# Comparing `tmp/landlab-2.7.0.tar.gz` & `tmp/landlab-2.8.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "landlab-2.7.0.tar", last modified: Sun Nov  5 04:32:52 2023, max compression
+gzip compressed data, was "landlab-2.8.0.tar", last modified: Sun May 12 23:30:00 2024, max compression
```

## Comparing `landlab-2.7.0.tar` & `landlab-2.8.0.tar`

### file list

```diff
@@ -1,960 +1,978 @@
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.358054 landlab-2.7.0/
--rw-r--r--   0 runner    (1001) docker     (127)     7029 2023-11-05 04:32:21.000000 landlab-2.7.0/.credits.toml
--rw-r--r--   0 runner    (1001) docker     (127)    15970 2023-11-05 04:32:21.000000 landlab-2.7.0/.mailmap
--rw-r--r--   0 runner    (1001) docker     (127)     2449 2023-11-05 04:32:21.000000 landlab-2.7.0/AUTHORS.rst
--rw-r--r--   0 runner    (1001) docker     (127)   525884 2023-11-05 04:32:21.000000 landlab-2.7.0/CHANGES.rst
--rw-r--r--   0 runner    (1001) docker     (127)     3193 2023-11-05 04:32:21.000000 landlab-2.7.0/CITATION.cff
--rw-r--r--   0 runner    (1001) docker     (127)     1445 2023-11-05 04:32:21.000000 landlab-2.7.0/FUNDING.rst
--rw-r--r--   0 runner    (1001) docker     (127)     1109 2023-11-05 04:32:21.000000 landlab-2.7.0/LICENSE.rst
--rw-r--r--   0 runner    (1001) docker     (127)     1142 2023-11-05 04:32:21.000000 landlab-2.7.0/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (127)    12479 2023-11-05 04:32:52.358054 landlab-2.7.0/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)     6836 2023-11-05 04:32:21.000000 landlab-2.7.0/README.rst
--rw-r--r--   0 runner    (1001) docker     (127)    61266 2023-11-05 04:32:21.000000 landlab-2.7.0/USEDBY.rst
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.266054 landlab-2.7.0/landlab/
--rw-r--r--   0 runner    (1001) docker     (127)     1653 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1195 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/_info.py
--rw-r--r--   0 runner    (1001) docker     (127)    11249 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/_registry.py
--rw-r--r--   0 runner    (1001) docker     (127)       22 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/_version.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.266054 landlab-2.7.0/landlab/bmi/
--rw-r--r--   0 runner    (1001) docker     (127)       91 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/bmi/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    18662 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/bmi/bmi_bridge.py
--rw-r--r--   0 runner    (1001) docker     (127)      392 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/bmi/components.py
--rw-r--r--   0 runner    (1001) docker     (127)     4429 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/bmi/standard_names.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.266054 landlab-2.7.0/landlab/ca/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/ca/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.266054 landlab-2.7.0/landlab/ca/boundaries/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/ca/boundaries/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    44972 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/ca/boundaries/hex_lattice_tectonicizer.py
--rw-r--r--   0 runner    (1001) docker     (127)    32191 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/ca/celllab_cts.py
--rw-r--r--   0 runner    (1001) docker     (127)    61106 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/ca/cfuncs.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     3788 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/ca/hex_cts.py
--rw-r--r--   0 runner    (1001) docker     (127)     5551 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/ca/oriented_hex_cts.py
--rw-r--r--   0 runner    (1001) docker     (127)     4815 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/ca/oriented_raster_cts.py
--rw-r--r--   0 runner    (1001) docker     (127)     3735 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/ca/raster_cts.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.266054 landlab-2.7.0/landlab/cmd/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/cmd/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7954 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/cmd/authors.py
--rw-r--r--   0 runner    (1001) docker     (127)    20106 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/cmd/landlab.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.266054 landlab-2.7.0/landlab/components/
--rw-r--r--   0 runner    (1001) docker     (127)     5644 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.266054 landlab-2.7.0/landlab/components/advection/
--rw-r--r--   0 runner    (1001) docker     (127)      316 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/advection/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    12463 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/advection/advection_solver_tvd.py
--rw-r--r--   0 runner    (1001) docker     (127)      459 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/advection/flux_limiters.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.266054 landlab-2.7.0/landlab/components/area_slope_transporter/
--rw-r--r--   0 runner    (1001) docker     (127)       93 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/area_slope_transporter/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9116 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/area_slope_transporter/area_slope_transporter.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.266054 landlab-2.7.0/landlab/components/bedrock_landslider/
--rw-r--r--   0 runner    (1001) docker     (127)       83 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/bedrock_landslider/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    28690 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/bedrock_landslider/bedrock_landslider.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2177 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/bedrock_landslider/cfuncs.pyx
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.270053 landlab-2.7.0/landlab/components/carbonate/
--rw-r--r--   0 runner    (1001) docker     (127)       83 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/carbonate/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10313 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/carbonate/carbonate_producer.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.270053 landlab-2.7.0/landlab/components/chi_index/
--rw-r--r--   0 runner    (1001) docker     (127)       60 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/chi_index/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    27378 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/chi_index/channel_chi.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.270053 landlab-2.7.0/landlab/components/depression_finder/
--rw-r--r--   0 runner    (1001) docker     (127)       92 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/depression_finder/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4981 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/depression_finder/cfuncs.pyx
--rw-r--r--   0 runner    (1001) docker     (127)      181 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/depression_finder/floodstatus.py
--rw-r--r--   0 runner    (1001) docker     (127)    54468 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/depression_finder/lake_mapper.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.270053 landlab-2.7.0/landlab/components/depth_dependent_diffusion/
--rw-r--r--   0 runner    (1001) docker     (127)      112 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/depth_dependent_diffusion/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9284 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/depth_dependent_diffusion/hillslope_depth_dependent_linear_flux.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.270053 landlab-2.7.0/landlab/components/depth_dependent_taylor_soil_creep/
--rw-r--r--   0 runner    (1001) docker     (127)      124 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/depth_dependent_taylor_soil_creep/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    19222 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/depth_dependent_taylor_soil_creep/hillslope_depth_dependent_taylor_flux.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.270053 landlab-2.7.0/landlab/components/detachment_ltd_erosion/
--rw-r--r--   0 runner    (1001) docker     (127)      200 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/detachment_ltd_erosion/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7123 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/detachment_ltd_erosion/generate_detachment_ltd_erosion.py
--rw-r--r--   0 runner    (1001) docker     (127)     8645 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/detachment_ltd_erosion/generate_erosion_by_depth_slope.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.270053 landlab-2.7.0/landlab/components/diffusion/
--rw-r--r--   0 runner    (1001) docker     (127)       68 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/diffusion/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    21778 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/diffusion/diffusion.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.270053 landlab-2.7.0/landlab/components/dimensionless_discharge/
--rw-r--r--   0 runner    (1001) docker     (127)      185 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/dimensionless_discharge/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     8316 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/dimensionless_discharge/dimensionless_discharge.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.270053 landlab-2.7.0/landlab/components/discharge_diffuser/
--rw-r--r--   0 runner    (1001) docker     (127)       85 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/discharge_diffuser/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    15298 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/discharge_diffuser/diffuse_by_discharge.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.270053 landlab-2.7.0/landlab/components/drainage_density/
--rw-r--r--   0 runner    (1001) docker     (127)       77 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/drainage_density/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2451 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/drainage_density/cfuncs.pyx
--rw-r--r--   0 runner    (1001) docker     (127)    17553 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/drainage_density/drainage_density.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.270053 landlab-2.7.0/landlab/components/erosion_deposition/
--rw-r--r--   0 runner    (1001) docker     (127)       83 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/erosion_deposition/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2265 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/erosion_deposition/cfuncs.pyx
--rw-r--r--   0 runner    (1001) docker     (127)    19680 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/erosion_deposition/erosion_deposition.py
--rw-r--r--   0 runner    (1001) docker     (127)     7305 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/erosion_deposition/generalized_erosion_deposition.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.270053 landlab-2.7.0/landlab/components/fire_generator/
--rw-r--r--   0 runner    (1001) docker     (127)       70 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/fire_generator/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5242 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/fire_generator/generate_fire.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.274053 landlab-2.7.0/landlab/components/flexure/
--rw-r--r--   0 runner    (1001) docker     (127)      343 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flexure/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2632 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flexure/cfuncs.pyx
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.274053 landlab-2.7.0/landlab/components/flexure/ext/
--rw-r--r--   0 runner    (1001) docker     (127)       70 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flexure/ext/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1472 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flexure/ext/flexure1d.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     9172 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flexure/flexure.py
--rw-r--r--   0 runner    (1001) docker     (127)    12378 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flexure/flexure_1d.py
--rw-r--r--   0 runner    (1001) docker     (127)     4799 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flexure/funcs.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.274053 landlab-2.7.0/landlab/components/flow_accum/
--rw-r--r--   0 runner    (1001) docker     (127)      386 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_accum/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3885 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_accum/cfuncs.pyx
--rw-r--r--   0 runner    (1001) docker     (127)    16827 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_accum/flow_accum_bw.py
--rw-r--r--   0 runner    (1001) docker     (127)    26737 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_accum/flow_accum_to_n.py
--rw-r--r--   0 runner    (1001) docker     (127)    52751 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_accum/flow_accumulator.py
--rw-r--r--   0 runner    (1001) docker     (127)    19619 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_accum/lossy_flow_accumulator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.274053 landlab-2.7.0/landlab/components/flow_director/
--rw-r--r--   0 runner    (1001) docker     (127)      466 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_director/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1965 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_director/cfuncs.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     4486 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_director/flow_direction_DN.py
--rw-r--r--   0 runner    (1001) docker     (127)    19058 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_director/flow_direction_dinf.py
--rw-r--r--   0 runner    (1001) docker     (127)    14667 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_director/flow_direction_mfd.py
--rw-r--r--   0 runner    (1001) docker     (127)     4791 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_director/flow_director.py
--rw-r--r--   0 runner    (1001) docker     (127)     9502 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_director/flow_director_d8.py
--rw-r--r--   0 runner    (1001) docker     (127)    13122 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_director/flow_director_dinf.py
--rw-r--r--   0 runner    (1001) docker     (127)    19850 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_director/flow_director_mfd.py
--rw-r--r--   0 runner    (1001) docker     (127)    26748 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_director/flow_director_steepest.py
--rw-r--r--   0 runner    (1001) docker     (127)     5189 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_director/flow_director_to_many.py
--rw-r--r--   0 runner    (1001) docker     (127)     6064 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_director/flow_director_to_one.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.274053 landlab-2.7.0/landlab/components/flow_router/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_router/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.274053 landlab-2.7.0/landlab/components/flow_router/ext/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_router/ext/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.274053 landlab-2.7.0/landlab/components/flow_router/ext/single_flow/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_router/ext/single_flow/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.274053 landlab-2.7.0/landlab/components/flow_router/ext/single_flow/priority_routing/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_router/ext/single_flow/priority_routing/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      382 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_router/ext/single_flow/priority_routing/_priority_queue.hpp
--rw-r--r--   0 runner    (1001) docker     (127)     2446 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_router/ext/single_flow/priority_routing/breach.pxd
--rw-r--r--   0 runner    (1001) docker     (127)    19209 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/flow_router/ext/single_flow/priority_routing/breach.pyx
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.274053 landlab-2.7.0/landlab/components/fracture_grid/
--rw-r--r--   0 runner    (1001) docker     (127)       86 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/fracture_grid/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    11365 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/fracture_grid/fracture_grid.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.278053 landlab-2.7.0/landlab/components/gflex/
--rw-r--r--   0 runner    (1001) docker     (127)       48 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/gflex/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10200 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/gflex/flexure.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.278053 landlab-2.7.0/landlab/components/gravel_bedrock_eroder/
--rw-r--r--   0 runner    (1001) docker     (127)       90 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/gravel_bedrock_eroder/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    31037 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/gravel_bedrock_eroder/gravel_bedrock_eroder.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.278053 landlab-2.7.0/landlab/components/gravel_river_transporter/
--rw-r--r--   0 runner    (1001) docker     (127)       99 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/gravel_river_transporter/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    22138 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/gravel_river_transporter/gravel_river_transporter.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.278053 landlab-2.7.0/landlab/components/groundwater/
--rw-r--r--   0 runner    (1001) docker     (127)     3392 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/groundwater/README.md
--rw-r--r--   0 runner    (1001) docker     (127)      207 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/groundwater/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    28617 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/groundwater/dupuit_percolator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.278053 landlab-2.7.0/landlab/components/hack_calculator/
--rw-r--r--   0 runner    (1001) docker     (127)       74 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/hack_calculator/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    11514 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/hack_calculator/hack_calculator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.278053 landlab-2.7.0/landlab/components/hand_calculator/
--rw-r--r--   0 runner    (1001) docker     (127)      189 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/hand_calculator/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6859 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/hand_calculator/hand_calculator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.278053 landlab-2.7.0/landlab/components/lake_fill/
--rw-r--r--   0 runner    (1001) docker     (127)       79 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/lake_fill/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)   100876 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/lake_fill/lake_fill_barnes.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.278053 landlab-2.7.0/landlab/components/landslides/
--rw-r--r--   0 runner    (1001) docker     (127)       92 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/landslides/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    27949 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/landslides/landslide_probability.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.278053 landlab-2.7.0/landlab/components/lateral_erosion/
--rw-r--r--   0 runner    (1001) docker     (127)       72 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/lateral_erosion/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    31611 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/lateral_erosion/lateral_erosion.py
--rw-r--r--   0 runner    (1001) docker     (127)    10241 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/lateral_erosion/node_finder.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.278053 landlab-2.7.0/landlab/components/lithology/
--rw-r--r--   0 runner    (1001) docker     (127)      765 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/lithology/README.md
--rw-r--r--   0 runner    (1001) docker     (127)      110 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/lithology/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8279 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/lithology/litholayers.py
--rw-r--r--   0 runner    (1001) docker     (127)    36900 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/lithology/lithology.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.278053 landlab-2.7.0/landlab/components/marine_sediment_transport/
--rw-r--r--   0 runner    (1001) docker     (127)      102 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/marine_sediment_transport/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7890 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/marine_sediment_transport/simple_submarine_diffuser.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.282054 landlab-2.7.0/landlab/components/network_sediment_transporter/
--rw-r--r--   0 runner    (1001) docker     (127)     2032 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/network_sediment_transporter/README.md
--rw-r--r--   0 runner    (1001) docker     (127)      612 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/network_sediment_transporter/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    27023 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/network_sediment_transporter/bed_parcel_initializers.py
--rw-r--r--   0 runner    (1001) docker     (127)    46453 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/network_sediment_transporter/network_sediment_transporter.py
--rw-r--r--   0 runner    (1001) docker     (127)    12400 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/network_sediment_transporter/sediment_pulser_at_links.py
--rw-r--r--   0 runner    (1001) docker     (127)     3096 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/network_sediment_transporter/sediment_pulser_base.py
--rw-r--r--   0 runner    (1001) docker     (127)    13031 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/network_sediment_transporter/sediment_pulser_each_parcel.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.282054 landlab-2.7.0/landlab/components/nonlinear_diffusion/
--rw-r--r--   0 runner    (1001) docker     (127)    62658 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/nonlinear_diffusion/Perron_nl_diffuse.py
--rw-r--r--   0 runner    (1001) docker     (127)       78 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/nonlinear_diffusion/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.282054 landlab-2.7.0/landlab/components/normal_fault/
--rw-r--r--   0 runner    (1001) docker     (127)       65 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/normal_fault/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    19729 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/normal_fault/normal_fault.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.282054 landlab-2.7.0/landlab/components/overland_flow/
--rw-r--r--   0 runner    (1001) docker     (127)      607 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/overland_flow/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    29246 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/overland_flow/_links.py
--rw-r--r--   0 runner    (1001) docker     (127)      918 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/overland_flow/_neighbors_at_link.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     8420 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/overland_flow/generate_overland_flow_Bates.py
--rw-r--r--   0 runner    (1001) docker     (127)    34908 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/overland_flow/generate_overland_flow_deAlmeida.py
--rw-r--r--   0 runner    (1001) docker     (127)    13694 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/overland_flow/generate_overland_flow_implicit_kinwave.py
--rw-r--r--   0 runner    (1001) docker     (127)     6226 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/overland_flow/generate_overland_flow_kinwave.py
--rw-r--r--   0 runner    (1001) docker     (127)    17391 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/overland_flow/kinematic_wave_rengers.py
--rw-r--r--   0 runner    (1001) docker     (127)    10430 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/overland_flow/linear_diffusion_overland_flow_router.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.282054 landlab-2.7.0/landlab/components/pet/
--rw-r--r--   0 runner    (1001) docker     (127)      119 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/pet/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    16886 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/pet/potential_evapotranspiration_field.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.282054 landlab-2.7.0/landlab/components/plant_competition_ca/
--rw-r--r--   0 runner    (1001) docker     (127)      100 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/plant_competition_ca/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    14387 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/plant_competition_ca/plant_competition_ca.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.282054 landlab-2.7.0/landlab/components/potentiality_flowrouting/
--rw-r--r--   0 runner    (1001) docker     (127)       97 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/potentiality_flowrouting/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    12240 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/potentiality_flowrouting/route_flow_by_boundary.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.282054 landlab-2.7.0/landlab/components/priority_flood_flow_router/
--rw-r--r--   0 runner    (1001) docker     (127)     2169 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/priority_flood_flow_router/README.md
--rw-r--r--   0 runner    (1001) docker     (127)      103 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/priority_flood_flow_router/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3509 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/priority_flood_flow_router/cfuncs.pyx
--rw-r--r--   0 runner    (1001) docker     (127)    37248 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/priority_flood_flow_router/priority_flood_flow_router.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.286054 landlab-2.7.0/landlab/components/profiler/
--rw-r--r--   0 runner    (1001) docker     (127)      219 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/profiler/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9120 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/profiler/base_profiler.py
--rw-r--r--   0 runner    (1001) docker     (127)    32587 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/profiler/channel_profiler.py
--rw-r--r--   0 runner    (1001) docker     (127)    13855 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/profiler/profiler.py
--rw-r--r--   0 runner    (1001) docker     (127)    14642 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/profiler/trickle_down_profiler.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.286054 landlab-2.7.0/landlab/components/radiation/
--rw-r--r--   0 runner    (1001) docker     (127)       58 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/radiation/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9001 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/radiation/radiation.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.286054 landlab-2.7.0/landlab/components/sink_fill/
--rw-r--r--   0 runner    (1001) docker     (127)      128 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/sink_fill/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    14103 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/sink_fill/fill_sinks.py
--rw-r--r--   0 runner    (1001) docker     (127)    12368 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/sink_fill/sink_fill_barnes.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.286054 landlab-2.7.0/landlab/components/soil_moisture/
--rw-r--r--   0 runner    (1001) docker     (127)      172 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/soil_moisture/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    14839 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/soil_moisture/infiltrate_soil_green_ampt.py
--rw-r--r--   0 runner    (1001) docker     (127)    26270 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/soil_moisture/soil_moisture_dynamics.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.286054 landlab-2.7.0/landlab/components/space/
--rw-r--r--   0 runner    (1001) docker     (127)      131 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/space/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.286054 landlab-2.7.0/landlab/components/space/ext/
--rw-r--r--   0 runner    (1001) docker     (127)     2305 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/space/ext/calc_qs.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     3899 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/space/ext/calc_sequential_ero_depo.pyx
--rw-r--r--   0 runner    (1001) docker     (127)    27131 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/space/space.py
--rw-r--r--   0 runner    (1001) docker     (127)    20743 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/space/space_large_scale_eroder.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.286054 landlab-2.7.0/landlab/components/spatial_precip/
--rw-r--r--   0 runner    (1001) docker     (127)      118 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/spatial_precip/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    81033 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/spatial_precip/generate_spatial_precip.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.286054 landlab-2.7.0/landlab/components/species_evolution/
--rw-r--r--   0 runner    (1001) docker     (127)     2222 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/species_evolution/README.md
--rw-r--r--   0 runner    (1001) docker     (127)      346 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/species_evolution/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4676 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/species_evolution/base_taxon.py
--rw-r--r--   0 runner    (1001) docker     (127)     6029 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/species_evolution/record.py
--rw-r--r--   0 runner    (1001) docker     (127)    25480 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/species_evolution/species_evolver.py
--rw-r--r--   0 runner    (1001) docker     (127)    10872 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/species_evolution/zone.py
--rw-r--r--   0 runner    (1001) docker     (127)    17335 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/species_evolution/zone_controller.py
--rw-r--r--   0 runner    (1001) docker     (127)    14012 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/species_evolution/zone_taxon.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.286054 landlab-2.7.0/landlab/components/steepness_index/
--rw-r--r--   0 runner    (1001) docker     (127)       78 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/steepness_index/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    24493 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/steepness_index/channel_steepness.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.290053 landlab-2.7.0/landlab/components/stream_power/
--rw-r--r--   0 runner    (1001) docker     (127)      343 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/stream_power/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    16849 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/stream_power/cfuncs.pyx
--rw-r--r--   0 runner    (1001) docker     (127)    13169 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/stream_power/fastscape_stream_power.py
--rw-r--r--   0 runner    (1001) docker     (127)    48241 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/stream_power/sed_flux_dep_incision.py
--rw-r--r--   0 runner    (1001) docker     (127)    17106 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/stream_power/stream_power.py
--rw-r--r--   0 runner    (1001) docker     (127)    12497 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/stream_power/stream_power_smooth_threshold.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.290053 landlab-2.7.0/landlab/components/taylor_nonlinear_hillslope_flux/
--rw-r--r--   0 runner    (1001) docker     (127)      108 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/taylor_nonlinear_hillslope_flux/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    12433 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/taylor_nonlinear_hillslope_flux/taylor_nonlinear_hillslope_flux.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.290053 landlab-2.7.0/landlab/components/tectonics/
--rw-r--r--   0 runner    (1001) docker     (127)      190 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/tectonics/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    10678 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/tectonics/listric_kinematic_extender.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.290053 landlab-2.7.0/landlab/components/threshold_eroder/
--rw-r--r--   0 runner    (1001) docker     (127)       77 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/threshold_eroder/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      883 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/threshold_eroder/cfuncs.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     7133 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/threshold_eroder/threshold_eroder.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.290053 landlab-2.7.0/landlab/components/tidal_flow/
--rw-r--r--   0 runner    (1001) docker     (127)      175 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/tidal_flow/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    12497 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/tidal_flow/tidal_flow_calculator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.290053 landlab-2.7.0/landlab/components/transport_length_diffusion/
--rw-r--r--   0 runner    (1001) docker     (127)      131 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/transport_length_diffusion/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10740 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/transport_length_diffusion/transport_length_hillslope_diffusion.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.290053 landlab-2.7.0/landlab/components/uniform_precip/
--rw-r--r--   0 runner    (1001) docker     (127)      104 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/uniform_precip/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    26774 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/uniform_precip/generate_uniform_precip.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.290053 landlab-2.7.0/landlab/components/vegetation_dynamics/
--rw-r--r--   0 runner    (1001) docker     (127)       70 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/vegetation_dynamics/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    21492 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/vegetation_dynamics/vegetation_dynamics.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.290053 landlab-2.7.0/landlab/components/weathering/
--rw-r--r--   0 runner    (1001) docker     (127)      205 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/weathering/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5305 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/weathering/exponential_weathering.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     8522 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/components/weathering/exponential_weathering_integrated.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.290053 landlab-2.7.0/landlab/core/
--rw-r--r--   0 runner    (1001) docker     (127)       75 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/core/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      798 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/core/errors.py
--rw-r--r--   0 runner    (1001) docker     (127)    12126 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/core/messages.py
--rw-r--r--   0 runner    (1001) docker     (127)    13473 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/core/model_component.py
--rw-r--r--   0 runner    (1001) docker     (127)     2008 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/core/model_parameter_loader.py
--rw-r--r--   0 runner    (1001) docker     (127)    20633 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/core/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.250053 landlab-2.7.0/landlab/data/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.250053 landlab-2.7.0/landlab/data/io/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.250053 landlab-2.7.0/landlab/data/io/shapefile/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.294054 landlab-2.7.0/landlab/data/io/shapefile/methow/
--rw-r--r--   0 runner    (1001) docker     (127)        6 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin.cpg
--rw-r--r--   0 runner    (1001) docker     (127)     2375 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin.dbf
--rw-r--r--   0 runner    (1001) docker     (127)      426 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin.prj
--rw-r--r--   0 runner    (1001) docker     (127)      436 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin.sbn
--rw-r--r--   0 runner    (1001) docker     (127)      148 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin.sbx
--rw-r--r--   0 runner    (1001) docker     (127)     8972 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin.shp
--rw-r--r--   0 runner    (1001) docker     (127)      921 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin.shp.xml
--rw-r--r--   0 runner    (1001) docker     (127)      332 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin.shx
--rw-r--r--   0 runner    (1001) docker     (127)        6 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.CPG
--rw-r--r--   0 runner    (1001) docker     (127)     2896 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.dbf
--rw-r--r--   0 runner    (1001) docker     (127)      426 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.prj
--rw-r--r--   0 runner    (1001) docker     (127)      428 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.sbn
--rw-r--r--   0 runner    (1001) docker     (127)      132 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.sbx
--rw-r--r--   0 runner    (1001) docker     (127)      940 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.shp
--rw-r--r--   0 runner    (1001) docker     (127)      506 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.shp.xml
--rw-r--r--   0 runner    (1001) docker     (127)      340 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.shx
--rwxr-xr-x   0 runner    (1001) docker     (127)    52818 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/Methow_Network.dbf
--rwxr-xr-x   0 runner    (1001) docker     (127)   259316 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/Methow_Network.shp
--rwxr-xr-x   0 runner    (1001) docker     (127)     5860 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/methow/Methow_Network.shx
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.294054 landlab-2.7.0/landlab/data/io/shapefile/redb/
--rw-r--r--   0 runner    (1001) docker     (127)        6 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_network.cpg
--rw-r--r--   0 runner    (1001) docker     (127)     1226 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_network.dbf
--rw-r--r--   0 runner    (1001) docker     (127)      426 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_network.prj
--rw-r--r--   0 runner    (1001) docker     (127)      252 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_network.sbn
--rw-r--r--   0 runner    (1001) docker     (127)      132 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_network.sbx
--rw-r--r--   0 runner    (1001) docker     (127)     5188 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_network.shp
--rw-r--r--   0 runner    (1001) docker     (127)     1946 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_network.shp.xml
--rw-r--r--   0 runner    (1001) docker     (127)      196 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_network.shx
--rw-r--r--   0 runner    (1001) docker     (127)        6 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_nodes_att.CPG
--rw-r--r--   0 runner    (1001) docker     (127)     1169 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_nodes_att.dbf
--rw-r--r--   0 runner    (1001) docker     (127)      426 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_nodes_att.prj
--rw-r--r--   0 runner    (1001) docker     (127)      252 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_nodes_att.sbn
--rw-r--r--   0 runner    (1001) docker     (127)      124 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_nodes_att.sbx
--rw-r--r--   0 runner    (1001) docker     (127)      464 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_nodes_att.shp
--rw-r--r--   0 runner    (1001) docker     (127)     3993 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_nodes_att.shp.xml
--rw-r--r--   0 runner    (1001) docker     (127)      204 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/redb/a001_nodes_att.shx
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.298054 landlab-2.7.0/landlab/data/io/shapefile/soque/
--rw-r--r--   0 runner    (1001) docker     (127)        6 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Links.cpg
--rw-r--r--   0 runner    (1001) docker     (127)   371672 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Links.dbf
--rw-r--r--   0 runner    (1001) docker     (127)      168 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Links.prj
--rw-r--r--   0 runner    (1001) docker     (127)     1038 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Links.qmd
--rw-r--r--   0 runner    (1001) docker     (127)   402332 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Links.shp
--rw-r--r--   0 runner    (1001) docker     (127)     2636 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Links.shx
--rw-r--r--   0 runner    (1001) docker     (127)        6 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Nodes.cpg
--rw-r--r--   0 runner    (1001) docker     (127)   383714 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Nodes.dbf
--rw-r--r--   0 runner    (1001) docker     (127)      168 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Nodes.prj
--rw-r--r--   0 runner    (1001) docker     (127)     1031 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Nodes.qmd
--rw-r--r--   0 runner    (1001) docker     (127)     9004 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Nodes.shp
--rw-r--r--   0 runner    (1001) docker     (127)     2644 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Nodes.shx
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.298054 landlab-2.7.0/landlab/data_record/
--rw-r--r--   0 runner    (1001) docker     (127)       62 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data_record/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    53142 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/data_record/data_record.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.298054 landlab-2.7.0/landlab/field/
--rw-r--r--   0 runner    (1001) docker     (127)      188 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/field/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      975 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/field/errors.py
--rw-r--r--   0 runner    (1001) docker     (127)    43287 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/field/graph_field.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.298054 landlab-2.7.0/landlab/framework/
--rw-r--r--   0 runner    (1001) docker     (127)       38 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/framework/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2494 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/framework/component.py
--rw-r--r--   0 runner    (1001) docker     (127)     1008 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/framework/decorators.py
--rw-r--r--   0 runner    (1001) docker     (127)     5040 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/framework/interfaces.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.302054 landlab-2.7.0/landlab/graph/
--rw-r--r--   0 runner    (1001) docker     (127)     1014 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    13538 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/cfuncs.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     3355 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/dual.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.302054 landlab-2.7.0/landlab/graph/ext/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/ext/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.302054 landlab-2.7.0/landlab/graph/framed_voronoi/
--rw-r--r--   0 runner    (1001) docker     (127)      163 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/framed_voronoi/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3273 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/framed_voronoi/dual_framed_voronoi.py
--rw-r--r--   0 runner    (1001) docker     (127)    15675 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/framed_voronoi/framed_voronoi.py
--rw-r--r--   0 runner    (1001) docker     (127)    32872 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/graph.py
--rw-r--r--   0 runner    (1001) docker     (127)     4940 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/graph_convention.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.302054 landlab-2.7.0/landlab/graph/hex/
--rw-r--r--   0 runner    (1001) docker     (127)      101 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/hex/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3199 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/hex/dual_hex.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.302054 landlab-2.7.0/landlab/graph/hex/ext/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/hex/ext/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10660 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/hex/ext/hex.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     6873 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/hex/ext/perimeternodes.pyx
--rw-r--r--   0 runner    (1001) docker     (127)    32338 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/hex/hex.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.302054 landlab-2.7.0/landlab/graph/matrix/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/matrix/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1533 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/matrix/at_node.py
--rw-r--r--   0 runner    (1001) docker     (127)     1248 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/matrix/at_patch.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.302054 landlab-2.7.0/landlab/graph/matrix/ext/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/matrix/ext/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      726 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/matrix/ext/at_patch.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     1204 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/matrix/ext/matrix.pyx
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.302054 landlab-2.7.0/landlab/graph/object/
--rw-r--r--   0 runner    (1001) docker     (127)       46 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/object/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4675 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/object/at_node.py
--rw-r--r--   0 runner    (1001) docker     (127)      617 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/object/at_patch.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.302054 landlab-2.7.0/landlab/graph/object/ext/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/object/ext/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3840 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/object/ext/at_node.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     3721 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/object/ext/at_patch.pyx
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.302054 landlab-2.7.0/landlab/graph/quantity/
--rw-r--r--   0 runner    (1001) docker     (127)       51 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/quantity/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.302054 landlab-2.7.0/landlab/graph/quantity/ext/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/quantity/ext/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      806 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/quantity/ext/of_link.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     3888 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/quantity/ext/of_patch.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     2489 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/quantity/of_link.py
--rw-r--r--   0 runner    (1001) docker     (127)     1204 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/quantity/of_patch.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.306054 landlab-2.7.0/landlab/graph/radial/
--rw-r--r--   0 runner    (1001) docker     (127)      119 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/radial/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1915 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/radial/dual_radial.py
--rw-r--r--   0 runner    (1001) docker     (127)     7143 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/radial/radial.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.306054 landlab-2.7.0/landlab/graph/sort/
--rw-r--r--   0 runner    (1001) docker     (127)      293 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/sort/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.306054 landlab-2.7.0/landlab/graph/sort/ext/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/sort/ext/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      182 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/sort/ext/argsort.pxd
--rw-r--r--   0 runner    (1001) docker     (127)     2878 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/sort/ext/argsort.pyx
--rw-r--r--   0 runner    (1001) docker     (127)    11982 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/sort/ext/remap_element.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     6881 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/sort/ext/spoke_sort.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     5343 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/sort/intpair.py
--rw-r--r--   0 runner    (1001) docker     (127)    22008 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/sort/sort.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.306054 landlab-2.7.0/landlab/graph/structured_quad/
--rw-r--r--   0 runner    (1001) docker     (127)      426 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/structured_quad/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5792 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/structured_quad/dual_structured_quad.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.306054 landlab-2.7.0/landlab/graph/structured_quad/ext/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/structured_quad/ext/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      836 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/structured_quad/ext/at_cell.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     1192 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/structured_quad/ext/at_face.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     3712 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/structured_quad/ext/at_link.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     8435 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/structured_quad/ext/at_node.pyx
--rw-r--r--   0 runner    (1001) docker     (127)      821 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/structured_quad/ext/at_patch.pyx
--rw-r--r--   0 runner    (1001) docker     (127)    24208 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/structured_quad/structured_quad.py
--rw-r--r--   0 runner    (1001) docker     (127)     2487 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/ugrid.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.306054 landlab-2.7.0/landlab/graph/voronoi/
--rw-r--r--   0 runner    (1001) docker     (127)      127 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/voronoi/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2288 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/voronoi/dual_voronoi.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.306054 landlab-2.7.0/landlab/graph/voronoi/ext/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/voronoi/ext/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3335 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/voronoi/ext/delaunay.pyx
--rw-r--r--   0 runner    (1001) docker     (127)    11427 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/voronoi/ext/voronoi.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     1776 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/voronoi/voronoi.py
--rw-r--r--   0 runner    (1001) docker     (127)    11800 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/graph/voronoi/voronoi_to_graph.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.310054 landlab-2.7.0/landlab/grid/
--rw-r--r--   0 runner    (1001) docker     (127)      480 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)   110041 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/base.py
--rw-r--r--   0 runner    (1001) docker     (127)     3764 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/cfuncs.pyx
--rw-r--r--   0 runner    (1001) docker     (127)    15455 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/create.py
--rw-r--r--   0 runner    (1001) docker     (127)    22205 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/create_network.py
--rw-r--r--   0 runner    (1001) docker     (127)     4203 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/decorators.py
--rw-r--r--   0 runner    (1001) docker     (127)    15227 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/diagonals.py
--rw-r--r--   0 runner    (1001) docker     (127)    29099 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/divergence.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.310054 landlab-2.7.0/landlab/grid/ext/
--rw-r--r--   0 runner    (1001) docker     (127)     1042 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/ext/raster_divergence.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     2578 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/ext/raster_gradient.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     5510 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/framed_voronoi.py
--rw-r--r--   0 runner    (1001) docker     (127)    18101 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/gradients.py
--rw-r--r--   0 runner    (1001) docker     (127)     1196 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/grid_funcs.py
--rw-r--r--   0 runner    (1001) docker     (127)    21242 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/hex.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     6813 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/hex_mappers.py
--rw-r--r--   0 runner    (1001) docker     (127)      170 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/linkorientation.py
--rw-r--r--   0 runner    (1001) docker     (127)     5214 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/linkstatus.py
--rw-r--r--   0 runner    (1001) docker     (127)    56320 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/mappers.py
--rw-r--r--   0 runner    (1001) docker     (127)    12026 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/network.py
--rw-r--r--   0 runner    (1001) docker     (127)      457 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/nodestatus.py
--rw-r--r--   0 runner    (1001) docker     (127)     5462 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/radial.py
--rw-r--r--   0 runner    (1001) docker     (127)    91099 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/raster.py
--rw-r--r--   0 runner    (1001) docker     (127)     4104 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/raster_aspect.py
--rw-r--r--   0 runner    (1001) docker     (127)     3133 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/raster_divergence.py
--rw-r--r--   0 runner    (1001) docker     (127)    11705 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/raster_funcs.py
--rw-r--r--   0 runner    (1001) docker     (127)    68727 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/raster_gradients.py
--rw-r--r--   0 runner    (1001) docker     (127)    28190 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/raster_mappers.py
--rw-r--r--   0 runner    (1001) docker     (127)     2629 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/raster_set_status.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.310054 landlab-2.7.0/landlab/grid/unstructured/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/unstructured/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    19397 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/unstructured/base.py
--rw-r--r--   0 runner    (1001) docker     (127)     3818 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/unstructured/cells.py
--rw-r--r--   0 runner    (1001) docker     (127)    18226 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/unstructured/links.py
--rw-r--r--   0 runner    (1001) docker     (127)     4387 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/unstructured/nodes.py
--rw-r--r--   0 runner    (1001) docker     (127)     2326 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/unstructured/status.py
--rw-r--r--   0 runner    (1001) docker     (127)     7539 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/voronoi.py
--rw-r--r--   0 runner    (1001) docker     (127)      904 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/grid/warnings.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.314054 landlab-2.7.0/landlab/io/
--rw-r--r--   0 runner    (1001) docker     (127)      822 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    17085 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/esri_ascii.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.314054 landlab-2.7.0/landlab/io/legacy_vtk/
--rw-r--r--   0 runner    (1001) docker     (127)       80 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/legacy_vtk/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5311 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/legacy_vtk/legacy_vtk.py
--rw-r--r--   0 runner    (1001) docker     (127)     3136 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/native_landlab.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.314054 landlab-2.7.0/landlab/io/netcdf/
--rw-r--r--   0 runner    (1001) docker     (127)      323 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/netcdf/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1206 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/netcdf/_constants.py
--rw-r--r--   0 runner    (1001) docker     (127)     4841 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/netcdf/dump.py
--rw-r--r--   0 runner    (1001) docker     (127)      387 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/netcdf/errors.py
--rw-r--r--   0 runner    (1001) docker     (127)     3052 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/netcdf/load.py
--rw-r--r--   0 runner    (1001) docker     (127)    11746 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/netcdf/read.py
--rw-r--r--   0 runner    (1001) docker     (127)    23951 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/netcdf/write.py
--rw-r--r--   0 runner    (1001) docker     (127)     4459 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/obj.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.314054 landlab-2.7.0/landlab/io/shapefile/
--rw-r--r--   0 runner    (1001) docker     (127)       73 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/shapefile/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    16199 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/io/shapefile/read_shapefile.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.314054 landlab-2.7.0/landlab/layers/
--rw-r--r--   0 runner    (1001) docker     (127)      207 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/layers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    29591 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/layers/eventlayers.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.314054 landlab-2.7.0/landlab/layers/ext/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/layers/ext/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1308 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/layers/ext/eventlayers.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     9411 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/layers/materiallayers.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.314054 landlab-2.7.0/landlab/plot/
--rw-r--r--   0 runner    (1001) docker     (127)      421 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/plot/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1381 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/plot/colors.py
--rw-r--r--   0 runner    (1001) docker     (127)     3706 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/plot/drainage_plot.py
--rw-r--r--   0 runner    (1001) docker     (127)     1655 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/plot/event_handler.py
--rw-r--r--   0 runner    (1001) docker     (127)     4562 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/plot/graph.py
--rw-r--r--   0 runner    (1001) docker     (127)    21012 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/plot/imshow.py
--rw-r--r--   0 runner    (1001) docker     (127)    38891 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/plot/imshowhs.py
--rw-r--r--   0 runner    (1001) docker     (127)     7879 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/plot/layers.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.314054 landlab-2.7.0/landlab/plot/network_sediment_transporter/
--rw-r--r--   0 runner    (1001) docker     (127)      163 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/plot/network_sediment_transporter/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4104 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/plot/network_sediment_transporter/locate_parcel_xy.py
--rw-r--r--   0 runner    (1001) docker     (127)    18171 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/plot/network_sediment_transporter/plot_network_and_parcels.py
--rw-r--r--   0 runner    (1001) docker     (127)     9258 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/plot/video_out.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.318054 landlab-2.7.0/landlab/utils/
--rw-r--r--   0 runner    (1001) docker     (127)     1190 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2824 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/_matrix.pyx
--rw-r--r--   0 runner    (1001) docker     (127)     1173 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/add_halo.py
--rw-r--r--   0 runner    (1001) docker     (127)     2358 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/count_repeats.py
--rw-r--r--   0 runner    (1001) docker     (127)    11407 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/decorators.py
--rw-r--r--   0 runner    (1001) docker     (127)     4203 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/depth_dependent_roughness.py
--rw-r--r--   0 runner    (1001) docker     (127)     8486 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/distance_to_divide.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.318054 landlab-2.7.0/landlab/utils/ext/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/ext/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      799 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/ext/jaggedarray.pyx
--rw-r--r--   0 runner    (1001) docker     (127)    23769 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/fault_facet_finder.py
--rw-r--r--   0 runner    (1001) docker     (127)     8727 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/flow__distance.py
--rw-r--r--   0 runner    (1001) docker     (127)    10519 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/jaggedarray.py
--rw-r--r--   0 runner    (1001) docker     (127)     9436 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/jaggedarray_ma.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     7413 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/matrix.py
--rw-r--r--   0 runner    (1001) docker     (127)     1205 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/return_array.py
--rw-r--r--   0 runner    (1001) docker     (127)    11695 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/source_tracking_algorithm.py
--rw-r--r--   0 runner    (1001) docker     (127)     3853 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/stable_priority_queue.py
--rw-r--r--   0 runner    (1001) docker     (127)    57226 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/structured_grid.py
--rw-r--r--   0 runner    (1001) docker     (127)      868 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/suppress_output.py
--rw-r--r--   0 runner    (1001) docker     (127)    13078 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/watershed.py
--rw-r--r--   0 runner    (1001) docker     (127)     8678 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/utils/window_statistic.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.318054 landlab-2.7.0/landlab/values/
--rw-r--r--   0 runner    (1001) docker     (127)      120 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/values/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    15072 2023-11-05 04:32:21.000000 landlab-2.7.0/landlab/values/synthetic.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.266054 landlab-2.7.0/landlab.egg-info/
--rw-r--r--   0 runner    (1001) docker     (127)    12479 2023-11-05 04:32:51.000000 landlab-2.7.0/landlab.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)    33319 2023-11-05 04:32:52.000000 landlab-2.7.0/landlab.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2023-11-05 04:32:52.000000 landlab-2.7.0/landlab.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (127)       56 2023-11-05 04:32:52.000000 landlab-2.7.0/landlab.egg-info/entry_points.txt
--rw-r--r--   0 runner    (1001) docker     (127)      195 2023-11-05 04:32:52.000000 landlab-2.7.0/landlab.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (127)       14 2023-11-05 04:32:52.000000 landlab-2.7.0/landlab.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (127)     3849 2023-11-05 04:32:21.000000 landlab-2.7.0/notebooks.py
--rw-r--r--   0 runner    (1001) docker     (127)    12058 2023-11-05 04:32:22.000000 landlab-2.7.0/noxfile.py
--rw-r--r--   0 runner    (1001) docker     (127)     4278 2023-11-05 04:32:22.000000 landlab-2.7.0/pyproject.toml
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.318054 landlab-2.7.0/requirements/
--rw-r--r--   0 runner    (1001) docker     (127)      470 2023-11-05 04:32:22.000000 landlab-2.7.0/requirements/README.md
--rw-r--r--   0 runner    (1001) docker     (127)      214 2023-11-05 04:32:22.000000 landlab-2.7.0/requirements/docs.txt
--rw-r--r--   0 runner    (1001) docker     (127)       90 2023-11-05 04:32:22.000000 landlab-2.7.0/requirements/notebooks.txt
--rw-r--r--   0 runner    (1001) docker     (127)      171 2023-11-05 04:32:22.000000 landlab-2.7.0/requirements/required.txt
--rw-r--r--   0 runner    (1001) docker     (127)      147 2023-11-05 04:32:22.000000 landlab-2.7.0/requirements/testing.txt
--rw-r--r--   0 runner    (1001) docker     (127)      177 2023-11-05 04:32:22.000000 landlab-2.7.0/requirements-testing.in
--rw-r--r--   0 runner    (1001) docker     (127)      111 2023-11-05 04:32:22.000000 landlab-2.7.0/requirements.in
--rw-r--r--   0 runner    (1001) docker     (127)      312 2023-11-05 04:32:52.358054 landlab-2.7.0/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (127)      776 2023-11-05 04:32:22.000000 landlab-2.7.0/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.318054 landlab-2.7.0/tests/
--rw-r--r--   0 runner    (1001) docker     (127)       41 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/ca/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/ca/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/ca/boundaries/
--rw-r--r--   0 runner    (1001) docker     (127)     3223 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/ca/boundaries/test_hex_normal_fault.py
--rw-r--r--   0 runner    (1001) docker     (127)     5404 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/ca/cts_model.py
--rw-r--r--   0 runner    (1001) docker     (127)    16345 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/ca/grain_hill.py
--rw-r--r--   0 runner    (1001) docker     (127)      377 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/ca/grain_hill_params.txt
--rw-r--r--   0 runner    (1001) docker     (127)    37425 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/ca/lattice_grain.py
--rw-r--r--   0 runner    (1001) docker     (127)    14651 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/ca/test_celllab_cts.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     5191 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/ca/test_user_guide_example.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/components/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/components/advection_solver/
--rw-r--r--   0 runner    (1001) docker     (127)     9751 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/advection_solver/test_advection_solver.py
--rw-r--r--   0 runner    (1001) docker     (127)      560 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/advection_solver/test_flux_limiters.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/components/bedrock_landslider/
--rw-r--r--   0 runner    (1001) docker     (127)    13794 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/bedrock_landslider/test_bedrock_landslider.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/components/carbonate/
--rw-r--r--   0 runner    (1001) docker     (127)     2122 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/carbonate/test_carbonate_producer.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/components/chi_index/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/chi_index/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1107 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/chi_index/test_chi_finder.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/components/depression_finder/
--rw-r--r--   0 runner    (1001) docker     (127)     5408 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/depression_finder/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)    43205 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/depression_finder/test_lake_mapper.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/components/depth_dependent_diffusion/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/depth_dependent_diffusion/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      752 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/depth_dependent_diffusion/test_depth_dependent_diffuser.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/components/depth_dependent_taylor_soil_creep/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/depth_dependent_taylor_soil_creep/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4589 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/depth_dependent_taylor_soil_creep/test_depth_dependent_taylor_diffuser.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/components/diffusion/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/diffusion/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10621 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/diffusion/test_sniff_diffusion.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/components/dimensionless_discharge/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/dimensionless_discharge/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2449 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/dimensionless_discharge/test_dimensionless_discharge.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/components/drainage_density/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/drainage_density/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8665 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/drainage_density/test_drainage_density.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.322054 landlab-2.7.0/tests/components/erosion_deposition/
--rw-r--r--   0 runner    (1001) docker     (127)     5495 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/erosion_deposition/test_ero_dep_mass_conservation.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     6741 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/erosion_deposition/test_ero_dep_with_flats.py
--rw-r--r--   0 runner    (1001) docker     (127)     6346 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/erosion_deposition/test_erodep.py
--rw-r--r--   0 runner    (1001) docker     (127)     5912 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/erosion_deposition/test_erodep_steady_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     7084 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/erosion_deposition/test_general_erodep.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/flexure/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flexure/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      851 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flexure/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     3692 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flexure/test_api.py
--rw-r--r--   0 runner    (1001) docker     (127)     4456 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flexure/test_flexure.py
--rw-r--r--   0 runner    (1001) docker     (127)    11457 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flexure/test_flexure_1d.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/flow_accum/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_accum/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7689 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_accum/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     1364 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_accum/test_flow_accums.py
--rw-r--r--   0 runner    (1001) docker     (127)    32433 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_accum/test_flow_accumulator.py
--rw-r--r--   0 runner    (1001) docker     (127)     7610 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_accum/test_flow_routing.py
--rw-r--r--   0 runner    (1001) docker     (127)    31937 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_accum/test_lossy_flow_accumulator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/flow_director/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_director/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4362 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_director/test_cfuncs.py
--rw-r--r--   0 runner    (1001) docker     (127)     7833 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_director/test_dinf.py
--rw-r--r--   0 runner    (1001) docker     (127)    12037 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_director/test_flow_director.py
--rw-r--r--   0 runner    (1001) docker     (127)     7736 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_director/test_mfd.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.254053 landlab-2.7.0/tests/components/flow_router/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.254053 landlab-2.7.0/tests/components/flow_router/ext/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.254053 landlab-2.7.0/tests/components/flow_router/ext/single_flow/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/flow_router/ext/single_flow/priority_routing/
--rw-r--r--   0 runner    (1001) docker     (127)      382 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_router/ext/single_flow/priority_routing/_priority_queue.hpp
--rw-r--r--   0 runner    (1001) docker     (127)      505 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_router/ext/single_flow/priority_routing/test_breach.py
--rw-r--r--   0 runner    (1001) docker     (127)      425 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_router/ext/single_flow/priority_routing/test_breach_c.pxd
--rw-r--r--   0 runner    (1001) docker     (127)    22661 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/flow_router/ext/single_flow/priority_routing/test_breach_c.pyx
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/fracture_grid/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/fracture_grid/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      933 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/fracture_grid/test_fracture_grid.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/gravel_bedrock_eroder/
--rw-r--r--   0 runner    (1001) docker     (127)     6122 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/gravel_bedrock_eroder/test_gravel_bedrock_eroder.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/gravel_river_transporter/
--rw-r--r--   0 runner    (1001) docker     (127)     9071 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/gravel_river_transporter/test_gravel_river_transporter.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/groundwater/
--rw-r--r--   0 runner    (1001) docker     (127)    12140 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/groundwater/test_dupuit_percolator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/hack_calculator/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/hack_calculator/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      966 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/hack_calculator/test_hack.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/hand_calculator/
--rw-r--r--   0 runner    (1001) docker     (127)     1063 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/hand_calculator/test_hand.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/lake_fill/
--rw-r--r--   0 runner    (1001) docker     (127)     6794 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/lake_fill/test_lake_fill.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/landslides/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/landslides/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      835 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/landslides/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     9590 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/landslides/test_landslide_probability.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/lateral_erosion/
--rw-r--r--   0 runner    (1001) docker     (127)    10779 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/lateral_erosion/test_latero.py
--rw-r--r--   0 runner    (1001) docker     (127)     1733 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/lateral_erosion/test_node_finder.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.326054 landlab-2.7.0/tests/components/lithology/
--rw-r--r--   0 runner    (1001) docker     (127)     2026 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/lithology/test_litholayers.py
--rw-r--r--   0 runner    (1001) docker     (127)    11548 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/lithology/test_lithology.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.330054 landlab-2.7.0/tests/components/marine_sediment_transport/
--rw-r--r--   0 runner    (1001) docker     (127)     5062 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/marine_sediment_transport/test_simple_submarine_diffuser.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.330054 landlab-2.7.0/tests/components/network_sediment_transporter/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4561 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     2022 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/test_abrasion.py
--rw-r--r--   0 runner    (1001) docker     (127)     3796 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/test_active_layer_methods.py
--rw-r--r--   0 runner    (1001) docker     (127)     8641 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/test_bed_initializer.py
--rw-r--r--   0 runner    (1001) docker     (127)     3500 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/test_filo.py
--rw-r--r--   0 runner    (1001) docker     (127)     2225 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/test_init.py
--rw-r--r--   0 runner    (1001) docker     (127)     1097 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/test_init_sediment_pulser.py
--rw-r--r--   0 runner    (1001) docker     (127)     1708 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/test_parcel_leaves.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     4708 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/test_pulse_sediment.py
--rw-r--r--   0 runner    (1001) docker     (127)     3111 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/test_recycling.py
--rw-r--r--   0 runner    (1001) docker     (127)    23051 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/test_sediment_pulser.py
--rw-r--r--   0 runner    (1001) docker     (127)     4300 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/network_sediment_transporter/test_transport.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.330054 landlab-2.7.0/tests/components/nonlinear_diffusion/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/nonlinear_diffusion/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5194 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/nonlinear_diffusion/test_sniff_nldiff.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.330054 landlab-2.7.0/tests/components/normal_fault/
--rw-r--r--   0 runner    (1001) docker     (127)     8582 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/normal_fault/test_normal_fault.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.330054 landlab-2.7.0/tests/components/overland_flow/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/overland_flow/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1001 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/overland_flow/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     5377 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/overland_flow/test_active_links_at_node.py
--rw-r--r--   0 runner    (1001) docker     (127)     2651 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/overland_flow/test_bates_overland_flow.py
--rw-r--r--   0 runner    (1001) docker     (127)     6292 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/overland_flow/test_dealmeida_overland_flow.py
--rw-r--r--   0 runner    (1001) docker     (127)     2452 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/overland_flow/test_kinwave.py
--rw-r--r--   0 runner    (1001) docker     (127)     5049 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/overland_flow/test_kinwave_implicit.py
--rw-r--r--   0 runner    (1001) docker     (127)     2112 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/overland_flow/test_linear_diffusion_overland_flow.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.330054 landlab-2.7.0/tests/components/pet/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/pet/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      352 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/pet/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     2546 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/pet/test_pet.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.330054 landlab-2.7.0/tests/components/plant_competition_ca/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/plant_competition_ca/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      386 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/plant_competition_ca/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     2228 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/plant_competition_ca/test_plant_competition_ca.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.330054 landlab-2.7.0/tests/components/potentiality_flowrouting/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/potentiality_flowrouting/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)       40 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/potentiality_flowrouting/pot_fr_params.txt
--rw-r--r--   0 runner    (1001) docker     (127)    12124 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/potentiality_flowrouting/test_sniff_pot_fr.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.334054 landlab-2.7.0/tests/components/priority_flood_flow_router/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/priority_flood_flow_router/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    29708 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/priority_flood_flow_router/test_priority_flood_flow_router.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.334054 landlab-2.7.0/tests/components/profiler/
--rw-r--r--   0 runner    (1001) docker     (127)      835 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/profiler/test_base_profiler.py
--rw-r--r--   0 runner    (1001) docker     (127)    12972 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/profiler/test_channel_profile.py
--rw-r--r--   0 runner    (1001) docker     (127)     3162 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/profiler/test_profiler.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.334054 landlab-2.7.0/tests/components/radiation/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/radiation/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      278 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/radiation/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     2339 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/radiation/test_radiation.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.334054 landlab-2.7.0/tests/components/sink_fill/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/sink_fill/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5002 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/sink_fill/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     8701 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/sink_fill/test_sink_filler.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.334054 landlab-2.7.0/tests/components/soil_moisture/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/soil_moisture/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1597 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/soil_moisture/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     2805 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/soil_moisture/test_green_ampt_infil.py
--rw-r--r--   0 runner    (1001) docker     (127)     3042 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/soil_moisture/test_soil_moisture.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.334054 landlab-2.7.0/tests/components/space/
--rw-r--r--   0 runner    (1001) docker     (127)    15130 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/space/test_space.py
--rw-r--r--   0 runner    (1001) docker     (127)    33081 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/space/test_space_large_scale_eroder.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.334054 landlab-2.7.0/tests/components/spatial_precip/
--rw-r--r--   0 runner    (1001) docker     (127)     7800 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/spatial_precip/BCs_Singer.txt
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/spatial_precip/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7800 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/spatial_precip/elevs_Singer.txt
--rw-r--r--   0 runner    (1001) docker     (127)     5761 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/spatial_precip/test_spatial_storm_generator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.334054 landlab-2.7.0/tests/components/species_evolution/
--rw-r--r--   0 runner    (1001) docker     (127)     1482 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/species_evolution/test_base_taxon.py
--rw-r--r--   0 runner    (1001) docker     (127)     2646 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/species_evolution/test_record.py
--rw-r--r--   0 runner    (1001) docker     (127)     5555 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/species_evolution/test_species_evolver.py
--rw-r--r--   0 runner    (1001) docker     (127)    14245 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/species_evolution/test_zone_objects.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.334054 landlab-2.7.0/tests/components/steepness_index/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/steepness_index/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      436 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/steepness_index/test_steepness_finder.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.338054 landlab-2.7.0/tests/components/stream_power/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    31250 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/perturbedcondst300.txt
--rw-r--r--   0 runner    (1001) docker     (127)    62500 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/seddepinit.txt
--rw-r--r--   0 runner    (1001) docker     (127)    62500 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/seddepz_tg.txt
--rw-r--r--   0 runner    (1001) docker     (127)    31250 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/tenmorestepsfrom300.txt
--rw-r--r--   0 runner    (1001) docker     (127)     5138 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/test_fastscape.py
--rw-r--r--   0 runner    (1001) docker     (127)     1595 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/test_not_implemented_errors.py
--rw-r--r--   0 runner    (1001) docker     (127)     2807 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/test_sed_flux_dep.py
--rw-r--r--   0 runner    (1001) docker     (127)     5161 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/test_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     2346 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/test_smooth_thresh.py
--rw-r--r--   0 runner    (1001) docker     (127)     3354 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/test_sp_driver_discharges.py
--rw-r--r--   0 runner    (1001) docker     (127)     2211 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/test_sp_driver_widths.py
--rw-r--r--   0 runner    (1001) docker     (127)     1621 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/test_sp_storms.py
--rw-r--r--   0 runner    (1001) docker     (127)     3793 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/stream_power/test_voronoi_sp.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.338054 landlab-2.7.0/tests/components/taylor_nonlinear_hillslope_flux/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/taylor_nonlinear_hillslope_flux/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1522 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/taylor_nonlinear_hillslope_flux/test_taylor_nonlinear_hillslope_flux.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.338054 landlab-2.7.0/tests/components/tectonics/
--rw-r--r--   0 runner    (1001) docker     (127)     1996 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/tectonics/test_listric_kinematic_extender.py
--rw-r--r--   0 runner    (1001) docker     (127)     5690 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/test_components.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.338054 landlab-2.7.0/tests/components/threshold_eroder/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/threshold_eroder/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4174 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/threshold_eroder/test_threshold_eroder.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.338054 landlab-2.7.0/tests/components/tidal_flow_calculator/
--rw-r--r--   0 runner    (1001) docker     (127)     6970 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/tidal_flow_calculator/test_tidal_flow_calculator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.338054 landlab-2.7.0/tests/components/transport_length_diffusion/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/transport_length_diffusion/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6600 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/transport_length_diffusion/test_tl_hill_diff.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.338054 landlab-2.7.0/tests/components/vegetation_dynamics/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/vegetation_dynamics/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      666 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/vegetation_dynamics/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     3024 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/vegetation_dynamics/test_vegetation_dynamics.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.338054 landlab-2.7.0/tests/components/weathering/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/weathering/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     1916 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/weathering/test_exponential_weatherer.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     4971 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/components/weathering/test_exponential_weathering_integrated.py
--rw-r--r--   0 runner    (1001) docker     (127)      157 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/conftest.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.338054 landlab-2.7.0/tests/core/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/core/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1051 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/core/test_example_data.py
--rw-r--r--   0 runner    (1001) docker     (127)     1035 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/core/test_load_params.py
--rw-r--r--   0 runner    (1001) docker     (127)     4597 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/core/test_messager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.342054 landlab-2.7.0/tests/data_record/
--rw-r--r--   0 runner    (1001) docker     (127)     1049 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/data_record/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     3888 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/data_record/test_data_record_2dim.py
--rw-r--r--   0 runner    (1001) docker     (127)     2219 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/data_record/test_data_record_item.py
--rw-r--r--   0 runner    (1001) docker     (127)      256 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/data_record/test_data_record_nodim.py
--rw-r--r--   0 runner    (1001) docker     (127)     2031 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/data_record/test_data_record_time.py
--rw-r--r--   0 runner    (1001) docker     (127)     1907 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/data_record/test_dummy.py
--rw-r--r--   0 runner    (1001) docker     (127)    16675 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/data_record/test_errors.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.342054 landlab-2.7.0/tests/field/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/field/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5225 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/field/test_field_dataset.py
--rw-r--r--   0 runner    (1001) docker     (127)     8427 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/field/test_graph_fields.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.342054 landlab-2.7.0/tests/graph/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.342054 landlab-2.7.0/tests/graph/framed_voronoi/
--rw-r--r--   0 runner    (1001) docker     (127)      280 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/framed_voronoi/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)      872 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/framed_voronoi/test_dual_framed_voronoi.py
--rw-r--r--   0 runner    (1001) docker     (127)     4566 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/framed_voronoi/test_framed_voronoi.py
--rw-r--r--   0 runner    (1001) docker     (127)     1712 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/framed_voronoi/test_perimeter_nodes.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.342054 landlab-2.7.0/tests/graph/hex/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/hex/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      478 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/hex/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     2309 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/hex/test_dual_hex.py
--rw-r--r--   0 runner    (1001) docker     (127)     8859 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/hex/test_hex.py
--rw-r--r--   0 runner    (1001) docker     (127)     3831 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/hex/test_perimeter_nodes.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.342054 landlab-2.7.0/tests/graph/radial/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/radial/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4792 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/radial/test_dual_radial.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.342054 landlab-2.7.0/tests/graph/sort/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/sort/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7600 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/sort/test_intpair.py
--rw-r--r--   0 runner    (1001) docker     (127)      768 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/sort/test_remap.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.342054 landlab-2.7.0/tests/graph/structured_quad/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/structured_quad/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7341 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/structured_quad/test_dual_quad.py
--rw-r--r--   0 runner    (1001) docker     (127)     9207 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/structured_quad/test_quad.py
--rw-r--r--   0 runner    (1001) docker     (127)     4049 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/test_graph.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.342054 landlab-2.7.0/tests/graph/voronoi/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/voronoi/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7479 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/graph/voronoi/test_voronoi_to_graph.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.346054 landlab-2.7.0/tests/grid/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1470 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)    10049 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_constructors.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.346054 landlab-2.7.0/tests/grid/test_create/
--rw-r--r--   0 runner    (1001) docker     (127)      131 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_create/4_x_3_no_nodata_value.asc
--rw-r--r--   0 runner    (1001) docker     (127)      318 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_create/bad_boundary.yaml
--rw-r--r--   0 runner    (1001) docker     (127)    11426 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_create/test-netcdf4.nc
--rw-r--r--   0 runner    (1001) docker     (127)    16403 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_create.py
--rw-r--r--   0 runner    (1001) docker     (127)    23008 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_create_network.py
--rw-r--r--   0 runner    (1001) docker     (127)     1830 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_diagonals.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.346054 landlab-2.7.0/tests/grid/test_framed_voronoi_grid/
--rw-r--r--   0 runner    (1001) docker     (127)     1397 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_framed_voronoi_grid/test_edges.py
--rw-r--r--   0 runner    (1001) docker     (127)     1141 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_framed_voronoi_grid/test_link_order.py
--rw-r--r--   0 runner    (1001) docker     (127)      531 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_framed_voronoi_grid/test_links.py
--rw-r--r--   0 runner    (1001) docker     (127)      646 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_framed_voronoi_grid/test_nodes_.py
--rw-r--r--   0 runner    (1001) docker     (127)     1042 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_framed_voronoi_grid/test_patches.py
--rw-r--r--   0 runner    (1001) docker     (127)     4233 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_grid_reference.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.346054 landlab-2.7.0/tests/grid/test_hex_grid/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_hex_grid/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1523 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_hex_grid/test_edges.py
--rw-r--r--   0 runner    (1001) docker     (127)     5793 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_hex_grid/test_flux_divergence_hex_grid.py
--rw-r--r--   0 runner    (1001) docker     (127)     1947 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_hex_grid/test_link_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     6809 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_hex_grid/test_links.py
--rw-r--r--   0 runner    (1001) docker     (127)      572 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_hex_grid/test_nodes.py
--rw-r--r--   0 runner    (1001) docker     (127)     1198 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_hex_grid/test_patches.py
--rw-r--r--   0 runner    (1001) docker     (127)     1663 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_hex_mappers.py
--rw-r--r--   0 runner    (1001) docker     (127)     2327 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_mappers.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.346054 landlab-2.7.0/tests/grid/test_radial_grid/
--rw-r--r--   0 runner    (1001) docker     (127)     1325 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_radial_grid/test_nodes.py
--rw-r--r--   0 runner    (1001) docker     (127)     1553 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_divergence.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.346054 landlab-2.7.0/tests/grid/test_raster_funcs/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_funcs/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1772 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_funcs/test_best_fit_plane.py
--rw-r--r--   0 runner    (1001) docker     (127)     2248 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_funcs/test_find_nearest_node.py
--rw-r--r--   0 runner    (1001) docker     (127)     1791 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_funcs/test_gradients_across_cell_corners.py
--rw-r--r--   0 runner    (1001) docker     (127)     1707 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_funcs/test_gradients_across_cell_faces.py
--rw-r--r--   0 runner    (1001) docker     (127)     3638 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_funcs/test_gradients_at_active_links.py
--rw-r--r--   0 runner    (1001) docker     (127)     2846 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_funcs/test_gradients_at_links.py
--rw-r--r--   0 runner    (1001) docker     (127)     1413 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_funcs/test_is_on_grid.py
--rw-r--r--   0 runner    (1001) docker     (127)     2177 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_funcs/test_line_to_grid_coords.py
--rw-r--r--   0 runner    (1001) docker     (127)     2335 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_funcs/test_node_id_of_adjacent.py
--rw-r--r--   0 runner    (1001) docker     (127)     6872 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_gradients.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.350054 landlab-2.7.0/tests/grid/test_raster_grid/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      163 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     1807 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_allocators.py
--rw-r--r--   0 runner    (1001) docker     (127)     1843 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_axis_methods.py
--rw-r--r--   0 runner    (1001) docker     (127)     1905 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_bc_updates.py
--rw-r--r--   0 runner    (1001) docker     (127)     1119 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_cell_areas.py
--rw-r--r--   0 runner    (1001) docker     (127)      767 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_corners.py
--rw-r--r--   0 runner    (1001) docker     (127)      769 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_faces.py
--rw-r--r--   0 runner    (1001) docker     (127)     2661 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_fields.py
--rw-r--r--   0 runner    (1001) docker     (127)     2081 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_fixed_link_boundary.py
--rw-r--r--   0 runner    (1001) docker     (127)     1923 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_has_boundary_neighbor.py
--rw-r--r--   0 runner    (1001) docker     (127)    12477 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_init.py
--rw-r--r--   0 runner    (1001) docker     (127)     2516 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_is_boundary.py
--rw-r--r--   0 runner    (1001) docker     (127)     2074 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_link_length.py
--rw-r--r--   0 runner    (1001) docker     (127)     1733 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_link_order.py
--rw-r--r--   0 runner    (1001) docker     (127)     6613 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_mappers.py
--rw-r--r--   0 runner    (1001) docker     (127)     5068 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_neighbor_nodes.py
--rw-r--r--   0 runner    (1001) docker     (127)     4144 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_nodes.py
--rw-r--r--   0 runner    (1001) docker     (127)     1855 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_nodes_around_point.py
--rw-r--r--   0 runner    (1001) docker     (127)     5030 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_patches.py
--rw-r--r--   0 runner    (1001) docker     (127)     2561 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_save.py
--rw-r--r--   0 runner    (1001) docker     (127)     2234 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_raster_grid/test_status_at_node.py
--rw-r--r--   0 runner    (1001) docker     (127)     1201 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/test_voronoi.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.350054 landlab-2.7.0/tests/grid/unstructured/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/unstructured/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3038 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/grid/unstructured/test_links.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.350054 landlab-2.7.0/tests/io/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.350054 landlab-2.7.0/tests/io/legacy_vtk/
--rw-r--r--   0 runner    (1001) docker     (127)     1141 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/legacy_vtk/test_legacy_vtk.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.350054 landlab-2.7.0/tests/io/netcdf/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/netcdf/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      336 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/netcdf/conftest.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.354054 landlab-2.7.0/tests/io/netcdf/test_from_netcdf/
--rw-r--r--   0 runner    (1001) docker     (127)    13449 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/netcdf/test_from_netcdf/test-HexModelGrid.nc
--rw-r--r--   0 runner    (1001) docker     (127)    13414 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/netcdf/test_from_netcdf/test-RadialModelGrid.nc
--rw-r--r--   0 runner    (1001) docker     (127)    12978 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/netcdf/test_from_netcdf/test-RasterModelGrid.nc
--rw-r--r--   0 runner    (1001) docker     (127)     2295 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/netcdf/test_from_netcdf.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.354054 landlab-2.7.0/tests/io/netcdf/test_read_netcdf/
--rw-r--r--   0 runner    (1001) docker     (127)      728 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/netcdf/test_read_netcdf/test-netcdf3-64bit.nc
--rw-r--r--   0 runner    (1001) docker     (127)    11426 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/netcdf/test_read_netcdf/test-netcdf4.nc
--rw-r--r--   0 runner    (1001) docker     (127)     3051 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/netcdf/test_read_netcdf.py
--rw-r--r--   0 runner    (1001) docker     (127)     7507 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/netcdf/test_to_netcdf.py
--rw-r--r--   0 runner    (1001) docker     (127)    10268 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/netcdf/test_write_netcdf.py
--rw-r--r--   0 runner    (1001) docker     (127)     8089 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/netcdf/test_write_raster_netcdf.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.354054 landlab-2.7.0/tests/io/shapefile/
--rw-r--r--   0 runner    (1001) docker     (127)     3546 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/shapefile/test_infer_dtype.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.354054 landlab-2.7.0/tests/io/shapefile/test_read_shapefile/
--rw-r--r--   0 runner    (1001) docker     (127)       76 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/shapefile/test_read_shapefile/multipartpolyline.dbf
--rw-r--r--   0 runner    (1001) docker     (127)      452 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/shapefile/test_read_shapefile/multipartpolyline.shp
--rw-r--r--   0 runner    (1001) docker     (127)      108 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/shapefile/test_read_shapefile/multipartpolyline.shx
--rw-r--r--   0 runner    (1001) docker     (127)      109 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/shapefile/test_read_shapefile/points.dbf
--rw-r--r--   0 runner    (1001) docker     (127)      212 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/shapefile/test_read_shapefile/points.shp
--rw-r--r--   0 runner    (1001) docker     (127)      132 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/shapefile/test_read_shapefile/points.shx
--rw-r--r--   0 runner    (1001) docker     (127)    14914 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/shapefile/test_read_shapefile.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.354054 landlab-2.7.0/tests/io/test_read_esri_ascii/
--rw-r--r--   0 runner    (1001) docker     (127)      152 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/test_read_esri_ascii/4_x_3.asc
--rw-r--r--   0 runner    (1001) docker     (127)      131 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/test_read_esri_ascii/4_x_3_no_nodata_value.asc
--rw-r--r--   0 runner    (1001) docker     (127)    23092 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/test_read_esri_ascii/hugo_site.asc
--rw-r--r--   0 runner    (1001) docker     (127)     9682 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/test_read_esri_ascii.py
--rw-r--r--   0 runner    (1001) docker     (127)     5427 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/test_read_write_native.py
--rw-r--r--   0 runner    (1001) docker     (127)     5255 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/test_write_esri_ascii.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2626 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/io/test_write_obj.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.354054 landlab-2.7.0/tests/layers/
--rw-r--r--   0 runner    (1001) docker     (127)     8234 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/layers/test_event_layers.py
--rw-r--r--   0 runner    (1001) docker     (127)      578 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/layers/test_material_layers.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.354054 landlab-2.7.0/tests/plot/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/plot/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.354054 landlab-2.7.0/tests/plot/network_sediment_transporter/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/plot/network_sediment_transporter/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6343 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/plot/network_sediment_transporter/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     5634 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/plot/network_sediment_transporter/test_plot_network_and_parcels.py
--rw-r--r--   0 runner    (1001) docker     (127)      649 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/plot/test_drainage_plot.py
--rw-r--r--   0 runner    (1001) docker     (127)     1164 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/plot/test_event_handler.py
--rw-r--r--   0 runner    (1001) docker     (127)     2003 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/plot/test_graph.py
--rw-r--r--   0 runner    (1001) docker     (127)    18599 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/plot/test_imshow_grid.py
--rw-r--r--   0 runner    (1001) docker     (127)     3536 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/plot/test_layers.py
--rw-r--r--   0 runner    (1001) docker     (127)      195 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/run_raster_model_grid_builtin_unit_test.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.358054 landlab-2.7.0/tests/utils/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      744 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_count_repeats.py
--rw-r--r--   0 runner    (1001) docker     (127)      466 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_decorators.py
--rw-r--r--   0 runner    (1001) docker     (127)     5192 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_distance_from_divide.py
--rw-r--r--   0 runner    (1001) docker     (127)    10405 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_flow__distance.py
--rw-r--r--   0 runner    (1001) docker     (127)     2275 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_halo.py
--rw-r--r--   0 runner    (1001) docker     (127)     7208 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_matrix.py
--rw-r--r--   0 runner    (1001) docker     (127)     5742 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_neighbor_node_array.py
--rw-r--r--   0 runner    (1001) docker     (127)      765 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_return_grid.py
--rw-r--r--   0 runner    (1001) docker     (127)     2731 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_source_tracking_algorithm.py
--rw-r--r--   0 runner    (1001) docker     (127)     1485 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_stable_priority_queue.py
--rw-r--r--   0 runner    (1001) docker     (127)    26443 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_structured_grid.py
--rw-r--r--   0 runner    (1001) docker     (127)     6059 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_watershed.py
--rw-r--r--   0 runner    (1001) docker     (127)     3154 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/utils/test_window_statistic.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:52.358054 landlab-2.7.0/tests/values/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/values/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      820 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/values/conftest.py
--rw-r--r--   0 runner    (1001) docker     (127)     7137 2023-11-05 04:32:22.000000 landlab-2.7.0/tests/values/test_synthetic.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.751363 landlab-2.8.0/
+-rw-r--r--   0 runner    (1001) docker     (127)     7190 2024-05-12 23:29:41.000000 landlab-2.8.0/.credits.toml
+-rw-r--r--   0 runner    (1001) docker     (127)    16118 2024-05-12 23:29:41.000000 landlab-2.8.0/.mailmap
+-rw-r--r--   0 runner    (1001) docker     (127)     2449 2024-05-12 23:29:41.000000 landlab-2.8.0/AUTHORS.rst
+-rw-r--r--   0 runner    (1001) docker     (127)   529611 2024-05-12 23:29:41.000000 landlab-2.8.0/CHANGES.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     3193 2024-05-12 23:29:41.000000 landlab-2.8.0/CITATION.cff
+-rw-r--r--   0 runner    (1001) docker     (127)     1445 2024-05-12 23:29:41.000000 landlab-2.8.0/FUNDING.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     1109 2024-05-12 23:29:41.000000 landlab-2.8.0/LICENSE.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     1142 2024-05-12 23:29:41.000000 landlab-2.8.0/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (127)    11265 2024-05-12 23:30:00.751363 landlab-2.8.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     6836 2024-05-12 23:29:41.000000 landlab-2.8.0/README.rst
+-rw-r--r--   0 runner    (1001) docker     (127)    65160 2024-05-12 23:29:41.000000 landlab-2.8.0/USEDBY.rst
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.635362 landlab-2.8.0/landlab/
+-rw-r--r--   0 runner    (1001) docker     (127)     1996 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1195 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/_info.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11248 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/_registry.py
+-rw-r--r--   0 runner    (1001) docker     (127)       22 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/_version.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.635362 landlab-2.8.0/landlab/bmi/
+-rw-r--r--   0 runner    (1001) docker     (127)      114 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/bmi/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18682 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/bmi/bmi_bridge.py
+-rw-r--r--   0 runner    (1001) docker     (127)      392 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/bmi/components.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4429 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/bmi/standard_names.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.635362 landlab-2.8.0/landlab/ca/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/ca/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.635362 landlab-2.8.0/landlab/ca/boundaries/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/ca/boundaries/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    45125 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/ca/boundaries/hex_lattice_tectonicizer.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32254 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/ca/celllab_cts.py
+-rw-r--r--   0 runner    (1001) docker     (127)    57535 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/ca/cfuncs.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     3788 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/ca/hex_cts.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5550 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/ca/oriented_hex_cts.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4814 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/ca/oriented_raster_cts.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3735 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/ca/raster_cts.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.639362 landlab-2.8.0/landlab/cmd/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/cmd/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7977 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/cmd/authors.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20439 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/cmd/landlab.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.639362 landlab-2.8.0/landlab/components/
+-rw-r--r--   0 runner    (1001) docker     (127)     6477 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.639362 landlab-2.8.0/landlab/components/advection/
+-rw-r--r--   0 runner    (1001) docker     (127)      365 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/advection/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    12520 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/advection/advection_solver_tvd.py
+-rw-r--r--   0 runner    (1001) docker     (127)      459 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/advection/flux_limiters.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.639362 landlab-2.8.0/landlab/components/area_slope_transporter/
+-rw-r--r--   0 runner    (1001) docker     (127)       93 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/area_slope_transporter/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9095 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/area_slope_transporter/area_slope_transporter.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.639362 landlab-2.8.0/landlab/components/bedrock_landslider/
+-rw-r--r--   0 runner    (1001) docker     (127)       83 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/bedrock_landslider/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28690 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/bedrock_landslider/bedrock_landslider.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2252 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/bedrock_landslider/cfuncs.pyx
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.639362 landlab-2.8.0/landlab/components/carbonate/
+-rw-r--r--   0 runner    (1001) docker     (127)       83 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/carbonate/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10375 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/carbonate/carbonate_producer.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.639362 landlab-2.8.0/landlab/components/chi_index/
+-rw-r--r--   0 runner    (1001) docker     (127)       60 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/chi_index/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27424 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/chi_index/channel_chi.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.639362 landlab-2.8.0/landlab/components/concentration_tracker/
+-rw-r--r--   0 runner    (1001) docker     (127)      322 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/concentration_tracker/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14328 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/concentration_tracker/concentration_tracker_for_diffusion.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.639362 landlab-2.8.0/landlab/components/depression_finder/
+-rw-r--r--   0 runner    (1001) docker     (127)       92 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/depression_finder/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5002 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/depression_finder/cfuncs.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)      197 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/depression_finder/floodstatus.py
+-rw-r--r--   0 runner    (1001) docker     (127)    54361 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/depression_finder/lake_mapper.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.639362 landlab-2.8.0/landlab/components/depth_dependent_diffusion/
+-rw-r--r--   0 runner    (1001) docker     (127)      112 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/depth_dependent_diffusion/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9302 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/depth_dependent_diffusion/hillslope_depth_dependent_linear_flux.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.639362 landlab-2.8.0/landlab/components/depth_dependent_taylor_soil_creep/
+-rw-r--r--   0 runner    (1001) docker     (127)      124 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/depth_dependent_taylor_soil_creep/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19245 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/depth_dependent_taylor_soil_creep/hillslope_depth_dependent_taylor_flux.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.643362 landlab-2.8.0/landlab/components/detachment_ltd_erosion/
+-rw-r--r--   0 runner    (1001) docker     (127)      200 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/detachment_ltd_erosion/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7103 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/detachment_ltd_erosion/generate_detachment_ltd_erosion.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8611 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/detachment_ltd_erosion/generate_erosion_by_depth_slope.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.643362 landlab-2.8.0/landlab/components/diffusion/
+-rw-r--r--   0 runner    (1001) docker     (127)       68 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/diffusion/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21835 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/diffusion/diffusion.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.643362 landlab-2.8.0/landlab/components/dimensionless_discharge/
+-rw-r--r--   0 runner    (1001) docker     (127)      185 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/dimensionless_discharge/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8313 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/dimensionless_discharge/dimensionless_discharge.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.643362 landlab-2.8.0/landlab/components/discharge_diffuser/
+-rw-r--r--   0 runner    (1001) docker     (127)       85 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/discharge_diffuser/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15317 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/discharge_diffuser/diffuse_by_discharge.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.643362 landlab-2.8.0/landlab/components/drainage_density/
+-rw-r--r--   0 runner    (1001) docker     (127)       77 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/drainage_density/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2451 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/drainage_density/cfuncs.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)    17454 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/drainage_density/drainage_density.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.643362 landlab-2.8.0/landlab/components/erosion_deposition/
+-rw-r--r--   0 runner    (1001) docker     (127)       83 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/erosion_deposition/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2250 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/erosion_deposition/cfuncs.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)    19740 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/erosion_deposition/erosion_deposition.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7320 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/erosion_deposition/generalized_erosion_deposition.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.643362 landlab-2.8.0/landlab/components/fire_generator/
+-rw-r--r--   0 runner    (1001) docker     (127)       70 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/fire_generator/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5241 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/fire_generator/generate_fire.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.643362 landlab-2.8.0/landlab/components/flexure/
+-rw-r--r--   0 runner    (1001) docker     (127)      361 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flexure/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2503 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flexure/cfuncs.pyx
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.643362 landlab-2.8.0/landlab/components/flexure/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)       70 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flexure/ext/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1424 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flexure/ext/flexure1d.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     9151 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flexure/flexure.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12329 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flexure/flexure_1d.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4799 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flexure/funcs.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.647362 landlab-2.8.0/landlab/components/flow_accum/
+-rw-r--r--   0 runner    (1001) docker     (127)      421 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_accum/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3572 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_accum/cfuncs.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)    16786 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_accum/flow_accum_bw.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26739 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_accum/flow_accum_to_n.py
+-rw-r--r--   0 runner    (1001) docker     (127)    52497 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_accum/flow_accumulator.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19514 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_accum/lossy_flow_accumulator.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.647362 landlab-2.8.0/landlab/components/flow_director/
+-rw-r--r--   0 runner    (1001) docker     (127)      466 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_director/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1966 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_director/cfuncs.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     4476 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_director/flow_direction_DN.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19058 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_director/flow_direction_dinf.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14470 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_director/flow_direction_mfd.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4772 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_director/flow_director.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9483 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_director/flow_director_d8.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12985 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_director/flow_director_dinf.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19473 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_director/flow_director_mfd.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26742 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_director/flow_director_steepest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5179 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_director/flow_director_to_many.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6054 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_director/flow_director_to_one.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.647362 landlab-2.8.0/landlab/components/flow_router/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_router/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.647362 landlab-2.8.0/landlab/components/flow_router/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_router/ext/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.647362 landlab-2.8.0/landlab/components/flow_router/ext/single_flow/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_router/ext/single_flow/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.647362 landlab-2.8.0/landlab/components/flow_router/ext/single_flow/priority_routing/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_router/ext/single_flow/priority_routing/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      382 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_router/ext/single_flow/priority_routing/_priority_queue.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2496 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_router/ext/single_flow/priority_routing/breach.pxd
+-rw-r--r--   0 runner    (1001) docker     (127)    19688 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/flow_router/ext/single_flow/priority_routing/breach.pyx
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.647362 landlab-2.8.0/landlab/components/fracture_grid/
+-rw-r--r--   0 runner    (1001) docker     (127)       86 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/fracture_grid/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11399 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/fracture_grid/fracture_grid.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.651362 landlab-2.8.0/landlab/components/gflex/
+-rw-r--r--   0 runner    (1001) docker     (127)       48 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/gflex/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10237 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/gflex/flexure.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.651362 landlab-2.8.0/landlab/components/gravel_bedrock_eroder/
+-rw-r--r--   0 runner    (1001) docker     (127)       90 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/gravel_bedrock_eroder/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    30991 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/gravel_bedrock_eroder/gravel_bedrock_eroder.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.651362 landlab-2.8.0/landlab/components/gravel_river_transporter/
+-rw-r--r--   0 runner    (1001) docker     (127)       99 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/gravel_river_transporter/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22128 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/gravel_river_transporter/gravel_river_transporter.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.651362 landlab-2.8.0/landlab/components/groundwater/
+-rw-r--r--   0 runner    (1001) docker     (127)     3392 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/groundwater/README.md
+-rw-r--r--   0 runner    (1001) docker     (127)      207 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/groundwater/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28662 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/groundwater/dupuit_percolator.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.651362 landlab-2.8.0/landlab/components/hack_calculator/
+-rw-r--r--   0 runner    (1001) docker     (127)       74 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/hack_calculator/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11515 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/hack_calculator/hack_calculator.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.651362 landlab-2.8.0/landlab/components/hand_calculator/
+-rw-r--r--   0 runner    (1001) docker     (127)      189 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/hand_calculator/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6844 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/hand_calculator/hand_calculator.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.651362 landlab-2.8.0/landlab/components/lake_fill/
+-rw-r--r--   0 runner    (1001) docker     (127)       79 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/lake_fill/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)   100912 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/lake_fill/lake_fill_barnes.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.651362 landlab-2.8.0/landlab/components/landslides/
+-rw-r--r--   0 runner    (1001) docker     (127)       92 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/landslides/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27949 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/landslides/landslide_probability.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.651362 landlab-2.8.0/landlab/components/lateral_erosion/
+-rw-r--r--   0 runner    (1001) docker     (127)       72 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/lateral_erosion/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    31542 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/lateral_erosion/lateral_erosion.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10237 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/lateral_erosion/node_finder.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.651362 landlab-2.8.0/landlab/components/lithology/
+-rw-r--r--   0 runner    (1001) docker     (127)      765 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/lithology/README.md
+-rw-r--r--   0 runner    (1001) docker     (127)      110 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/lithology/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8092 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/lithology/litholayers.py
+-rw-r--r--   0 runner    (1001) docker     (127)    36304 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/lithology/lithology.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.651362 landlab-2.8.0/landlab/components/marine_sediment_transport/
+-rw-r--r--   0 runner    (1001) docker     (127)      102 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/marine_sediment_transport/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7885 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/marine_sediment_transport/simple_submarine_diffuser.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.655362 landlab-2.8.0/landlab/components/mass_wasting_runout/
+-rw-r--r--   0 runner    (1001) docker     (127)      105 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/mass_wasting_runout/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    51509 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/mass_wasting_runout/mass_wasting_runout.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5328 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/mass_wasting_runout/mass_wasting_saver.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.655362 landlab-2.8.0/landlab/components/network_sediment_transporter/
+-rw-r--r--   0 runner    (1001) docker     (127)     2032 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/network_sediment_transporter/README.md
+-rw-r--r--   0 runner    (1001) docker     (127)      699 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/network_sediment_transporter/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27023 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/network_sediment_transporter/bed_parcel_initializers.py
+-rw-r--r--   0 runner    (1001) docker     (127)    46457 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/network_sediment_transporter/network_sediment_transporter.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12400 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/network_sediment_transporter/sediment_pulser_at_links.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3094 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/network_sediment_transporter/sediment_pulser_base.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13029 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/network_sediment_transporter/sediment_pulser_each_parcel.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.655362 landlab-2.8.0/landlab/components/nonlinear_diffusion/
+-rw-r--r--   0 runner    (1001) docker     (127)    62765 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/nonlinear_diffusion/Perron_nl_diffuse.py
+-rw-r--r--   0 runner    (1001) docker     (127)       78 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/nonlinear_diffusion/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.655362 landlab-2.8.0/landlab/components/normal_fault/
+-rw-r--r--   0 runner    (1001) docker     (127)       65 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/normal_fault/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19633 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/normal_fault/normal_fault.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.655362 landlab-2.8.0/landlab/components/overland_flow/
+-rw-r--r--   0 runner    (1001) docker     (127)      607 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/overland_flow/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29210 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/overland_flow/_links.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1000 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/overland_flow/_neighbors_at_link.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     8421 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/overland_flow/generate_overland_flow_Bates.py
+-rw-r--r--   0 runner    (1001) docker     (127)    34757 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/overland_flow/generate_overland_flow_deAlmeida.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13690 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/overland_flow/generate_overland_flow_implicit_kinwave.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6205 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/overland_flow/generate_overland_flow_kinwave.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17310 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/overland_flow/kinematic_wave_rengers.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10429 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/overland_flow/linear_diffusion_overland_flow_router.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.659362 landlab-2.8.0/landlab/components/pet/
+-rw-r--r--   0 runner    (1001) docker     (127)      119 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/pet/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16791 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/pet/potential_evapotranspiration_field.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.659362 landlab-2.8.0/landlab/components/plant_competition_ca/
+-rw-r--r--   0 runner    (1001) docker     (127)      100 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/plant_competition_ca/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14387 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/plant_competition_ca/plant_competition_ca.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.659362 landlab-2.8.0/landlab/components/potentiality_flowrouting/
+-rw-r--r--   0 runner    (1001) docker     (127)       97 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/potentiality_flowrouting/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12270 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/potentiality_flowrouting/route_flow_by_boundary.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.659362 landlab-2.8.0/landlab/components/priority_flood_flow_router/
+-rw-r--r--   0 runner    (1001) docker     (127)     2169 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/priority_flood_flow_router/README.md
+-rw-r--r--   0 runner    (1001) docker     (127)      103 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/priority_flood_flow_router/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3656 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/priority_flood_flow_router/cfuncs.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)    37304 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/priority_flood_flow_router/priority_flood_flow_router.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.659362 landlab-2.8.0/landlab/components/profiler/
+-rw-r--r--   0 runner    (1001) docker     (127)      219 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/profiler/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9131 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/profiler/base_profiler.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32538 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/profiler/channel_profiler.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13888 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/profiler/profiler.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14619 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/profiler/trickle_down_profiler.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.659362 landlab-2.8.0/landlab/components/radiation/
+-rw-r--r--   0 runner    (1001) docker     (127)       58 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/radiation/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19412 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/radiation/radiation.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.659362 landlab-2.8.0/landlab/components/sink_fill/
+-rw-r--r--   0 runner    (1001) docker     (127)      128 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/sink_fill/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14172 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/sink_fill/fill_sinks.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12368 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/sink_fill/sink_fill_barnes.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.659362 landlab-2.8.0/landlab/components/soil_moisture/
+-rw-r--r--   0 runner    (1001) docker     (127)      172 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/soil_moisture/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14802 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/soil_moisture/infiltrate_soil_green_ampt.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26270 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/soil_moisture/soil_moisture_dynamics.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.659362 landlab-2.8.0/landlab/components/space/
+-rw-r--r--   0 runner    (1001) docker     (127)      131 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/space/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.663362 landlab-2.8.0/landlab/components/space/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)     2185 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/space/ext/calc_qs.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     3921 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/space/ext/calc_sequential_ero_depo.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)    27160 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/space/space.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20446 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/space/space_large_scale_eroder.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.663362 landlab-2.8.0/landlab/components/spatial_precip/
+-rw-r--r--   0 runner    (1001) docker     (127)      118 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/spatial_precip/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    81083 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/spatial_precip/generate_spatial_precip.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.663362 landlab-2.8.0/landlab/components/species_evolution/
+-rw-r--r--   0 runner    (1001) docker     (127)     2222 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/species_evolution/README.md
+-rw-r--r--   0 runner    (1001) docker     (127)      346 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/species_evolution/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4691 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/species_evolution/base_taxon.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6029 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/species_evolution/record.py
+-rw-r--r--   0 runner    (1001) docker     (127)    25426 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/species_evolution/species_evolver.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10888 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/species_evolution/zone.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17352 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/species_evolution/zone_controller.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14012 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/species_evolution/zone_taxon.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.663362 landlab-2.8.0/landlab/components/steepness_index/
+-rw-r--r--   0 runner    (1001) docker     (127)       78 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/steepness_index/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24423 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/steepness_index/channel_steepness.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.663362 landlab-2.8.0/landlab/components/stream_power/
+-rw-r--r--   0 runner    (1001) docker     (127)      343 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/stream_power/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16163 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/stream_power/cfuncs.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)    13134 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/stream_power/fastscape_stream_power.py
+-rw-r--r--   0 runner    (1001) docker     (127)    48236 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/stream_power/sed_flux_dep_incision.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17074 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/stream_power/stream_power.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12466 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/stream_power/stream_power_smooth_threshold.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.663362 landlab-2.8.0/landlab/components/taylor_nonlinear_hillslope_flux/
+-rw-r--r--   0 runner    (1001) docker     (127)      108 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/taylor_nonlinear_hillslope_flux/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12451 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/taylor_nonlinear_hillslope_flux/taylor_nonlinear_hillslope_flux.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.663362 landlab-2.8.0/landlab/components/tectonics/
+-rw-r--r--   0 runner    (1001) docker     (127)      190 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/tectonics/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10716 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/tectonics/listric_kinematic_extender.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.667362 landlab-2.8.0/landlab/components/threshold_eroder/
+-rw-r--r--   0 runner    (1001) docker     (127)       77 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/threshold_eroder/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      853 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/threshold_eroder/cfuncs.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     7151 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/threshold_eroder/threshold_eroder.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.667362 landlab-2.8.0/landlab/components/tidal_flow/
+-rw-r--r--   0 runner    (1001) docker     (127)      175 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/tidal_flow/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    12471 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/tidal_flow/tidal_flow_calculator.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.667362 landlab-2.8.0/landlab/components/transport_length_diffusion/
+-rw-r--r--   0 runner    (1001) docker     (127)      131 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/transport_length_diffusion/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10740 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/transport_length_diffusion/transport_length_hillslope_diffusion.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.667362 landlab-2.8.0/landlab/components/uniform_precip/
+-rw-r--r--   0 runner    (1001) docker     (127)      104 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/uniform_precip/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26788 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/uniform_precip/generate_uniform_precip.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.667362 landlab-2.8.0/landlab/components/vegetation_dynamics/
+-rw-r--r--   0 runner    (1001) docker     (127)       70 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/vegetation_dynamics/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21492 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/vegetation_dynamics/vegetation_dynamics.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.667362 landlab-2.8.0/landlab/components/weathering/
+-rw-r--r--   0 runner    (1001) docker     (127)      205 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/weathering/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5304 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/weathering/exponential_weathering.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8521 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/components/weathering/exponential_weathering_integrated.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.667362 landlab-2.8.0/landlab/core/
+-rw-r--r--   0 runner    (1001) docker     (127)       75 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/core/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      795 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/core/errors.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12126 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/core/messages.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13473 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/core/model_component.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2008 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/core/model_parameter_loader.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20814 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/core/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.615362 landlab-2.8.0/landlab/data/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.615362 landlab-2.8.0/landlab/data/io/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.615362 landlab-2.8.0/landlab/data/io/shapefile/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.671362 landlab-2.8.0/landlab/data/io/shapefile/methow/
+-rw-r--r--   0 runner    (1001) docker     (127)        6 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin.cpg
+-rw-r--r--   0 runner    (1001) docker     (127)     2375 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin.dbf
+-rw-r--r--   0 runner    (1001) docker     (127)      426 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin.prj
+-rw-r--r--   0 runner    (1001) docker     (127)      436 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin.sbn
+-rw-r--r--   0 runner    (1001) docker     (127)      148 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin.sbx
+-rw-r--r--   0 runner    (1001) docker     (127)     8972 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin.shp
+-rw-r--r--   0 runner    (1001) docker     (127)      921 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin.shp.xml
+-rw-r--r--   0 runner    (1001) docker     (127)      332 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin.shx
+-rw-r--r--   0 runner    (1001) docker     (127)        6 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.CPG
+-rw-r--r--   0 runner    (1001) docker     (127)     2896 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.dbf
+-rw-r--r--   0 runner    (1001) docker     (127)      426 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.prj
+-rw-r--r--   0 runner    (1001) docker     (127)      428 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.sbn
+-rw-r--r--   0 runner    (1001) docker     (127)      132 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.sbx
+-rw-r--r--   0 runner    (1001) docker     (127)      940 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.shp
+-rw-r--r--   0 runner    (1001) docker     (127)      506 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.shp.xml
+-rw-r--r--   0 runner    (1001) docker     (127)      340 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.shx
+-rwxr-xr-x   0 runner    (1001) docker     (127)    52818 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/Methow_Network.dbf
+-rwxr-xr-x   0 runner    (1001) docker     (127)   259316 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/Methow_Network.shp
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5860 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/methow/Methow_Network.shx
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.675362 landlab-2.8.0/landlab/data/io/shapefile/redb/
+-rw-r--r--   0 runner    (1001) docker     (127)        6 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_network.cpg
+-rw-r--r--   0 runner    (1001) docker     (127)     1226 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_network.dbf
+-rw-r--r--   0 runner    (1001) docker     (127)      426 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_network.prj
+-rw-r--r--   0 runner    (1001) docker     (127)      252 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_network.sbn
+-rw-r--r--   0 runner    (1001) docker     (127)      132 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_network.sbx
+-rw-r--r--   0 runner    (1001) docker     (127)     5188 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_network.shp
+-rw-r--r--   0 runner    (1001) docker     (127)     1946 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_network.shp.xml
+-rw-r--r--   0 runner    (1001) docker     (127)      196 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_network.shx
+-rw-r--r--   0 runner    (1001) docker     (127)        6 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_nodes_att.CPG
+-rw-r--r--   0 runner    (1001) docker     (127)     1169 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_nodes_att.dbf
+-rw-r--r--   0 runner    (1001) docker     (127)      426 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_nodes_att.prj
+-rw-r--r--   0 runner    (1001) docker     (127)      252 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_nodes_att.sbn
+-rw-r--r--   0 runner    (1001) docker     (127)      124 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_nodes_att.sbx
+-rw-r--r--   0 runner    (1001) docker     (127)      464 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_nodes_att.shp
+-rw-r--r--   0 runner    (1001) docker     (127)     3993 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_nodes_att.shp.xml
+-rw-r--r--   0 runner    (1001) docker     (127)      204 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/redb/a001_nodes_att.shx
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.675362 landlab-2.8.0/landlab/data/io/shapefile/soque/
+-rw-r--r--   0 runner    (1001) docker     (127)        6 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Links.cpg
+-rw-r--r--   0 runner    (1001) docker     (127)   371672 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Links.dbf
+-rw-r--r--   0 runner    (1001) docker     (127)      168 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Links.prj
+-rw-r--r--   0 runner    (1001) docker     (127)     1038 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Links.qmd
+-rw-r--r--   0 runner    (1001) docker     (127)   402332 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Links.shp
+-rw-r--r--   0 runner    (1001) docker     (127)     2636 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Links.shx
+-rw-r--r--   0 runner    (1001) docker     (127)        6 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Nodes.cpg
+-rw-r--r--   0 runner    (1001) docker     (127)   383714 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Nodes.dbf
+-rw-r--r--   0 runner    (1001) docker     (127)      168 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Nodes.prj
+-rw-r--r--   0 runner    (1001) docker     (127)     1031 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Nodes.qmd
+-rw-r--r--   0 runner    (1001) docker     (127)     9004 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Nodes.shp
+-rw-r--r--   0 runner    (1001) docker     (127)     2644 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Nodes.shx
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.675362 landlab-2.8.0/landlab/data_record/
+-rw-r--r--   0 runner    (1001) docker     (127)       62 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data_record/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    53010 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/data_record/data_record.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.679362 landlab-2.8.0/landlab/field/
+-rw-r--r--   0 runner    (1001) docker     (127)      226 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/field/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      971 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/field/errors.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43224 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/field/graph_field.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.679362 landlab-2.8.0/landlab/framework/
+-rw-r--r--   0 runner    (1001) docker     (127)       38 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/framework/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2494 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/framework/component.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1008 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/framework/decorators.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5040 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/framework/interfaces.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.679362 landlab-2.8.0/landlab/graph/
+-rw-r--r--   0 runner    (1001) docker     (127)     1709 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3356 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/dual.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.679362 landlab-2.8.0/landlab/graph/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/ext/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.679362 landlab-2.8.0/landlab/graph/framed_voronoi/
+-rw-r--r--   0 runner    (1001) docker     (127)      163 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/framed_voronoi/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3255 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/framed_voronoi/dual_framed_voronoi.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15658 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/framed_voronoi/framed_voronoi.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32872 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/graph.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4938 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/graph_convention.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.679362 landlab-2.8.0/landlab/graph/hex/
+-rw-r--r--   0 runner    (1001) docker     (127)      101 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/hex/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3223 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/hex/dual_hex.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.679362 landlab-2.8.0/landlab/graph/hex/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/hex/ext/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10352 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/hex/ext/hex.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     6755 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/hex/ext/perimeternodes.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)    32331 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/hex/hex.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.679362 landlab-2.8.0/landlab/graph/matrix/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/matrix/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1533 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/matrix/at_node.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1248 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/matrix/at_patch.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.679362 landlab-2.8.0/landlab/graph/matrix/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/matrix/ext/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      697 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/matrix/ext/at_patch.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     1204 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/matrix/ext/matrix.pyx
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.683363 landlab-2.8.0/landlab/graph/object/
+-rw-r--r--   0 runner    (1001) docker     (127)       46 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/object/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4703 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/object/at_node.py
+-rw-r--r--   0 runner    (1001) docker     (127)      617 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/object/at_patch.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.683363 landlab-2.8.0/landlab/graph/object/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/object/ext/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3746 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/object/ext/at_node.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     3574 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/object/ext/at_patch.pyx
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.683363 landlab-2.8.0/landlab/graph/quantity/
+-rw-r--r--   0 runner    (1001) docker     (127)       51 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/quantity/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.683363 landlab-2.8.0/landlab/graph/quantity/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/quantity/ext/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6069 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/quantity/ext/of_element.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)      806 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/quantity/ext/of_link.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     3692 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/quantity/ext/of_patch.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     2481 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/quantity/of_link.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1204 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/quantity/of_patch.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.683363 landlab-2.8.0/landlab/graph/quasi_spherical/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/quasi_spherical/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17981 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/quasi_spherical/dual_icosphere.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9896 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/quasi_spherical/refinable_icosahedron.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.683363 landlab-2.8.0/landlab/graph/radial/
+-rw-r--r--   0 runner    (1001) docker     (127)      119 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/radial/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1933 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/radial/dual_radial.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7123 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/radial/radial.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.683363 landlab-2.8.0/landlab/graph/sort/
+-rw-r--r--   0 runner    (1001) docker     (127)      349 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/sort/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.683363 landlab-2.8.0/landlab/graph/sort/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/sort/ext/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      198 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/sort/ext/argsort.pxd
+-rw-r--r--   0 runner    (1001) docker     (127)     7521 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/sort/ext/argsort.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)    11915 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/sort/ext/remap_element.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     6294 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/sort/ext/spoke_sort.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     5395 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/sort/intpair.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22906 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/sort/sort.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.687363 landlab-2.8.0/landlab/graph/structured_quad/
+-rw-r--r--   0 runner    (1001) docker     (127)      514 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/structured_quad/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5807 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/structured_quad/dual_structured_quad.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.687363 landlab-2.8.0/landlab/graph/structured_quad/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/structured_quad/ext/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      836 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/structured_quad/ext/at_cell.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     1192 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/structured_quad/ext/at_face.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     3654 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/structured_quad/ext/at_link.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     8307 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/structured_quad/ext/at_node.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)      821 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/structured_quad/ext/at_patch.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)    24121 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/structured_quad/structured_quad.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2487 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/ugrid.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.687363 landlab-2.8.0/landlab/graph/voronoi/
+-rw-r--r--   0 runner    (1001) docker     (127)      127 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/voronoi/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2284 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/voronoi/dual_voronoi.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.687363 landlab-2.8.0/landlab/graph/voronoi/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/voronoi/ext/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3305 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/voronoi/ext/delaunay.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)    11158 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/voronoi/ext/voronoi.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     1773 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/voronoi/voronoi.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11834 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/graph/voronoi/voronoi_to_graph.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.691362 landlab-2.8.0/landlab/grid/
+-rw-r--r--   0 runner    (1001) docker     (127)      576 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)   101071 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/base.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3764 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/cfuncs.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)    15529 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/create.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22223 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/create_network.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4202 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/decorators.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15274 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/diagonals.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29072 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/divergence.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.691362 landlab-2.8.0/landlab/grid/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)     1964 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/ext/raster_divergence.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     2567 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/ext/raster_gradient.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     5510 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/framed_voronoi.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18085 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/gradients.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1197 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/grid_funcs.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21342 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/hex.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6806 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/hex_mappers.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3028 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/icosphere.py
+-rw-r--r--   0 runner    (1001) docker     (127)      170 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/linkorientation.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5122 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/linkstatus.py
+-rw-r--r--   0 runner    (1001) docker     (127)    56299 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/mappers.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12070 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/network.py
+-rw-r--r--   0 runner    (1001) docker     (127)      473 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/nodestatus.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5459 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/radial.py
+-rw-r--r--   0 runner    (1001) docker     (127)    91047 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/raster.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4104 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/raster_aspect.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3592 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/raster_divergence.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11669 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/raster_funcs.py
+-rw-r--r--   0 runner    (1001) docker     (127)    69047 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/raster_gradients.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28187 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/raster_mappers.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2629 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/raster_set_status.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.695363 landlab-2.8.0/landlab/grid/unstructured/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/unstructured/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19398 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/unstructured/base.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3818 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/unstructured/cells.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18226 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/unstructured/links.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4372 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/unstructured/nodes.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2326 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/unstructured/status.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7529 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/voronoi.py
+-rw-r--r--   0 runner    (1001) docker     (127)      904 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/grid/warnings.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.695363 landlab-2.8.0/landlab/io/
+-rw-r--r--   0 runner    (1001) docker     (127)     1144 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17070 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/esri_ascii.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9549 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/legacy_vtk.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3136 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/native_landlab.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.695363 landlab-2.8.0/landlab/io/netcdf/
+-rw-r--r--   0 runner    (1001) docker     (127)      341 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/netcdf/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1206 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/netcdf/_constants.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4886 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/netcdf/dump.py
+-rw-r--r--   0 runner    (1001) docker     (127)      385 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/netcdf/errors.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3052 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/netcdf/load.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11836 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/netcdf/read.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23997 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/netcdf/write.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4459 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/obj.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16191 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/io/shapefile.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.695363 landlab-2.8.0/landlab/layers/
+-rw-r--r--   0 runner    (1001) docker     (127)      258 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/layers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29512 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/layers/eventlayers.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.695363 landlab-2.8.0/landlab/layers/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/layers/ext/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1308 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/layers/ext/eventlayers.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     9431 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/layers/materiallayers.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.699363 landlab-2.8.0/landlab/plot/
+-rw-r--r--   0 runner    (1001) docker     (127)      461 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/plot/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1381 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/plot/colors.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3707 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/plot/drainage_plot.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1655 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/plot/event_handler.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4562 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/plot/graph.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21049 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/plot/imshow.py
+-rw-r--r--   0 runner    (1001) docker     (127)    38921 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/plot/imshowhs.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7876 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/plot/layers.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.699363 landlab-2.8.0/landlab/plot/network_sediment_transporter/
+-rw-r--r--   0 runner    (1001) docker     (127)      164 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/plot/network_sediment_transporter/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4105 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/plot/network_sediment_transporter/locate_parcel_xy.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18174 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/plot/network_sediment_transporter/plot_network_and_parcels.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9257 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/plot/video_out.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.699363 landlab-2.8.0/landlab/utils/
+-rw-r--r--   0 runner    (1001) docker     (127)     1356 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2824 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/_matrix.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)     1173 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/add_halo.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2358 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/count_repeats.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11404 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/decorators.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4199 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/depth_dependent_roughness.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8490 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/distance_to_divide.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.699363 landlab-2.8.0/landlab/utils/ext/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/ext/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      799 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/ext/jaggedarray.pyx
+-rw-r--r--   0 runner    (1001) docker     (127)    23803 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/fault_facet_finder.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8731 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/flow__distance.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.703363 landlab-2.8.0/landlab/utils/geometry/
+-rw-r--r--   0 runner    (1001) docker     (127)     7548 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/geometry/spherical.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10517 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/jaggedarray.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9433 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/jaggedarray_ma.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7436 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/matrix.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1205 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/return_array.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11695 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/source_tracking_algorithm.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3853 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/stable_priority_queue.py
+-rw-r--r--   0 runner    (1001) docker     (127)    57188 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/structured_grid.py
+-rw-r--r--   0 runner    (1001) docker     (127)      868 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/suppress_output.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13066 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/watershed.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8668 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/utils/window_statistic.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.703363 landlab-2.8.0/landlab/values/
+-rw-r--r--   0 runner    (1001) docker     (127)      208 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/values/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15051 2024-05-12 23:29:42.000000 landlab-2.8.0/landlab/values/synthetic.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.751363 landlab-2.8.0/landlab.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)    11265 2024-05-12 23:30:00.000000 landlab-2.8.0/landlab.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)    33973 2024-05-12 23:30:00.000000 landlab-2.8.0/landlab.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-12 23:30:00.000000 landlab-2.8.0/landlab.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       56 2024-05-12 23:30:00.000000 landlab-2.8.0/landlab.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      243 2024-05-12 23:30:00.000000 landlab-2.8.0/landlab.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       14 2024-05-12 23:30:00.000000 landlab-2.8.0/landlab.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     3850 2024-05-12 23:29:42.000000 landlab-2.8.0/notebooks.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12422 2024-05-12 23:29:42.000000 landlab-2.8.0/noxfile.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5324 2024-05-12 23:29:42.000000 landlab-2.8.0/pyproject.toml
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.703363 landlab-2.8.0/requirements/
+-rw-r--r--   0 runner    (1001) docker     (127)      470 2024-05-12 23:29:42.000000 landlab-2.8.0/requirements/README.md
+-rw-r--r--   0 runner    (1001) docker     (127)      214 2024-05-12 23:29:42.000000 landlab-2.8.0/requirements/docs.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       90 2024-05-12 23:29:42.000000 landlab-2.8.0/requirements/notebooks.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      223 2024-05-12 23:29:42.000000 landlab-2.8.0/requirements/required.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      147 2024-05-12 23:29:42.000000 landlab-2.8.0/requirements/testing.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      177 2024-05-12 23:29:42.000000 landlab-2.8.0/requirements-testing.in
+-rw-r--r--   0 runner    (1001) docker     (127)      156 2024-05-12 23:29:42.000000 landlab-2.8.0/requirements.in
+-rw-r--r--   0 runner    (1001) docker     (127)      318 2024-05-12 23:30:00.751363 landlab-2.8.0/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (127)     2740 2024-05-12 23:29:42.000000 landlab-2.8.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.703363 landlab-2.8.0/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)       41 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.703363 landlab-2.8.0/tests/ca/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/ca/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.703363 landlab-2.8.0/tests/ca/boundaries/
+-rw-r--r--   0 runner    (1001) docker     (127)     3293 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/ca/boundaries/test_hex_normal_fault.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5438 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/ca/cts_model.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16456 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/ca/grain_hill.py
+-rw-r--r--   0 runner    (1001) docker     (127)      377 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/ca/grain_hill_params.txt
+-rw-r--r--   0 runner    (1001) docker     (127)    37425 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/ca/lattice_grain.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14695 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/ca/test_celllab_cts.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5191 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/ca/test_user_guide_example.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.703363 landlab-2.8.0/tests/components/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.703363 landlab-2.8.0/tests/components/advection_solver/
+-rw-r--r--   0 runner    (1001) docker     (127)     9830 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/advection_solver/test_advection_solver.py
+-rw-r--r--   0 runner    (1001) docker     (127)      560 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/advection_solver/test_flux_limiters.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.703363 landlab-2.8.0/tests/components/bedrock_landslider/
+-rw-r--r--   0 runner    (1001) docker     (127)    13843 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/bedrock_landslider/test_bedrock_landslider.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.703363 landlab-2.8.0/tests/components/carbonate/
+-rw-r--r--   0 runner    (1001) docker     (127)     2147 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/carbonate/test_carbonate_producer.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.703363 landlab-2.8.0/tests/components/chi_index/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/chi_index/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1156 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/chi_index/test_chi_finder.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.707363 landlab-2.8.0/tests/components/concentration_tracker/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/concentration_tracker/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14758 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/concentration_tracker/test_concentration_tracker_for_diffusion.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.707363 landlab-2.8.0/tests/components/depression_finder/
+-rw-r--r--   0 runner    (1001) docker     (127)     5438 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/depression_finder/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43253 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/depression_finder/test_lake_mapper.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.707363 landlab-2.8.0/tests/components/depth_dependent_diffusion/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/depth_dependent_diffusion/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      782 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/depth_dependent_diffusion/test_depth_dependent_diffuser.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.707363 landlab-2.8.0/tests/components/depth_dependent_taylor_soil_creep/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/depth_dependent_taylor_soil_creep/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4619 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/depth_dependent_taylor_soil_creep/test_depth_dependent_taylor_diffuser.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.707363 landlab-2.8.0/tests/components/diffusion/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/diffusion/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10666 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/diffusion/test_sniff_diffusion.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.707363 landlab-2.8.0/tests/components/dimensionless_discharge/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/dimensionless_discharge/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2449 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/dimensionless_discharge/test_dimensionless_discharge.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.707363 landlab-2.8.0/tests/components/drainage_density/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/drainage_density/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8788 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/drainage_density/test_drainage_density.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.707363 landlab-2.8.0/tests/components/erosion_deposition/
+-rw-r--r--   0 runner    (1001) docker     (127)     5555 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/erosion_deposition/test_ero_dep_mass_conservation.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6796 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/erosion_deposition/test_ero_dep_with_flats.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6395 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/erosion_deposition/test_erodep.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5942 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/erosion_deposition/test_erodep_steady_state.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7114 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/erosion_deposition/test_general_erodep.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.707363 landlab-2.8.0/tests/components/flexure/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flexure/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      851 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flexure/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3748 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flexure/test_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4456 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flexure/test_flexure.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11490 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flexure/test_flexure_1d.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.711363 landlab-2.8.0/tests/components/flow_accum/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_accum/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7689 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_accum/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1364 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_accum/test_flow_accums.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32336 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_accum/test_flow_accumulator.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7610 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_accum/test_flow_routing.py
+-rw-r--r--   0 runner    (1001) docker     (127)    31802 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_accum/test_lossy_flow_accumulator.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.711363 landlab-2.8.0/tests/components/flow_director/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_director/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4406 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_director/test_cfuncs.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7882 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_director/test_dinf.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12095 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_director/test_flow_director.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7791 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_director/test_mfd.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.623362 landlab-2.8.0/tests/components/flow_router/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.623362 landlab-2.8.0/tests/components/flow_router/ext/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.623362 landlab-2.8.0/tests/components/flow_router/ext/single_flow/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.711363 landlab-2.8.0/tests/components/flow_router/ext/single_flow/priority_routing/
+-rw-r--r--   0 runner    (1001) docker     (127)      382 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_router/ext/single_flow/priority_routing/_priority_queue.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)      505 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_router/ext/single_flow/priority_routing/test_breach.py
+-rw-r--r--   0 runner    (1001) docker     (127)      425 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_router/ext/single_flow/priority_routing/test_breach_c.pxd
+-rw-r--r--   0 runner    (1001) docker     (127)    25955 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/flow_router/ext/single_flow/priority_routing/test_breach_c.pyx
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.711363 landlab-2.8.0/tests/components/fracture_grid/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/fracture_grid/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      933 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/fracture_grid/test_fracture_grid.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.711363 landlab-2.8.0/tests/components/gravel_bedrock_eroder/
+-rw-r--r--   0 runner    (1001) docker     (127)     6152 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/gravel_bedrock_eroder/test_gravel_bedrock_eroder.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.711363 landlab-2.8.0/tests/components/gravel_river_transporter/
+-rw-r--r--   0 runner    (1001) docker     (127)     9189 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/gravel_river_transporter/test_gravel_river_transporter.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.711363 landlab-2.8.0/tests/components/groundwater/
+-rw-r--r--   0 runner    (1001) docker     (127)    12214 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/groundwater/test_dupuit_percolator.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.711363 landlab-2.8.0/tests/components/hack_calculator/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/hack_calculator/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      996 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/hack_calculator/test_hack.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.711363 landlab-2.8.0/tests/components/hand_calculator/
+-rw-r--r--   0 runner    (1001) docker     (127)     1093 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/hand_calculator/test_hand.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.711363 landlab-2.8.0/tests/components/lake_fill/
+-rw-r--r--   0 runner    (1001) docker     (127)     6901 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/lake_fill/test_lake_fill.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.711363 landlab-2.8.0/tests/components/landslides/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/landslides/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      835 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/landslides/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9591 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/landslides/test_landslide_probability.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.715363 landlab-2.8.0/tests/components/lateral_erosion/
+-rw-r--r--   0 runner    (1001) docker     (127)    10809 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/lateral_erosion/test_latero.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1733 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/lateral_erosion/test_node_finder.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.715363 landlab-2.8.0/tests/components/lithology/
+-rw-r--r--   0 runner    (1001) docker     (127)     2026 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/lithology/test_litholayers.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11578 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/lithology/test_lithology.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.715363 landlab-2.8.0/tests/components/marine_sediment_transport/
+-rw-r--r--   0 runner    (1001) docker     (127)     5087 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/marine_sediment_transport/test_simple_submarine_diffuser.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.715363 landlab-2.8.0/tests/components/mass_wasting_runout/
+-rw-r--r--   0 runner    (1001) docker     (127)    11245 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/mass_wasting_runout/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)    52021 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/mass_wasting_runout/test_mass_wasting_runout.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.715363 landlab-2.8.0/tests/components/network_sediment_transporter/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4591 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2022 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/test_abrasion.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3796 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/test_active_layer_methods.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9062 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/test_bed_initializer.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3530 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/test_filo.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2225 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/test_init.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1127 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/test_init_sediment_pulser.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1708 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/test_parcel_leaves.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4738 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/test_pulse_sediment.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3141 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/test_recycling.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23077 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/test_sediment_pulser.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4355 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/network_sediment_transporter/test_transport.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.715363 landlab-2.8.0/tests/components/nonlinear_diffusion/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/nonlinear_diffusion/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5194 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/nonlinear_diffusion/test_sniff_nldiff.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.715363 landlab-2.8.0/tests/components/normal_fault/
+-rw-r--r--   0 runner    (1001) docker     (127)     8601 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/normal_fault/test_normal_fault.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.719363 landlab-2.8.0/tests/components/overland_flow/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/overland_flow/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1072 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/overland_flow/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5377 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/overland_flow/test_active_links_at_node.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2652 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/overland_flow/test_bates_overland_flow.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6293 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/overland_flow/test_dealmeida_overland_flow.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2453 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/overland_flow/test_kinwave.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5035 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/overland_flow/test_kinwave_implicit.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2137 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/overland_flow/test_linear_diffusion_overland_flow.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.719363 landlab-2.8.0/tests/components/pet/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/pet/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      352 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/pet/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2547 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/pet/test_pet.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.719363 landlab-2.8.0/tests/components/plant_competition_ca/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/plant_competition_ca/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      386 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/plant_competition_ca/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2229 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/plant_competition_ca/test_plant_competition_ca.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.719363 landlab-2.8.0/tests/components/potentiality_flowrouting/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/potentiality_flowrouting/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)       40 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/potentiality_flowrouting/pot_fr_params.txt
+-rw-r--r--   0 runner    (1001) docker     (127)    12125 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/potentiality_flowrouting/test_sniff_pot_fr.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.719363 landlab-2.8.0/tests/components/priority_flood_flow_router/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/priority_flood_flow_router/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29809 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/priority_flood_flow_router/test_priority_flood_flow_router.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.719363 landlab-2.8.0/tests/components/profiler/
+-rw-r--r--   0 runner    (1001) docker     (127)      835 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/profiler/test_base_profiler.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13086 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/profiler/test_channel_profile.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3162 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/profiler/test_profiler.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.719363 landlab-2.8.0/tests/components/radiation/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/radiation/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      278 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/radiation/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6307 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/radiation/test_radiation.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.719363 landlab-2.8.0/tests/components/sink_fill/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/sink_fill/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5002 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/sink_fill/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8806 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/sink_fill/test_sink_filler.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.723363 landlab-2.8.0/tests/components/soil_moisture/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/soil_moisture/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1597 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/soil_moisture/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2806 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/soil_moisture/test_green_ampt_infil.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3043 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/soil_moisture/test_soil_moisture.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.723363 landlab-2.8.0/tests/components/space/
+-rw-r--r--   0 runner    (1001) docker     (127)    15181 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/space/test_space.py
+-rw-r--r--   0 runner    (1001) docker     (127)    40498 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/space/test_space_large_scale_eroder.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.723363 landlab-2.8.0/tests/components/spatial_precip/
+-rw-r--r--   0 runner    (1001) docker     (127)     7800 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/spatial_precip/BCs_Singer.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/spatial_precip/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7800 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/spatial_precip/elevs_Singer.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     5761 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/spatial_precip/test_spatial_storm_generator.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.723363 landlab-2.8.0/tests/components/species_evolution/
+-rw-r--r--   0 runner    (1001) docker     (127)     1482 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/species_evolution/test_base_taxon.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2646 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/species_evolution/test_record.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5555 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/species_evolution/test_species_evolver.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14341 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/species_evolution/test_zone_objects.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.723363 landlab-2.8.0/tests/components/steepness_index/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/steepness_index/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      466 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/steepness_index/test_steepness_finder.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.727363 landlab-2.8.0/tests/components/stream_power/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    31250 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/perturbedcondst300.txt
+-rw-r--r--   0 runner    (1001) docker     (127)    62500 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/seddepinit.txt
+-rw-r--r--   0 runner    (1001) docker     (127)    62500 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/seddepz_tg.txt
+-rw-r--r--   0 runner    (1001) docker     (127)    31250 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/tenmorestepsfrom300.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     5139 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/test_fastscape.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1690 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/test_not_implemented_errors.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2838 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/test_sed_flux_dep.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5192 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/test_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2376 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/test_smooth_thresh.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3385 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/test_sp_driver_discharges.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2242 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/test_sp_driver_widths.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1665 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/test_sp_storms.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3824 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/stream_power/test_voronoi_sp.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.727363 landlab-2.8.0/tests/components/taylor_nonlinear_hillslope_flux/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/taylor_nonlinear_hillslope_flux/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1522 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/taylor_nonlinear_hillslope_flux/test_taylor_nonlinear_hillslope_flux.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.727363 landlab-2.8.0/tests/components/tectonics/
+-rw-r--r--   0 runner    (1001) docker     (127)     2069 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/tectonics/test_listric_kinematic_extender.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5739 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/test_components.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.727363 landlab-2.8.0/tests/components/threshold_eroder/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/threshold_eroder/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4262 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/threshold_eroder/test_threshold_eroder.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.727363 landlab-2.8.0/tests/components/tidal_flow_calculator/
+-rw-r--r--   0 runner    (1001) docker     (127)     7064 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/tidal_flow_calculator/test_tidal_flow_calculator.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.727363 landlab-2.8.0/tests/components/transport_length_diffusion/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/transport_length_diffusion/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6643 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/transport_length_diffusion/test_tl_hill_diff.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.727363 landlab-2.8.0/tests/components/vegetation_dynamics/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/vegetation_dynamics/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      666 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/vegetation_dynamics/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3025 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/vegetation_dynamics/test_vegetation_dynamics.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.727363 landlab-2.8.0/tests/components/weathering/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/weathering/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1916 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/weathering/test_exponential_weatherer.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4990 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/components/weathering/test_exponential_weathering_integrated.py
+-rw-r--r--   0 runner    (1001) docker     (127)      157 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/conftest.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.727363 landlab-2.8.0/tests/core/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/core/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1051 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/core/test_example_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1035 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/core/test_load_params.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4704 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/core/test_messager.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.731363 landlab-2.8.0/tests/data_record/
+-rw-r--r--   0 runner    (1001) docker     (127)     1049 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/data_record/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3889 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/data_record/test_data_record_2dim.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2220 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/data_record/test_data_record_item.py
+-rw-r--r--   0 runner    (1001) docker     (127)      256 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/data_record/test_data_record_nodim.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2032 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/data_record/test_data_record_time.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1907 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/data_record/test_dummy.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16732 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/data_record/test_errors.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.731363 landlab-2.8.0/tests/field/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/field/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5225 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/field/test_field_dataset.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8452 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/field/test_graph_fields.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.731363 landlab-2.8.0/tests/graph/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.731363 landlab-2.8.0/tests/graph/framed_voronoi/
+-rw-r--r--   0 runner    (1001) docker     (127)      280 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/framed_voronoi/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)      872 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/framed_voronoi/test_dual_framed_voronoi.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4674 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/framed_voronoi/test_framed_voronoi.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1712 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/framed_voronoi/test_perimeter_nodes.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.731363 landlab-2.8.0/tests/graph/hex/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/hex/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      556 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/hex/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2335 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/hex/test_dual_hex.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8995 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/hex/test_hex.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3909 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/hex/test_perimeter_nodes.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.731363 landlab-2.8.0/tests/graph/quantity/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/quantity/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6923 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/quantity/test_of_element.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.731363 landlab-2.8.0/tests/graph/radial/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/radial/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4818 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/radial/test_dual_radial.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.731363 landlab-2.8.0/tests/graph/sort/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/sort/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7659 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/sort/test_intpair.py
+-rw-r--r--   0 runner    (1001) docker     (127)      768 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/sort/test_remap.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.731363 landlab-2.8.0/tests/graph/structured_quad/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/structured_quad/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7367 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/structured_quad/test_dual_quad.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9338 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/structured_quad/test_quad.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4074 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/test_graph.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.735363 landlab-2.8.0/tests/graph/voronoi/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/voronoi/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7543 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/graph/voronoi/test_voronoi_to_graph.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.735363 landlab-2.8.0/tests/grid/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1470 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10140 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_constructors.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.735363 landlab-2.8.0/tests/grid/test_create/
+-rw-r--r--   0 runner    (1001) docker     (127)      131 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_create/4_x_3_no_nodata_value.asc
+-rw-r--r--   0 runner    (1001) docker     (127)      318 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_create/bad_boundary.yaml
+-rw-r--r--   0 runner    (1001) docker     (127)    11426 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_create/test-netcdf4.nc
+-rw-r--r--   0 runner    (1001) docker     (127)    16619 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_create.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23728 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_create_network.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1830 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_diagonals.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.735363 landlab-2.8.0/tests/grid/test_framed_voronoi_grid/
+-rw-r--r--   0 runner    (1001) docker     (127)     1397 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_framed_voronoi_grid/test_edges.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1141 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_framed_voronoi_grid/test_link_order.py
+-rw-r--r--   0 runner    (1001) docker     (127)      531 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_framed_voronoi_grid/test_links.py
+-rw-r--r--   0 runner    (1001) docker     (127)      646 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_framed_voronoi_grid/test_nodes_.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1042 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_framed_voronoi_grid/test_patches.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4271 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_grid_reference.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.739363 landlab-2.8.0/tests/grid/test_hex_grid/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_hex_grid/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1523 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_hex_grid/test_edges.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5794 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_hex_grid/test_flux_divergence_hex_grid.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1948 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_hex_grid/test_link_order.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6809 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_hex_grid/test_links.py
+-rw-r--r--   0 runner    (1001) docker     (127)      572 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_hex_grid/test_nodes.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1198 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_hex_grid/test_patches.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1663 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_hex_mappers.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2346 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_mappers.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.739363 landlab-2.8.0/tests/grid/test_radial_grid/
+-rw-r--r--   0 runner    (1001) docker     (127)     1325 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_radial_grid/test_nodes.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2856 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_divergence.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.739363 landlab-2.8.0/tests/grid/test_raster_funcs/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_funcs/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1772 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_funcs/test_best_fit_plane.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2248 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_funcs/test_find_nearest_node.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1791 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_funcs/test_gradients_across_cell_corners.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1707 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_funcs/test_gradients_across_cell_faces.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3638 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_funcs/test_gradients_at_active_links.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2846 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_funcs/test_gradients_at_links.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1413 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_funcs/test_is_on_grid.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2177 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_funcs/test_line_to_grid_coords.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2335 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_funcs/test_node_id_of_adjacent.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6959 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_gradients.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.743363 landlab-2.8.0/tests/grid/test_raster_grid/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      163 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1807 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_allocators.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1843 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_axis_methods.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1924 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_bc_updates.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1119 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_cell_areas.py
+-rw-r--r--   0 runner    (1001) docker     (127)      767 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_corners.py
+-rw-r--r--   0 runner    (1001) docker     (127)      769 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_faces.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2661 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_fields.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2100 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_fixed_link_boundary.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1923 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_has_boundary_neighbor.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12477 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_init.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2535 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_is_boundary.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2074 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_link_length.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1734 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_link_order.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6613 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_mappers.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5070 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_neighbor_nodes.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4144 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_nodes.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1855 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_nodes_around_point.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5048 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_patches.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2561 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_save.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2253 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_raster_grid/test_status_at_node.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1201 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/test_voronoi.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.743363 landlab-2.8.0/tests/grid/unstructured/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/unstructured/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3107 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/grid/unstructured/test_links.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.743363 landlab-2.8.0/tests/io/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.743363 landlab-2.8.0/tests/io/legacy_vtk/
+-rw-r--r--   0 runner    (1001) docker     (127)     3682 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/legacy_vtk/test_legacy_vtk.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.743363 landlab-2.8.0/tests/io/netcdf/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/netcdf/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      336 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/netcdf/conftest.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.743363 landlab-2.8.0/tests/io/netcdf/test_from_netcdf/
+-rw-r--r--   0 runner    (1001) docker     (127)    13449 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/netcdf/test_from_netcdf/test-HexModelGrid.nc
+-rw-r--r--   0 runner    (1001) docker     (127)    13414 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/netcdf/test_from_netcdf/test-RadialModelGrid.nc
+-rw-r--r--   0 runner    (1001) docker     (127)    12978 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/netcdf/test_from_netcdf/test-RasterModelGrid.nc
+-rw-r--r--   0 runner    (1001) docker     (127)     2324 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/netcdf/test_from_netcdf.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.747363 landlab-2.8.0/tests/io/netcdf/test_read_netcdf/
+-rw-r--r--   0 runner    (1001) docker     (127)      728 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/netcdf/test_read_netcdf/test-netcdf3-64bit.nc
+-rw-r--r--   0 runner    (1001) docker     (127)    11426 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/netcdf/test_read_netcdf/test-netcdf4.nc
+-rw-r--r--   0 runner    (1001) docker     (127)     3078 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/netcdf/test_read_netcdf.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7574 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/netcdf/test_to_netcdf.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10297 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/netcdf/test_write_netcdf.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8089 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/netcdf/test_write_raster_netcdf.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.747363 landlab-2.8.0/tests/io/test_read_esri_ascii/
+-rw-r--r--   0 runner    (1001) docker     (127)      152 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_read_esri_ascii/4_x_3.asc
+-rw-r--r--   0 runner    (1001) docker     (127)      131 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_read_esri_ascii/4_x_3_no_nodata_value.asc
+-rw-r--r--   0 runner    (1001) docker     (127)    23092 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_read_esri_ascii/hugo_site.asc
+-rw-r--r--   0 runner    (1001) docker     (127)     9860 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_read_esri_ascii.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5483 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_read_write_native.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.747363 landlab-2.8.0/tests/io/test_shapefile/
+-rw-r--r--   0 runner    (1001) docker     (127)       76 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_shapefile/multipartpolyline.dbf
+-rw-r--r--   0 runner    (1001) docker     (127)      452 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_shapefile/multipartpolyline.shp
+-rw-r--r--   0 runner    (1001) docker     (127)      108 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_shapefile/multipartpolyline.shx
+-rw-r--r--   0 runner    (1001) docker     (127)      109 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_shapefile/points.dbf
+-rw-r--r--   0 runner    (1001) docker     (127)      212 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_shapefile/points.shp
+-rw-r--r--   0 runner    (1001) docker     (127)      132 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_shapefile/points.shx
+-rw-r--r--   0 runner    (1001) docker     (127)    14974 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_shapefile.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3553 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_shapefile_infer_dtype.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5277 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_write_esri_ascii.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2645 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/io/test_write_obj.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.747363 landlab-2.8.0/tests/layers/
+-rw-r--r--   0 runner    (1001) docker     (127)     8272 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/layers/test_event_layers.py
+-rw-r--r--   0 runner    (1001) docker     (127)      578 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/layers/test_material_layers.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.747363 landlab-2.8.0/tests/plot/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/plot/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.747363 landlab-2.8.0/tests/plot/network_sediment_transporter/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/plot/network_sediment_transporter/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6373 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/plot/network_sediment_transporter/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5635 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/plot/network_sediment_transporter/test_plot_network_and_parcels.py
+-rw-r--r--   0 runner    (1001) docker     (127)      649 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/plot/test_drainage_plot.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1183 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/plot/test_event_handler.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2033 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/plot/test_graph.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18630 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/plot/test_imshow_grid.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3614 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/plot/test_layers.py
+-rw-r--r--   0 runner    (1001) docker     (127)      195 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/run_raster_model_grid_builtin_unit_test.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.751363 landlab-2.8.0/tests/utils/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      744 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_count_repeats.py
+-rw-r--r--   0 runner    (1001) docker     (127)      466 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_decorators.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5241 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_distance_from_divide.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10498 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_flow__distance.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2275 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_halo.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7227 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_matrix.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5742 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_neighbor_node_array.py
+-rw-r--r--   0 runner    (1001) docker     (127)      822 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_return_grid.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2756 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_source_tracking_algorithm.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1485 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_stable_priority_queue.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26443 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_structured_grid.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6113 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_watershed.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3211 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/utils/test_window_statistic.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-12 23:30:00.751363 landlab-2.8.0/tests/values/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/values/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      839 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/values/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7251 2024-05-12 23:29:42.000000 landlab-2.8.0/tests/values/test_synthetic.py
```

### Comparing `landlab-2.7.0/.credits.toml` & `landlab-2.8.0/.credits.toml`

 * *Files 2% similar despite different names*

```diff
@@ -358,13 +358,21 @@
 email = '49699333+dependabot[bot]@users.noreply.github.com'
 aliases = [
 ]
 alternate_emails = [
 ]
 
 [[tool.landlab.credits.author]]
+name = 'pre-commit-ci[bot]'
+email = '66853113+pre-commit-ci[bot]@users.noreply.github.com'
+aliases = [
+]
+alternate_emails = [
+]
+
+[[tool.landlab.credits.author]]
 name = 'root'
 email = 'root@093548ea-dc74-4ebb-8037-4be9f23db00a'
 aliases = [
 ]
 alternate_emails = [
 ]
```

### Comparing `landlab-2.7.0/.mailmap` & `landlab-2.8.0/.mailmap`

 * *Files 1% similar despite different names*

```diff
@@ -190,8 +190,9 @@
 Sarah Lundell <s_lundell@att.net> slundell123 <s_lundell@att.net>
 Sebastien Lenard <sebastien.lenard@gmail.com> Sebastien Lenard <91671955+sebastien-lenard@users.noreply.github.com>
 Sebastien Lenard <sebastien.lenard@gmail.com> Sebastien Lenard <sebastien.lenard@gmail.com>
 Sebastien Lenard <sebastien.lenard@gmail.com> sebastien-lenard <91671955+sebastien-lenard@users.noreply.github.com>
 Sebastien Lenard <sebastien.lenard@gmail.com> sebastien-lenard <sebastien.lenard@gmail.com>
 Shelby Ahrendt <36043125+shelbyahrendt@users.noreply.github.com> Shelby Ahrendt <36043125+shelbyahrendt@users.noreply.github.com>
 dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com> dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
+pre-commit-ci[bot] <66853113+pre-commit-ci[bot]@users.noreply.github.com> pre-commit-ci[bot] <66853113+pre-commit-ci[bot]@users.noreply.github.com>
 root <root@093548ea-dc74-4ebb-8037-4be9f23db00a> root <root@093548ea-dc74-4ebb-8037-4be9f23db00a>
```

### Comparing `landlab-2.7.0/AUTHORS.rst` & `landlab-2.8.0/AUTHORS.rst`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/CHANGES.rst` & `landlab-2.8.0/CHANGES.rst`

 * *Files 1% similar despite different names*

```diff
@@ -2,14 +2,82 @@
 Release Notes
 =============
 
 .. towncrier-draft-entries:: Not yet released
 
 .. towncrier release notes start
 
+2.8.0 (2024-05-12)
+------------------
+
+New Components
+``````````````
+
+- Added new component :class:`~.ConcentrationTrackerForDiffusion`
+  for tracking hillslope sediment properties. (`#1662 <https://github.com/landlab/landlab/issues/1662>`_)
+- Added new component :class:`~.MassWastingRunout`
+  for predicting the hazard extent, sediment transport and topographic change associated with the runout of a landslide. (`#1830 <https://github.com/landlab/landlab/issues/1830>`_)
+
+
+New Features
+````````````
+
+- Fixed the Radiation component by computing fields with ASCE standard formulas, added
+  increased test coverage for both field computations and standard unit testing.
+  Min, max, and avg daily temp are also three optional, newly added
+  user-defined arguments for the component. (`#1755 <https://github.com/landlab/landlab/issues/1755>`_)
+- Added a new grid type, :class:`~.IcosphereGlobalGrid` (plus underlying graph
+  machinery, etc.). (`#1808 <https://github.com/landlab/landlab/issues/1808>`_)
+- Added a new function, calc_net_face_flux_at_cell, that computes the
+  net flux of a quantity into each of a RasterModelGrid's cells. This
+  function uses openmp to parallelize its calculations. (`#1900 <https://github.com/landlab/landlab/issues/1900>`_)
+- Added a new *vtk* writer, ``landlab.io.legacy_vtk.dump`` that is
+  able to write *Landlab* grids that have three spatial coordinates.
+  This function is also able to write both the main grid (*nodes* and
+  *patches*) as well as the dual grid (*corners* and *cells*). (`#1932 <https://github.com/landlab/landlab/issues/1932>`_)
+
+
+Bug Fixes
+`````````
+
+- Fixed a bug when ordering links at patches with patches composed of varying
+  numbers of links. (`#1807 <https://github.com/landlab/landlab/issues/1807>`_)
+- Fixed a bug where SpaceLargeScaleEroder deviates from analytical solution for mixed bedrock-alluvial river in a portion of the parameter space. (`#1901 <https://github.com/landlab/landlab/issues/1901>`_)
+- Fixed a bug that caused a ``ModuleNotFoundError`` for *pkg_config* on
+  Python 3.12. (`#1927 <https://github.com/landlab/landlab/issues/1927>`_)
+
+
+Documentation Enhancements
+``````````````````````````
+
+- Update list of publications in USEDBY.rst. (`#1928 <https://github.com/landlab/landlab/issues/1928>`_)
+
+
+Other Changes and Additions
+```````````````````````````
+
+- Removed the broken ``map_link_vector_to_nodes`` method from
+  ``ModelGrid``. As a replacement, use
+  :func:`~.map_link_vector_components_to_node_raster` for raster grids, and
+  :func:`~.map_link_vector_components_to_node_hex` for hex grids. (`#1786 <https://github.com/landlab/landlab/issues/1786>`_)
+- Fixed the path to the requirements file needed by *readthedocs*. (`#1797 <https://github.com/landlab/landlab/issues/1797>`_)
+- Fixed an issue that caused with the CI to fail when building *multidict* on
+  Mac and Python 3.12. (`#1850 <https://github.com/landlab/landlab/issues/1850>`_)
+- Fixed warnings caused by using xarray.Dataset.dims rather than
+  xarray.Dataset.sizes. (`#1910 <https://github.com/landlab/landlab/issues/1910>`_)
+- Added a list of Landlab's extensions to setup.py that must be
+  maintained manually. This replaces the old, and somewhat buggy,
+  method of conducting a recursive glob for pyx files. (`#1915 <https://github.com/landlab/landlab/issues/1915>`_)
+- Added a new linter, *cython-lint*, that checks for lint in cython
+  files. (`#1924 <https://github.com/landlab/landlab/issues/1924>`_)
+- Changed the *numpy* printing options from the legacy 1.13 format
+  to the latest, default, version. (`#1929 <https://github.com/landlab/landlab/issues/1929>`_)
+- Removed duplicate shapefile modules. (`#1933 <https://github.com/landlab/landlab/issues/1933>`_)
+
+
 2.7.0 (2023-11-04)
 ------------------
 
 New Components
 ``````````````
 
 - Added new component :class:`~.GravelBedrockEroder` to model rock-cutting gravel rivers. (`#1505 <https://github.com/landlab/landlab/issues/1505>`_)
```

### Comparing `landlab-2.7.0/CITATION.cff` & `landlab-2.8.0/CITATION.cff`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/FUNDING.rst` & `landlab-2.8.0/FUNDING.rst`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/LICENSE.rst` & `landlab-2.8.0/LICENSE.rst`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/MANIFEST.in` & `landlab-2.8.0/MANIFEST.in`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/PKG-INFO` & `landlab-2.8.0/PKG-INFO`

 * *Files 5% similar despite different names*

```diff
@@ -1,37 +1,16 @@
 Metadata-Version: 2.1
 Name: landlab
-Version: 2.7.0
+Version: 2.8.0
 Summary: Open-source Python package for numerical modeling of Earth surface dynamics.
 Author: The landlab team
 Author-email: mcflugen@gmail.com
 Maintainer: The landlab team
 Maintainer-email: mcflugen@gmail.com
-License: The MIT License (MIT)
-        =====================
-        
-        Copyright (c) `2013` `The Landlab Team`
-        
-        Permission is hereby granted, free of charge, to any person obtaining a copy of
-        this software and associated documentation files (the "Software"), to deal in
-        the Software without restriction, including without limitation the rights to
-        use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-        the Software, and to permit persons to whom the Software is furnished to do so,
-        subject to the following conditions:
-        
-        The above copyright notice and this permission notice shall be included in all
-        copies or substantial portions of the Software.
-        
-        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-        FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-        COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-        IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-        CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-        
+License: MIT
 Project-URL: homepage, https://github.com/landlab
 Project-URL: documentation, https://landlab.readthedocs.io
 Project-URL: repository, https://github.com/landlab
 Project-URL: changelog, https://github.com/landlab/landlab/blob/develop/CHANGES.rst
 Keywords: bmi,component modeling,earth science,gridding engine,model coupling,numerical modeling
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Science/Research
@@ -45,14 +24,15 @@
 Classifier: Programming Language :: Python :: Implementation :: CPython
 Classifier: Topic :: Scientific/Engineering :: Physics
 Requires-Python: >=3.10
 Description-Content-Type: text/x-rst
 License-File: LICENSE.rst
 License-File: AUTHORS.rst
 Requires-Dist: bmipy
+Requires-Dist: importlib-resources; python_version < "3.12"
 Requires-Dist: matplotlib
 Requires-Dist: netcdf4
 Requires-Dist: numpy>=1.20
 Requires-Dist: pyyaml
 Requires-Dist: pyshp!=2.3.0
 Requires-Dist: rich-click
 Requires-Dist: scipy
```

### Comparing `landlab-2.7.0/README.rst` & `landlab-2.8.0/README.rst`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/USEDBY.rst` & `landlab-2.8.0/USEDBY.rst`

 * *Files 2% similar despite different names*

```diff
@@ -2,31 +2,62 @@
 Papers and Presentations
 ========================
 
 ------------------------------
 Peer-reviewed journal articles
 ------------------------------
 
+2024
+----
+
+Bower, S. J., Shobe, C. M., Maxwell, A. E., & Campforts, B. (2024). **The uncertain future of mountaintop-removal-mined landscapes 2: Modeling the influence of topography and vegetation.** *Geomorphology,* 446, 108985.
+
+Chen, H., Wang, X., Yu, Y., Lu, H., & Van Balen, R. (2024). **Past anthropogenic land use change caused a regime shift of the fluvial response to Holocene climate change in the Chinese Loess Plateau.** *Earth Surface Dynamics,* 12(1), 163-180.
+
+Gan, T., Tucker, G. E., Hutton, E. W., Piper, M. D., Overeem, I., Kettner, A. J., Campforts, B., Moriarty, J.M., Undzis, B., Pierce, E. and McCready, L., (2024). **CSDMS Data Components: datamodel integration tools for Earth surface processes modeling**. *Geoscientific Model Development,* 17(5), 2165-2185, `https://doi.org/10.5194/gmd-17-2165-2024 <https://doi.org/10.5194/gmd-17-2165-2024>`__.
+
+Mohr, C. H., Dietze, M., Tolorza, V., Gonzalez, E., Sotomayor, B., Iroume, A., Mohr, C.H., Dietze, M., Tolorza, V., Gonzalez, E., Sotomayor, B., Iroume, A., Gilfert, S., and Tautz, F. (2024). **Ideas and perspectives: Sensing energy and matter fluxes in a biota-dominated Patagonian landscape through environmental seismologyintroducing the Pumaln Critical Zone Observatory.** *Biogeosciences,* 21(6), 1583-1599.
+
+Rosier, I., Diels, J., Somers, B., & Van Orshoven, J. (2024). **Maximising runoff retention by vegetated landscape elements positioned through spatial optimisation.** *Landscape and Urban Planning,* 243, 104968.
+
+Shmilovitz, Y., Tucker, G. E., Rossi, M. W., Morin, E., Armon, M., Pederson, J., ... & Enzel, Y. (2024). **Impacts of rainstorm intensity and temporal pattern on caprock cliff persistence and hillslope morphology in drylands.** *Journal of Geophysical Research: Earth Surface,* 129(2), e2023JF007478, `https://doi.org/10.1029/2023JF007478 <https://doi.org/10.1029/2023JF007478>`__.
+
+Shobe, C. M., Bower, S. J., Maxwell, A. E., Glade, R. C., & Samassi, N. M. (2024). **The uncertain future of mountaintop-removal-mined landscapes 1: How mining changes erosion processes and variables.** *Geomorphology,* 445, 108984.
+
+Walker, S. J., Wilkinson, S. N., & Hairsine, P. B. (2024). **Advancing gully topographic threshold analysis using an automated algorithm and high-resolution topography.** *CATENA,* 239, 107897.
+
+Wang, Y. (2024) **Identifying geomorphic domains using hierarchically clustered drainage areaslope scaling.** *Earth Surface Processes and Landforms,* https://doi.org/10.1002/esp.5796.
+
 2023
 ----
 
+Cardenas, B. T., & Stacey, K. (2023). **Landforms Associated With the Aspect-Controlled Exhumation of Crater-Filling Alluvial Strata on Mars.** Geophysical Research Letters, 50(15), e2023GL103618.
+
 Eschenfelder, J., Lipp, A. G., & Roberts, G. G. (2023). **Quantifying excess heavy metal concentrations in drainage basins using conservative mixing models.** *Journal of Geochemical Exploration,* 248, 107178, `https://doi.org/10.1016/j.gexplo.2023.107178 <https://doi.org/10.1016/j.gexplo.2023.107178>`__.
 
 Fiolleau, S., Uhlemann, S., Falco, N., & Dafflon, B. (2023). **Assessing probability of failure of urban landslides through rapid characterization of soil properties and vegetation distribution.** *Geomorphology,* 423, 108560, `https://doi.org/10.1016/j.geomorph.2022.108560 <https://doi.org/10.1016/j.geomorph.2022.108560>`__.
 
+Morris, M. J., Lipp, A. G., & Roberts, G. G. (2023). **Towards inverse modeling of landscapes using the Wasserstein distance.** *Geophysical Research Letters,* 50(14), e2023GL103880.
+
 Nudurupati, S. S., Istanbulluoglu, E., Tucker, G. E., Gasparini, N. M., Hobley, D. E., Hutton, E. W., Barnhart, Katherine R., and Adams, J. M. (2023). **On transient semiarid ecosystem dynamics using Landlab: Vegetation shifts, topographic refugia, and response to climate.** *Water Resources Research,* e2021WR031179, `https://doi.org/10.1029/2021WR031179 <https://doi.org/10.1029/2021WR031179>`__.
 
+Raistrick, A., Lipson, L., Ma, Z., Mei, L., Wang, M., Zuo, Y., Kayan, K., Wen, H., Han, B., Wang, Y., and Newell, A. (2023). **Infinite photorealistic worlds using procedural generation.** In *Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition* (pp. 12630-12641).
+
 Rosier, I., Diels, J., Somers, B., & Van Orshoven, J. (2023). **The impact of vegetated landscape elements on runoff in a small agricultural watershed: A modelling study.** *Journal of Hydrology,* 129144, `https://doi.org/10.1016/j.jhydrol.2023.129144 <https://doi.org/10.1016/j.jhydrol.2023.129144>`__.
-<
+
+Shmilovitz, Y., Marra, F., Enzel, Y., Morin, E., Armon, M., Matmon, A., ... & Haviv, I. (2023). **The impact of extreme rainstorms on escarpment morphology in arid areas: Insights from the central Negev Desert.** *Journal of Geophysical Research: Earth Surface,* e2023JF007093.
+
+Wang, Y., Chen, S. M., Xiong, L. Y., & Li, S. J. (2023). **Paleotopography-constrained numerical modeling of loess landform evolution.** *Geomorphology,* 433, 108725.
+
 2022
 ----
 
-Campforts, B., Shobe, C.M., Overeem, I., and Tucker, G.E. (2022) **The art of landslides: how stochastic
-mass wasting shapes topography and influences landscape dynamics.** *Journal of Geophysical Research:
-Earth Surface,* v. 127(8), e2022JF006745, `https://doi.org/10.1029/2022JF006745 <https://doi.org/10.1029/2022JF006745>`__.
+Anders, A. M., Lai, J., & Marshak, S. (2022). **Development of Foreland Intracratonic Plateaus (Ozark Plateau and Appalachian Plateaus): A Consequence of Topographic Inversion Due To Erosion of Adjacent Fold-Thrust Belts.** *Tectonics,* 41(4), e2021TC006957.
+
+Campforts, B., Shobe, C.M., Overeem, I., and Tucker, G.E. (2022) **The art of landslides: how stochastic mass wasting shapes topography and influences landscape dynamics.** *Journal of Geophysical Research: Earth Surface,* v. 127(8), e2022JF006745, `https://doi.org/10.1029/2022JF006745 <https://doi.org/10.1029/2022JF006745>`__.
 
 Cardenas, B. T., Lamb, M. P., & Grotzinger, J. P. (2022). **Martian landscapes of fluvial ridges carved from ancient sedimentary basin fill.** *Nature Geoscience,* 1-7. `https://www.nature.com/articles/s41561-022-01058-2 <https://www.nature.com/articles/s41561-022-01058-2>`__.
 
 Cullen, C., Anders, A. M., Lai, J., & Druhan, J. L. (2022). **Numerical modeling of groundwaterdriven stream network evolution in lowrelief postglacial landscapes.** *Earth Surface Processes and Landforms,* 47(2), 658-671, `https://doi.org/10.1002/esp.5278 <https://doi.org/10.1002/esp.5278>`__.
 >
 Gray, H. J., DuRoss, C. B., Nicovich, S. R., & Gold, R. D. (2022). **A geomorphic-process-based cellular automata model of colluvial wedge morphology and stratigraphy.** *Earth Surface Dynamics,* 10(2), 329-348, `https://doi.org/10.5194/esurf-10-329-2022 <https://doi.org/10.5194/esurf-10-329-2022>`__.
 
@@ -115,53 +146,29 @@
 Walker, S. J., Wilkinson, S. N., van Dijk, A. I., & Hairsine, P. B. (2020). **A multi-resolution method to map and identify locations of future gully and channel incision.** *Geomorphology,* 358, 107115, `https://doi.org/10.1016/j.geomorph.2020.107115 <https://doi.org/10.1016/j.geomorph.2020.107115>`__.
 
 2019
 ----
 
 Baldazo, D., Parras, J., & Zazo, S. (2019). **Decentralized multi-agent deep reinforcement learning in swarms of drones for flood monitoring.** In *2019 27th European Signal Processing Conference (EUSIPCO)* (pp. 1-5). IEEE.
 
-Bandaragoda, C. J., Castronova, A., Istanbulluoglu, E., Strauch, R.,
-Nudurupati, S. S., Phuong, J., Adams, J.M., Gasparini, N.M., Barnhart,
-K.R., Hutton, E.W.H., Hobley, D.E.J., Lyons, N.J., Tucker, G.E.,
-Tarboton, D.G., Idaszak, R., and Wang S. (2019). **Enabling
-collaborative numerical Modeling in Earth sciences using Knowledge
-Infrastructure.** *Environmental Modelling & Software*,
-`doi:10.1016/j.envsoft.2019.03.020 <https://linkinghub.elsevier.com/retrieve/pii/S1364815219301562>`__.
-
-Barnhart, K. R., Glade, R. C., Shobe, C. M., and Tucker, G. E. (2019)
-**Terrainbento 1.0: a Python package for multi-model analysis in
-long-term drainage basin evolution.** *Geosci. Model Dev.*, v. 12,
-p.1267-1297, `doi:10.5194/gmd-12-1267-2019 <https://www.geosci-model-dev.net/12/1267/2019/>`__.
+Bandaragoda, C. J., Castronova, A., Istanbulluoglu, E., Strauch, R., Nudurupati, S. S., Phuong, J., Adams, J.M., Gasparini, N.M., Barnhart, K.R., Hutton, E.W.H., Hobley, D.E.J., Lyons, N.J., Tucker, G.E., Tarboton, D.G., Idaszak, R., and Wang S. (2019). **Enabling collaborative numerical Modeling in Earth sciences using Knowledge Infrastructure.** *Environmental Modelling & Software*, `doi:10.1016/j.envsoft.2019.03.020 <https://linkinghub.elsevier.com/retrieve/pii/S1364815219301562>`__.
+
+Barnhart, K. R., Glade, R. C., Shobe, C. M., and Tucker, G. E. (2019) **Terrainbento 1.0: a Python package for multi-model analysis in long-term drainage basin evolution.** *Geosci. Model Dev.*, v. 12, p.1267-1297, `doi:10.5194/gmd-12-1267-2019 <https://www.geosci-model-dev.net/12/1267/2019/>`__.
 
 Barnhart, K.R., Hutton, E., and Tucker, G.E. (2019) **umami: a Python package for Earth surface dynamics objective function construction**, *Journal of Open Source Software*, 4(42), 1776, `doi:10.21105/joss.01776 <https://doi.org/10.21105/joss.01776>`__.
 
-Glade, R.C.*, Shobe, C.M.*, Anderson, R.S., and Tucker, G.E. (2019)
-**Canyon shape and erosion dynamics governed by channel-hillslope
-feedbacks.** *Geology*,
-`doi:10.1130/G46219.1 <https://pubs.geoscienceworld.org/gsa/geology/article/47/7/650/570313/Canyon-shape-and-erosion-dynamics-governed-by>`__. \*Equal
-contributions
-
-Phuong J., C. Bandaragoda, E. Istanbulluoglu, C. Beveridge, R. Strauch,
-L. Setiawan, and S. D. Mooney (2019). **Automated retrieval,
-preprocessing, and visualization of gridded hydrometeorology data
-products for spatial-temporal exploratory analysis and
-intercomparison.** Environmental Modeling and Software. Vol 116.
-p.119-30: https://linkinghub.elsevier.com/retrieve/pii/S136481521830865X.
+Glade, R.C.*, Shobe, C.M.*, Anderson, R.S., and Tucker, G.E. (2019) **Canyon shape and erosion dynamics governed by channel-hillslope feedbacks.** *Geology*, `doi:10.1130/G46219.1 <https://pubs.geoscienceworld.org/gsa/geology/article/47/7/650/570313/Canyon-shape-and-erosion-dynamics-governed-by>`__. \*Equal contributions
+
+Phuong J., C. Bandaragoda, E. Istanbulluoglu, C. Beveridge, R. Strauch, L. Setiawan, and S. D. Mooney (2019). **Automated retrieval, preprocessing, and visualization of gridded hydrometeorology data products for spatial-temporal exploratory analysis and intercomparison.** Environmental Modeling and Software. Vol 116. p.119-30: https://linkinghub.elsevier.com/retrieve/pii/S136481521830865X.
 
 Reitman, N.G., Mueller, K.J., Tucker, G.E., Gold, R.D., Briggs, R.D., and Barnhart, K.R. (2019) **Landscape Evolution Models Demonstrate that Offset Channels are Incomplete Records of Strike-Slip Fault Displacement.** *Journal of Geophysical Research: Solid Earth*, 124, `doi:10.1029/2019JB018596 <https://doi.org/10.1029/2019JB018596>`__.
 
-Sharman, G. R., Sylvester, Z., & Covault, J. A. (2019). **Conversion of
-tectonic and climatic forcings into records of sediment supply and
-provenance.** *Scientific Reports*, 9(1), 4115,
-`doi:10.1038/s41598-019-39754-6 <https://www.nature.com/articles/s41598-019-39754-6>`__.
-
-Zebari, M., Grtzner, C., Navabpour, P., & Ustaszewski, K. (2019).
-**Relative timing of uplift along the Zagros Mountain Front Flexure
-(Kurdistan Region of Iraq): Constrained by geomorphic indices and
-landscape evolution modeling.** *Solid Earth*, 10(3), 663-682
+Sharman, G. R., Sylvester, Z., & Covault, J. A. (2019). **Conversion of tectonic and climatic forcings into records of sediment supply and provenance.** *Scientific Reports*, 9(1), 4115, `doi:10.1038/s41598-019-39754-6 <https://www.nature.com/articles/s41598-019-39754-6>`__.
+
+Zebari, M., Grtzner, C., Navabpour, P., & Ustaszewski, K. (2019). **Relative timing of uplift along the Zagros Mountain Front Flexure (Kurdistan Region of Iraq): Constrained by geomorphic indices and landscape evolution modeling.** *Solid Earth*, 10(3), 663-682
 `doi:10.5194/se-10-663-2019 <https://www.solid-earth.net/10/663/2019/>`__.
 
 2018
 ----
 
 Barnhart, K. R., Hutton, E. W., Gasparini, N. M., & Tucker, G. E.
 (2018). **Lithology: A Landlab submodule for spatially variable rock
```

### Comparing `landlab-2.7.0/landlab/_info.py` & `landlab-2.8.0/landlab/_info.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/_registry.py` & `landlab-2.8.0/landlab/_registry.py`

 * *Files 0% similar despite different names*

```diff
@@ -120,15 +120,14 @@
 import os
 
 from . import _info
 from .core.messages import indent_and_wrap
 
 
 class ComponentRegistry:
-
     """A registry for instantiated landlab components."""
 
     def __init__(self, objs=None):
         self._registered = []
         if objs is not None:
             try:
                 [self.add(obj) for obj in objs]
```

### Comparing `landlab-2.7.0/landlab/bmi/bmi_bridge.py` & `landlab-2.8.0/landlab/bmi/bmi_bridge.py`

 * *Files 0% similar despite different names*

```diff
@@ -8,23 +8,25 @@
 Function reference
 ------------------
 
 The `wrap_as_bmi` function wraps a landlab component class so that it
 exposes a Basic Modelling Interface.
 
 """
+
 import inspect
 
 import numpy as np
 from bmipy import Bmi
 
 from ..core import load_params
 from ..core.model_component import Component
 from ..framework.decorators import snake_case
-from ..grid import HexModelGrid, RasterModelGrid
+from ..grid import HexModelGrid
+from ..grid import RasterModelGrid
 from ..grid.create import create_grid
 
 BMI_LOCATION = {
     "node": "node",
     "link": "edge",
     "patch": "face",
     "corner": "node",
@@ -41,15 +43,14 @@
     "face": 1,
     "cell": 1,
     "grid": 2,
 }
 
 
 class TimeStepper:
-
     """Step through time.
 
     Parameters
     ----------
     start : float, optional
         Clock start time.
     stop : float, optional
@@ -354,17 +355,17 @@
 
             params = load_params(config_file)
             params.pop("grid")
             clock_params = params.pop("clock")
             self._clock = TimeStepper(**clock_params)
 
             self._base = self._cls(grid, **params.pop(snake_case(cls.__name__), {}))
-            self._base.grid.at_node[
-                "boundary_condition_flag"
-            ] = self._base.grid.status_at_node
+            self._base.grid.at_node["boundary_condition_flag"] = (
+                self._base.grid.status_at_node
+            )
 
         def update(self):
             """Update the component one time step."""
             if hasattr(self._base, "update"):
                 self._base.update()
             elif hasattr(self._base, "run_one_step"):
                 args = []
```

### Comparing `landlab-2.7.0/landlab/bmi/standard_names.py` & `landlab-2.8.0/landlab/bmi/standard_names.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/ca/boundaries/hex_lattice_tectonicizer.py` & `landlab-2.8.0/landlab/ca/boundaries/hex_lattice_tectonicizer.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,30 +9,29 @@
 sideways (representing motion on a fault plane).
 
 Created on Mon Nov 17 08:01:49 2014
 
 @author: gtucker
 """
 
-from numpy import (
-    amax,
-    arange,
-    array,
-    cos,
-    logical_and,
-    logical_or,
-    logical_xor,
-    pi,
-    sqrt,
-    tan,
-    where,
-    zeros,
-)
+from numpy import amax
+from numpy import arange
+from numpy import array
+from numpy import cos
+from numpy import logical_and
+from numpy import logical_or
+from numpy import logical_xor
+from numpy import pi
+from numpy import sqrt
+from numpy import tan
+from numpy import where
+from numpy import zeros
 
-from landlab import HexModelGrid, LinkStatus
+from landlab import HexModelGrid
+from landlab import LinkStatus
 from landlab.core.utils import as_id_array
 
 from ..cfuncs import get_next_event_new  # , update_link_state_new
 
 _DEFAULT_NUM_ROWS = 5
 _DEFAULT_NUM_COLS = 5
 _TAN60 = 1.732
```

### Comparing `landlab-2.7.0/landlab/ca/celllab_cts.py` & `landlab-2.8.0/landlab/ca/celllab_cts.py`

 * *Files 0% similar despite different names*

```diff
@@ -119,31 +119,28 @@
 """
 
 
 import numpy as np
 import pylab as plt
 
 import landlab
-from landlab.ca.cfuncs import (
-    PriorityQueue,
-    get_next_event_new,
-    push_transitions_to_event_queue,
-    run_cts_new,
-)
+from landlab.ca.cfuncs import PriorityQueue
+from landlab.ca.cfuncs import get_next_event_new
+from landlab.ca.cfuncs import push_transitions_to_event_queue
+from landlab.ca.cfuncs import run_cts_new
 from landlab.grid.nodestatus import NodeStatus
 
 _NEVER = 1e50
 
 _DEBUG = False
 
 _CORE = NodeStatus.CORE
 
 
 class Transition:
-
     """A transition from one state to another.
 
     Represents a transition from one state ("from_state") to another
     ("to_state") at a link. The transition probability is represented by a rate
     parameter "rate", with dimensions of 1/T. The probability distribution of
     time until the transition event occurs is exponentional with mean 1/rate.
     The optional name parameter allows the caller to assign a name to any given
@@ -202,15 +199,14 @@
         self.rate = rate
         self.name = name
         self.swap_properties = swap_properties
         self.prop_update_fn = prop_update_fn
 
 
 class CAPlotter:
-
     """Handle display of a CellLab-CTS grid.
 
     CAPlotter() constructor keeps a reference to the CA model, and
     optionally a colormap to be used with plots.
 
     Parameters
     ----------
@@ -298,15 +294,14 @@
         the plot.
         """
         plt.ioff()
         plt.show()
 
 
 class CellLabCTSModel:
-
     """Link-type (or doublet-type) cellular automaton model.
 
     A CellLabCTSModel implements a link-type (or doublet-type) cellular
     automaton model. A link connects a pair of cells. Each cell has a state
     (represented by an integer code), and each link also has a state that is
     determined by the states of the cell pair.
```

### Comparing `landlab-2.7.0/landlab/ca/cfuncs.pyx` & `landlab-2.8.0/landlab/ca/cfuncs.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -5,23 +5,20 @@
 """
 
 import numpy as np
 
 cimport cython
 cimport numpy as np
 
+import sys  # for debug
+
 from _heapq import heappop, heappush
 
 from landlab.grid.nodestatus import NodeStatus
 
-from libc.math cimport log
-from libc.stdlib cimport rand
-
-import sys  # for debug
-
 
 cdef double _NEVER = 1.0e50
 
 cdef int _CORE = NodeStatus.CORE
 
 DTYPE = np.double
 ctypedef np.double_t DTYPE_t
@@ -50,15 +47,15 @@
         self._index = 0
 
     def push(self, int item, double priority):
         heappush(self._queue, (priority, self._index, item))
         self._index += 1
 
     def pop(self):
-        assert len(self._queue) > 0, 'Q is empty'
+        assert len(self._queue) > 0, "Q is empty"
         return heappop(self._queue)
 
 
 cdef class Event:
     """
     Represents a transition event at a link. The transition occurs at a given
     link and a given time, and it involves a transition into the state xn_to
@@ -130,21 +127,23 @@
         has an earlier scheduled time than the event on the right
         """
         return self.time < other.time
 
 
 @cython.boundscheck(True)
 @cython.wraparound(False)
-cdef int current_link_state(DTYPE_INT_t link_id,
-                       np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                       np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
-                       np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
-                       np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
-                       DTYPE_INT_t num_node_states,
-                       DTYPE_INT_t num_node_states_sq):
+cdef int current_link_state(
+    DTYPE_INT_t link_id,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
+    np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
+    DTYPE_INT_t num_node_states,
+    DTYPE_INT_t num_node_states_sq,
+):
     """Get the current state of a link.
 
     Used to determine whether the link state at link *link_id* has changed
     due to an independent change in the node-state grid. Returns the
     current state of the link based on the states of its two end nodes;
     this can be compared to the entry in self.link_state to determine
     whether the state has changed.
@@ -183,148 +182,187 @@
     return (orientation * num_node_states_sq +
             tail_node_state * num_node_states + head_node_state)
 
 
 @cython.boundscheck(True)
 @cython.wraparound(False)
 cpdef update_link_states_and_transitions(
-                             np.ndarray[DTYPE_INT_t, ndim=1] active_links,
-                             np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                             np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
-                             np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
-                             np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
-                             np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
-                             np.ndarray[DTYPE_INT_t, ndim=1] link_state,
-                             np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
-                             event_queue,
-                             np.ndarray[DTYPE_t, ndim=1] next_update,
-                             np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
-                             np.ndarray[DTYPE_t, ndim=2] xn_rate,
-                             DTYPE_INT_t num_node_states,
-                             DTYPE_INT_t num_node_states_sq,
-                             DTYPE_t current_time,
-                             np.ndarray[DTYPE_INT8_t, ndim=2] xn_propswap,
-                             xn_prop_update_fn):
-        """
-        Following an "external" change to the node state grid, updates link
-        states where necessary and creates any needed events.
+    np.ndarray[DTYPE_INT_t, ndim=1] active_links,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
+    np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
+    np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
+    event_queue,
+    np.ndarray[DTYPE_t, ndim=1] next_update,
+    np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
+    np.ndarray[DTYPE_t, ndim=2] xn_rate,
+    DTYPE_INT_t num_node_states,
+    DTYPE_INT_t num_node_states_sq,
+    DTYPE_t current_time,
+    np.ndarray[DTYPE_INT8_t, ndim=2] xn_propswap,
+    xn_prop_update_fn,
+):
+    """
+    Following an "external" change to the node state grid, updates link
+    states where necessary and creates any needed events.
 
-        Notes
-        -----
-        **Algorithm**::
-
-            FOR each active link:
-                if the actual node pair is different from the link's code:
-                    change the link state to be correct
-                    schedule an event
-        """
-        cdef int current_state
-        cdef int i, j
+    Notes
+    -----
+    **Algorithm**::
 
-        for j in range(len(active_links)):
-            i = active_links[j]
-            current_state = current_link_state(i, node_state,
-                                               node_at_link_tail,
-                                               node_at_link_head,
-                                               link_orientation,
-                                               num_node_states,
-                                               num_node_states_sq)
-            if current_state != link_state[i]:
-                update_link_state(i, current_state, current_time, bnd_lnk,
-                                  node_state, node_at_link_tail,
-                                  node_at_link_head, link_orientation,
-                                  num_node_states, num_node_states_sq,
-                                  link_state, n_xn, event_queue, next_update,
-                                  xn_to, xn_rate,xn_propswap,
-                                  xn_prop_update_fn)
+        FOR each active link:
+            if the actual node pair is different from the link's code:
+                change the link state to be correct
+                schedule an event
+    """
+    cdef int current_state
+    cdef int i, j
+
+    for j in range(len(active_links)):
+        i = active_links[j]
+        current_state = current_link_state(
+            i,
+            node_state,
+            node_at_link_tail,
+            node_at_link_head,
+            link_orientation,
+            num_node_states,
+            num_node_states_sq,
+        )
+        if current_state != link_state[i]:
+            update_link_state(
+                i,
+                current_state,
+                current_time,
+                bnd_lnk,
+                node_state,
+                node_at_link_tail,
+                node_at_link_head,
+                link_orientation,
+                num_node_states,
+                num_node_states_sq,
+                link_state,
+                n_xn,
+                event_queue,
+                next_update,
+                xn_to,
+                xn_rate,
+                xn_propswap,
+                xn_prop_update_fn,
+            )
 
 
 @cython.boundscheck(True)
 @cython.wraparound(False)
 cpdef update_link_states_and_transitions_new(
-                             np.ndarray[DTYPE_INT_t, ndim=1] active_links,
-                             np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                             np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
-                             np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
-                             np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
-                             np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
-                             np.ndarray[DTYPE_INT_t, ndim=1] link_state,
-                             np.ndarray[DTYPE_INT_t, ndim=1] n_trn,
-                             priority_queue,
-                             np.ndarray[DTYPE_t, ndim=1] next_update,
-                             np.ndarray[DTYPE_INT_t, ndim=1] next_trn_id,
-                             np.ndarray[DTYPE_INT_t, ndim=2] trn_id,
-                             np.ndarray[DTYPE_t, ndim=1] trn_rate,
-                             DTYPE_INT_t num_node_states,
-                             DTYPE_INT_t num_node_states_sq,
-                             DTYPE_t current_time):
-        """
-        Following an "external" change to the node state grid, updates link
-        states where necessary and creates any needed events.
+    np.ndarray[DTYPE_INT_t, ndim=1] active_links,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
+    np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
+    np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_trn,
+    priority_queue,
+    np.ndarray[DTYPE_t, ndim=1] next_update,
+    np.ndarray[DTYPE_INT_t, ndim=1] next_trn_id,
+    np.ndarray[DTYPE_INT_t, ndim=2] trn_id,
+    np.ndarray[DTYPE_t, ndim=1] trn_rate,
+    DTYPE_INT_t num_node_states,
+    DTYPE_INT_t num_node_states_sq,
+    DTYPE_t current_time,
+):
+    """
+    Following an "external" change to the node state grid, updates link
+    states where necessary and creates any needed events.
 
-        Notes
-        -----
-        **Algorithm**::
-
-            FOR each active link:
-                if the actual node pair is different from the link's code:
-                    change the link state to be correct
-                    schedule an event
-        """
-        cdef int current_state
-        cdef int i, j
+    Notes
+    -----
+    **Algorithm**::
 
-        for j in range(len(active_links)):
-            i = active_links[j]
-            current_state = current_link_state(i, node_state,
-                                               node_at_link_tail,
-                                               node_at_link_head,
-                                               link_orientation,
-                                               num_node_states,
-                                               num_node_states_sq)
-            if current_state != link_state[i]:
-                update_link_state_new(i, current_state, current_time, bnd_lnk,
-                                  node_state, node_at_link_tail,
-                                  node_at_link_head, link_orientation,
-                                  num_node_states, num_node_states_sq,
-                                  link_state, n_trn, priority_queue, next_update,
-                                  next_trn_id, trn_id, trn_rate)
+        FOR each active link:
+            if the actual node pair is different from the link's code:
+                change the link state to be correct
+                schedule an event
+    """
+    cdef int current_state
+    cdef int i, j
+
+    for j in range(len(active_links)):
+        i = active_links[j]
+        current_state = current_link_state(
+            i,
+            node_state,
+            node_at_link_tail,
+            node_at_link_head,
+            link_orientation,
+            num_node_states,
+            num_node_states_sq,
+        )
+        if current_state != link_state[i]:
+            update_link_state_new(
+                i,
+                current_state,
+                current_time,
+                bnd_lnk,
+                node_state,
+                node_at_link_tail,
+                node_at_link_head,
+                link_orientation,
+                num_node_states,
+                num_node_states_sq,
+                link_state,
+                n_trn,
+                priority_queue,
+                next_update,
+                next_trn_id,
+                trn_id,
+                trn_rate,
+            )
 
 
 @cython.boundscheck(True)
 @cython.wraparound(False)
 @cython.cdivision(True)
-cpdef update_node_states(np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                       np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
-                       DTYPE_INT_t tail_node,
-                       DTYPE_INT_t head_node,
-                       DTYPE_INT_t new_link_state,
-                       DTYPE_INT_t num_states):
+cpdef update_node_states(
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
+    DTYPE_INT_t tail_node,
+    DTYPE_INT_t head_node,
+    DTYPE_INT_t new_link_state,
+    DTYPE_INT_t num_states,
+):
     """Update the states of 2 nodes that underwent a transition."""
     if _DEBUG:
-        print(('UNS', tail_node, head_node, new_link_state, num_states))
+        print(("UNS", tail_node, head_node, new_link_state, num_states))
     # Change to the new states
     if status_at_node[tail_node] == _CORE:
-        node_state[tail_node] = (new_link_state / num_states) % num_states # assume integer division!!
+        # assume integer division!!
+        node_state[tail_node] = (new_link_state / num_states) % num_states
     if status_at_node[head_node] == _CORE:
         node_state[head_node] = new_link_state % num_states
     if _DEBUG:
-        print(('UNS new tail state: ', node_state[tail_node]))
-        print(('UNS new head state: ', node_state[head_node]))
+        print(("UNS new tail state: ", node_state[tail_node]))
+        print(("UNS new head state: ", node_state[head_node]))
 
 
 @cython.boundscheck(True)
 @cython.wraparound(False)
-cpdef get_next_event(DTYPE_INT_t link, DTYPE_INT_t current_state,
-                   DTYPE_t current_time,
-                   np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
-                   np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
-                   np.ndarray[DTYPE_t, ndim=2] xn_rate,
-                   np.ndarray[DTYPE_INT8_t, ndim=2] xn_propswap,
-                   xn_prop_update_fn):
+cpdef get_next_event(
+    DTYPE_INT_t link, DTYPE_INT_t current_state,
+    DTYPE_t current_time,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
+    np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
+    np.ndarray[DTYPE_t, ndim=2] xn_rate,
+    np.ndarray[DTYPE_INT8_t, ndim=2] xn_propswap,
+    xn_prop_update_fn,
+):
     """Get the next event for a link.
 
     Returns the next event for link with ID "link", which is in state
     "current state".
 
     Parameters
     ----------
@@ -361,43 +399,44 @@
     cdef Event my_event
 
     # Find next event time for each potential transition
     if n_xn[current_state] == 1:
         my_xn_to = xn_to[current_state, 0]
         propswap = xn_propswap[current_state, 0]
         next_time = np.random.exponential(1.0 / xn_rate[current_state, 0])
-        #next_time = -(1.0 / xn_rate[current_state, 0]) * log(1.0 - rand())
+        # next_time = -(1.0 / xn_rate[current_state, 0]) * log(1.0 - rand())
         prop_update_fn = xn_prop_update_fn[current_state, 0]
     else:
         next_time = _NEVER
         my_xn_to = 0
         propswap = 0
         for i in range(n_xn[current_state]):
             this_next = np.random.exponential(1.0 / xn_rate[current_state, i])
-            #this_next = -(1.0 / xn_rate[current_state, i]) * log(1.0 - rand())
+            # this_next = -(1.0 / xn_rate[current_state, i]) * log(1.0 - rand())
             if this_next < next_time:
                 next_time = this_next
                 my_xn_to = xn_to[current_state, i]
                 propswap = xn_propswap[current_state, i]
                 prop_update_fn = xn_prop_update_fn[current_state, i]
 
     # Create and setup event, and return it
-    my_event = Event(next_time + current_time, link,
-                     my_xn_to, propswap, prop_update_fn)
+    my_event = Event(next_time + current_time, link, my_xn_to, propswap, prop_update_fn)
 
     return my_event
 
 
 @cython.boundscheck(True)
 @cython.wraparound(False)
-cpdef get_next_event_new(DTYPE_INT_t link, DTYPE_INT_t current_state,
-                   DTYPE_t current_time,
-                   np.ndarray[DTYPE_INT_t, ndim=1] n_trn,
-                   np.ndarray[DTYPE_INT_t, ndim=2] trn_id,
-                   np.ndarray[DTYPE_t, ndim=1] trn_rate):
+cpdef get_next_event_new(
+    DTYPE_INT_t link, DTYPE_INT_t current_state,
+    DTYPE_t current_time,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_trn,
+    np.ndarray[DTYPE_INT_t, ndim=2] trn_id,
+    np.ndarray[DTYPE_t, ndim=1] trn_rate,
+):
     """Get the next event for a link.
 
     Returns the next event for link with ID "link", which is in state
     "current state".
 
     Parameters
     ----------
@@ -425,15 +464,14 @@
     chosen for each, and the smallest of these applied.
 
     Assumes that there is at least one potential transition from the
     current state.
     """
     cdef int this_trn_id
     cdef int i
-    cdef char propswap
     cdef double next_time, this_next
 
     # Find next event time for each potential transition
     if n_trn[current_state] == 1:
         this_trn_id = trn_id[current_state, 0]
         next_time = np.random.exponential(1.0 / trn_rate[this_trn_id])
     else:
@@ -444,61 +482,66 @@
             if this_next < next_time:
                 next_time = this_next
                 this_trn_id = trn_id[current_state, i]
 
     return (next_time + current_time, this_trn_id)
 
 
-cpdef push_transitions_to_event_queue(int number_of_active_links,
-                                      np.ndarray[DTYPE_INT_t, ndim=1] active_links,
-                                      np.ndarray[DTYPE_INT_t, ndim=1] n_trn,
-                                      np.ndarray[DTYPE_INT_t, ndim=1] link_state,
-                                      np.ndarray[DTYPE_INT_t, ndim=2] trn_id,
-                                      np.ndarray[DTYPE_t, ndim=1] trn_rate,
-                                      np.ndarray[DTYPE_t, ndim=1] next_update,
-                                      np.ndarray[DTYPE_INT_t, ndim=1] next_trn_id,
-                                      PriorityQueue priority_queue):
+cpdef push_transitions_to_event_queue(
+    int number_of_active_links,
+    np.ndarray[DTYPE_INT_t, ndim=1] active_links,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_trn,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_state,
+    np.ndarray[DTYPE_INT_t, ndim=2] trn_id,
+    np.ndarray[DTYPE_t, ndim=1] trn_rate,
+    np.ndarray[DTYPE_t, ndim=1] next_update,
+    np.ndarray[DTYPE_INT_t, ndim=1] next_trn_id,
+    PriorityQueue priority_queue,
+):
     """
     Initializes the event queue by creating transition events for each
     cell pair that has one or more potential transitions and pushing these
     onto the queue. Also records scheduled transition times in the
     self.next_update array.
     """
     for j in range(number_of_active_links):
 
         i = active_links[j]
         if n_trn[link_state[i]] > 0:
-            (ev_time, this_trn_id) = get_next_event_new(i, link_state[i], 0.0,
-                                                        n_trn, trn_id,
-                                                        trn_rate)
+            (ev_time, this_trn_id) = get_next_event_new(
+                i, link_state[i], 0.0, n_trn, trn_id, trn_rate
+            )
             priority_queue.push(i, ev_time)
             next_update[i] = ev_time
             next_trn_id[i] = this_trn_id
 
         else:
             next_update[i] = _NEVER
 
+
 @cython.boundscheck(True)
 @cython.wraparound(False)
-cdef void update_link_state(DTYPE_INT_t link, DTYPE_INT_t new_link_state,
-                      DTYPE_t current_time,
-                      np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
-                      np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                      np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
-                      np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
-                      np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
-                      DTYPE_INT_t num_node_states,
-                      DTYPE_INT_t num_node_states_sq,
-                      np.ndarray[DTYPE_INT_t, ndim=1] link_state,
-                      np.ndarray[DTYPE_INT_t, ndim=1] n_xn, event_queue,
-                      np.ndarray[DTYPE_t, ndim=1] next_update,
-                      np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
-                      np.ndarray[DTYPE_t, ndim=2] xn_rate,
-                      np.ndarray[DTYPE_INT8_t, ndim=2] xn_propswap,
-                      np.ndarray[object, ndim=2] xn_prop_update_fn):
+cdef void update_link_state(
+    DTYPE_INT_t link, DTYPE_INT_t new_link_state,
+    DTYPE_t current_time,
+    np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
+    np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
+    DTYPE_INT_t num_node_states,
+    DTYPE_INT_t num_node_states_sq,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_xn, event_queue,
+    np.ndarray[DTYPE_t, ndim=1] next_update,
+    np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
+    np.ndarray[DTYPE_t, ndim=2] xn_rate,
+    np.ndarray[DTYPE_INT8_t, ndim=2] xn_propswap,
+    np.ndarray[object, ndim=2] xn_prop_update_fn,
+):
     """
     Implements a link transition by updating the current state of the link
     and (if appropriate) choosing the next transition event and pushing it
     on to the event queue.
 
     Parameters
     ----------
@@ -521,40 +564,50 @@
         tns = node_state[node_at_link_head[link]]
         orientation = link_orientation[link]
         new_link_state = orientation * num_node_states_sq + \
             fns * num_node_states + tns
 
     link_state[link] = new_link_state
     if n_xn[new_link_state] > 0:
-        event = get_next_event(link, new_link_state, current_time, n_xn, xn_to,
-                               xn_rate, xn_propswap, xn_prop_update_fn)
+        event = get_next_event(
+            link,
+            new_link_state,
+            current_time,
+            n_xn,
+            xn_to,
+            xn_rate,
+            xn_propswap,
+            xn_prop_update_fn,
+        )
         heappush(event_queue, event)
         next_update[link] = event.time
     else:
         next_update[link] = _NEVER
 
 
 @cython.boundscheck(True)
 @cython.wraparound(False)
-cdef void update_link_state_new(DTYPE_INT_t link, DTYPE_INT_t new_link_state,
-                      DTYPE_t current_time,
-                      np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
-                      np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                      np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
-                      np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
-                      np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
-                      DTYPE_INT_t num_node_states,
-                      DTYPE_INT_t num_node_states_sq,
-                      np.ndarray[DTYPE_INT_t, ndim=1] link_state,
-                      np.ndarray[DTYPE_INT_t, ndim=1] n_trn,
-                      PriorityQueue priority_queue,
-                      np.ndarray[DTYPE_t, ndim=1] next_update,
-                      np.ndarray[DTYPE_INT_t, ndim=1] next_trn_id,
-                      np.ndarray[DTYPE_INT_t, ndim=2] trn_id,
-                      np.ndarray[DTYPE_t, ndim=1] trn_rate):
+cdef void update_link_state_new(
+    DTYPE_INT_t link, DTYPE_INT_t new_link_state,
+    DTYPE_t current_time,
+    np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
+    np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
+    DTYPE_INT_t num_node_states,
+    DTYPE_INT_t num_node_states_sq,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_trn,
+    PriorityQueue priority_queue,
+    np.ndarray[DTYPE_t, ndim=1] next_update,
+    np.ndarray[DTYPE_INT_t, ndim=1] next_trn_id,
+    np.ndarray[DTYPE_INT_t, ndim=2] trn_id,
+    np.ndarray[DTYPE_t, ndim=1] trn_rate,
+):
     """
     Implements a link transition by updating the current state of the link
     and (if appropriate) choosing the next transition event and pushing it
     on to the event queue.
 
     Parameters
     ----------
@@ -567,66 +620,69 @@
     (see celllab_cts.py for other parameters)
     """
     cdef int fns, tns
     cdef int this_trn_id
     cdef int orientation
 
     if _DEBUG:
-        print(('ULSN', link, link_state[link], new_link_state, current_time))
+        print(("ULSN", link, link_state[link], new_link_state, current_time))
 
     # If the link connects to a boundary, we might have a different state
     # than the one we planned
     if bnd_lnk[link]:
         fns = node_state[node_at_link_tail[link]]
         tns = node_state[node_at_link_head[link]]
         orientation = link_orientation[link]
         new_link_state = orientation * num_node_states_sq + \
             fns * num_node_states + tns
         if _DEBUG:
-            print((' bnd True', new_link_state))
+            print((" bnd True", new_link_state))
 
     link_state[link] = new_link_state
     if n_trn[new_link_state] > 0:
-        (event_time, this_trn_id) = get_next_event_new(link, new_link_state,
-                                                       current_time,
-                                                       n_trn, trn_id, trn_rate)
+        (event_time, this_trn_id) = get_next_event_new(
+            link, new_link_state, current_time, n_trn, trn_id, trn_rate
+        )
         priority_queue.push(link, event_time)
         next_update[link] = event_time
         next_trn_id[link] = this_trn_id
     else:
         next_update[link] = _NEVER
         next_trn_id[link] = -1
 
+
 @cython.boundscheck(True)
 @cython.wraparound(False)
-cdef void do_transition(Event event,
-                  np.ndarray[DTYPE_t, ndim=1] next_update,
-                  np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
-                  np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
-                  np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                  np.ndarray[DTYPE_INT_t, ndim=1] link_state,
-                  np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
-                  np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
-                  np.ndarray[DTYPE_INT_t, ndim=1] propid,
-                  object prop_data,
-                  np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
-                  np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
-                  np.ndarray[DTYPE_t, ndim=2] xn_rate,
-                  np.ndarray[DTYPE_INT_t, ndim=2] links_at_node,
-                  np.ndarray[DTYPE_INT8_t, ndim=2] active_link_dirs_at_node,
-                  DTYPE_INT_t num_node_states,
-                  DTYPE_INT_t num_node_states_sq,
-                  DTYPE_INT_t prop_reset_value,
-                  np.ndarray[DTYPE_INT8_t, ndim=2] xn_propswap,
-                  xn_prop_update_fn,
-                  np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
-                  event_queue,
-                  this_cts_model,
-                  plot_each_transition=False,
-                  plotter=None):
+cdef void do_transition(
+    Event event,
+    np.ndarray[DTYPE_t, ndim=1] next_update,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_state,
+    np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
+    np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
+    np.ndarray[DTYPE_INT_t, ndim=1] propid,
+    object prop_data,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
+    np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
+    np.ndarray[DTYPE_t, ndim=2] xn_rate,
+    np.ndarray[DTYPE_INT_t, ndim=2] links_at_node,
+    np.ndarray[DTYPE_INT8_t, ndim=2] active_link_dirs_at_node,
+    DTYPE_INT_t num_node_states,
+    DTYPE_INT_t num_node_states_sq,
+    DTYPE_INT_t prop_reset_value,
+    np.ndarray[DTYPE_INT8_t, ndim=2] xn_propswap,
+    xn_prop_update_fn,
+    np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
+    event_queue,
+    this_cts_model,
+    plot_each_transition=False,
+    plotter=None,
+):
     """Transition state.
 
     Implements a state transition.
 
     Parameters
     ----------
     event : Event object
@@ -656,15 +712,14 @@
     cdef int old_tail_node_state
     cdef int old_head_node_state
     cdef int this_link_tail_node   # Tail ID for an adjacent link
     cdef int this_link_head_node   # Head ID for an adjacent link
     cdef int link                  # ID of a link
     cdef int new_link_state        # New link state after transition
     cdef int tmp                   # Used to exchange property IDs
-    cdef char tail_changed, head_changed,  # Booleans
     cdef char dir_code             # Direction code for link at node
     cdef char orientation          # Orientation code for link
     cdef int i
 
     # We'll process the event if its update time matches the one we have
     # recorded for the link in question. If not, it means that the link has
     # changed state since the event was pushed onto the event queue, and
@@ -675,25 +730,42 @@
         head_node = node_at_link_head[event.link]
 
         # Remember the previous state of each node so we can detect whether the
         # state has changed
         old_tail_node_state = node_state[tail_node]
         old_head_node_state = node_state[head_node]
 
-        update_node_states(node_state, status_at_node, tail_node,
-                           head_node, event.xn_to, num_node_states)
-        update_link_state(event.link, event.xn_to, event.time,
-                          bnd_lnk, node_state,
-                          node_at_link_tail,
-                          node_at_link_head,
-                          link_orientation, num_node_states,
-                          num_node_states_sq, link_state,
-                          n_xn, event_queue,
-                          next_update, xn_to, xn_rate,
-                          xn_propswap, xn_prop_update_fn)
+        update_node_states(
+            node_state,
+            status_at_node,
+            tail_node,
+            head_node,
+            event.xn_to,
+            num_node_states,
+        )
+        update_link_state(
+            event.link,
+            event.xn_to,
+            event.time,
+            bnd_lnk,
+            node_state,
+            node_at_link_tail,
+            node_at_link_head,
+            link_orientation,
+            num_node_states,
+            num_node_states_sq,
+            link_state,
+            n_xn,
+            event_queue,
+            next_update,
+            xn_to,
+            xn_rate,
+            xn_propswap,
+            xn_prop_update_fn,
+        )
 
         # Next, when the state of one of the link's nodes changes, we have
         # to update the states of the OTHER links attached to it. This
         # could happen to one or both nodes.
         if node_state[tail_node] != old_tail_node_state:
 
             for i in range(links_at_node.shape[1]):
@@ -705,24 +777,36 @@
 
                     this_link_tail_node = node_at_link_tail[link]
                     this_link_head_node = node_at_link_head[link]
                     orientation = link_orientation[link]
                     new_link_state = (
                         orientation * num_node_states_sq +
                         node_state[this_link_tail_node] * num_node_states +
-                        node_state[this_link_head_node])
-                    update_link_state(link, new_link_state, event.time,
-                                      bnd_lnk, node_state,
-                                      node_at_link_tail,
-                                      node_at_link_head,
-                                      link_orientation, num_node_states,
-                                      num_node_states_sq, link_state,
-                                      n_xn, event_queue,
-                                      next_update, xn_to, xn_rate,
-                                      xn_propswap, xn_prop_update_fn)
+                        node_state[this_link_head_node]
+                    )
+                    update_link_state(
+                        link,
+                        new_link_state,
+                        event.time,
+                        bnd_lnk,
+                        node_state,
+                        node_at_link_tail,
+                        node_at_link_head,
+                        link_orientation,
+                        num_node_states,
+                        num_node_states_sq,
+                        link_state,
+                        n_xn,
+                        event_queue,
+                        next_update,
+                        xn_to,
+                        xn_rate,
+                        xn_propswap,
+                        xn_prop_update_fn,
+                    )
 
         if node_state[head_node] != old_head_node_state:
 
             for i in range(links_at_node.shape[1]):
 
                 link = links_at_node[head_node, i]
                 dir_code = active_link_dirs_at_node[head_node, i]
@@ -730,24 +814,36 @@
                 if dir_code != 0 and link != event.link:
                     this_link_tail_node = node_at_link_tail[link]
                     this_link_head_node = node_at_link_head[link]
                     orientation = link_orientation[link]
                     new_link_state = (
                         orientation * num_node_states_sq +
                         node_state[this_link_tail_node] * num_node_states +
-                        node_state[this_link_head_node])
-                    update_link_state(link, new_link_state, event.time,
-                                      bnd_lnk, node_state,
-                                      node_at_link_tail,
-                                      node_at_link_head,
-                                      link_orientation, num_node_states,
-                                      num_node_states_sq, link_state,
-                                      n_xn, event_queue,
-                                      next_update, xn_to, xn_rate,
-                                      xn_propswap, xn_prop_update_fn)
+                        node_state[this_link_head_node]
+                    )
+                    update_link_state(
+                        link,
+                        new_link_state,
+                        event.time,
+                        bnd_lnk,
+                        node_state,
+                        node_at_link_tail,
+                        node_at_link_head,
+                        link_orientation,
+                        num_node_states,
+                        num_node_states_sq,
+                        link_state,
+                        n_xn,
+                        event_queue,
+                        next_update,
+                        xn_to,
+                        xn_rate,
+                        xn_propswap,
+                        xn_prop_update_fn,
+                    )
 
         # If requested, display a plot of the grid
         if plot_each_transition and (plotter is not None):
             plotter.update_plot()
 
         # If this event involves an exchange of properties (i.e., the
         # event involves motion of an object that posses properties we
@@ -759,47 +855,49 @@
             propid[tail_node] = propid[head_node]
             propid[head_node] = tmp
             if status_at_node[tail_node] != _CORE:
                 prop_data[propid[tail_node]] = prop_reset_value
             if status_at_node[head_node] != _CORE:
                 prop_data[propid[head_node]] = prop_reset_value
             if event.prop_update_fn is not None:
-                event.prop_update_fn(
-                    this_cts_model, tail_node, head_node, event.time)
+                event.prop_update_fn(this_cts_model, tail_node, head_node, event.time)
 
-#@cython.boundscheck(False)
-#@cython.wraparound(False)
-cpdef void do_transition_new(DTYPE_INT_t event_link,
-                  DTYPE_t event_time,
-                  PriorityQueue priority_queue,
-                  np.ndarray[DTYPE_t, ndim=1] next_update,
-                  np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
-                  np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
-                  np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                  np.ndarray[DTYPE_INT_t, ndim=1] next_trn_id,
-                  np.ndarray[DTYPE_INT_t, ndim=1] trn_to,
-                  np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
-                  DTYPE_INT_t num_node_states,
-                  DTYPE_INT_t num_node_states_sq,
-                  np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
-                  np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
-                  np.ndarray[DTYPE_INT_t, ndim=1] link_state,
-                  np.ndarray[DTYPE_INT_t, ndim=1] n_trn,
-                  np.ndarray[DTYPE_INT_t, ndim=2] trn_id,
-                  np.ndarray[DTYPE_t, ndim=1] trn_rate,
-                  np.ndarray[DTYPE_INT_t, ndim=2] links_at_node,
-                  np.ndarray[DTYPE_INT8_t, ndim=2] active_link_dirs_at_node,
-                  np.ndarray[DTYPE_INT8_t, ndim=1] trn_propswap,
-                  np.ndarray[DTYPE_INT_t, ndim=1] propid,
-                  object prop_data,
-                  DTYPE_INT_t prop_reset_value,
-                  object trn_prop_update_fn,
-                  object this_cts_model,
-                  plot_each_transition=False,
-                  plotter=None):
+
+# @cython.boundscheck(False)
+# @cython.wraparound(False)
+cpdef void do_transition_new(
+    DTYPE_INT_t event_link,
+    DTYPE_t event_time,
+    PriorityQueue priority_queue,
+    np.ndarray[DTYPE_t, ndim=1] next_update,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] next_trn_id,
+    np.ndarray[DTYPE_INT_t, ndim=1] trn_to,
+    np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
+    DTYPE_INT_t num_node_states,
+    DTYPE_INT_t num_node_states_sq,
+    np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
+    np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_trn,
+    np.ndarray[DTYPE_INT_t, ndim=2] trn_id,
+    np.ndarray[DTYPE_t, ndim=1] trn_rate,
+    np.ndarray[DTYPE_INT_t, ndim=2] links_at_node,
+    np.ndarray[DTYPE_INT8_t, ndim=2] active_link_dirs_at_node,
+    np.ndarray[DTYPE_INT8_t, ndim=1] trn_propswap,
+    np.ndarray[DTYPE_INT_t, ndim=1] propid,
+    object prop_data,
+    DTYPE_INT_t prop_reset_value,
+    object trn_prop_update_fn,
+    object this_cts_model,
+    plot_each_transition=False,
+    plotter=None,
+):
     """Transition state.
 
     Implements a state transition.
 
     Parameters
     ----------
     event : Event object
@@ -821,72 +919,105 @@
 
     1. Update the states of the two nodes attached to the link
     2. Update the link's state, choose its next transition, and push
        it on the event queue.
     3. Update the states of the other links attached to the two nodes,
        choose their next transitions, and push them on the event queue.
     """
-    cdef int index
     cdef int tail_node, head_node  # IDs of tail and head nodes at link
     cdef int old_tail_node_state
     cdef int old_head_node_state
     cdef int this_trn_id
     cdef int this_trn_to
     cdef int this_link_tail_node   # Tail ID for an adjacent link
     cdef int this_link_head_node   # Head ID for an adjacent link
     cdef int link                  # ID of a link
     cdef int new_link_state        # New link state after transition
     cdef int tmp                   # Used to exchange property IDs
-    cdef char tail_changed, head_changed,  # Booleans
     cdef char dir_code             # Direction code for link at node
     cdef char orientation          # Orientation code for link
     cdef int i
 
     if _DEBUG:
-        print(('DTN', event_time, event_link, link_state[event_link], next_update[event_link]))
+        print(
+            (
+                "DTN",
+                event_time,
+                event_link,
+                link_state[event_link],
+                next_update[event_link],
+            )
+        )
 
     # We'll process the event if its update time matches the one we have
     # recorded for the link in question. If not, it means that the link has
     # changed state since the event was pushed onto the event queue, and
     # in that case we'll ignore it.
     if event_time == next_update[event_link]:
 
         tail_node = node_at_link_tail[event_link]
         head_node = node_at_link_head[event_link]
 
         # DEBUG
         if status_at_node[tail_node] == 4 or status_at_node[head_node] == 4:
-            print(('TRN INFO: ', event_time, event_link, link_state[event_link], next_update[event_link]))
-            print('TAIL ' + str(tail_node) + ' ' + status_at_node[tail_node])
-            print('HEAD ' + str(head_node) + ' ' + status_at_node[tail_node])
-            #_DEBUG = True
+            print(
+                (
+                    "TRN INFO: ",
+                    event_time,
+                    event_link,
+                    link_state[event_link],
+                    next_update[event_link],
+                )
+            )
+            print("TAIL " + str(tail_node) + " " + status_at_node[tail_node])
+            print("HEAD " + str(head_node) + " " + status_at_node[tail_node])
+            # _DEBUG = True
 
         # Remember the previous state of each node so we can detect whether the
         # state has changed
         old_tail_node_state = node_state[tail_node]
         old_head_node_state = node_state[head_node]
 
         this_trn_id = next_trn_id[event_link]
         this_trn_to = trn_to[this_trn_id]
 
         if _DEBUG:
             print((this_trn_id, this_trn_to))
-            print(('tail:', tail_node))
-            print(('tail state:', old_tail_node_state))
-            print(('head:', head_node))
-            print(('head state:', old_head_node_state))
-
-        update_node_states(node_state, status_at_node, tail_node,
-                           head_node, this_trn_to, num_node_states)
-        update_link_state_new(event_link, this_trn_to, event_time, bnd_lnk,
-                              node_state, node_at_link_tail,
-                              node_at_link_head, link_orientation,
-                              num_node_states, num_node_states_sq,
-                              link_state, n_trn, priority_queue, next_update,
-                              next_trn_id, trn_id, trn_rate)
+            print(("tail:", tail_node))
+            print(("tail state:", old_tail_node_state))
+            print(("head:", head_node))
+            print(("head state:", old_head_node_state))
+
+        update_node_states(
+            node_state,
+            status_at_node,
+            tail_node,
+            head_node,
+            this_trn_to,
+            num_node_states,
+        )
+        update_link_state_new(
+            event_link,
+            this_trn_to,
+            event_time,
+            bnd_lnk,
+            node_state,
+            node_at_link_tail,
+            node_at_link_head,
+            link_orientation,
+            num_node_states,
+            num_node_states_sq,
+            link_state,
+            n_trn,
+            priority_queue,
+            next_update,
+            next_trn_id,
+            trn_id,
+            trn_rate,
+        )
 
         # Next, when the state of one of the link's nodes changes, we have
         # to update the states of the OTHER links attached to it. This
         # could happen to one or both nodes.
         if node_state[tail_node] != old_tail_node_state:
 
             for i in range(links_at_node.shape[1]):
@@ -898,22 +1029,35 @@
 
                     this_link_tail_node = node_at_link_tail[link]
                     this_link_head_node = node_at_link_head[link]
                     orientation = link_orientation[link]
                     new_link_state = (
                         orientation * num_node_states_sq +
                         node_state[this_link_tail_node] * num_node_states +
-                        node_state[this_link_head_node])
-                    update_link_state_new(link, new_link_state, event_time,
-                                          bnd_lnk,
-                                          node_state, node_at_link_tail,
-                                          node_at_link_head, link_orientation,
-                                          num_node_states, num_node_states_sq,
-                                          link_state, n_trn, priority_queue, next_update,
-                                          next_trn_id, trn_id, trn_rate)
+                        node_state[this_link_head_node]
+                    )
+                    update_link_state_new(
+                        link,
+                        new_link_state,
+                        event_time,
+                        bnd_lnk,
+                        node_state,
+                        node_at_link_tail,
+                        node_at_link_head,
+                        link_orientation,
+                        num_node_states,
+                        num_node_states_sq,
+                        link_state,
+                        n_trn,
+                        priority_queue,
+                        next_update,
+                        next_trn_id,
+                        trn_id,
+                        trn_rate,
+                    )
 
         if node_state[head_node] != old_head_node_state:
 
             for i in range(links_at_node.shape[1]):
 
                 link = links_at_node[head_node, i]
                 dir_code = active_link_dirs_at_node[head_node, i]
@@ -921,22 +1065,35 @@
                 if dir_code != 0 and link != event_link:
                     this_link_tail_node = node_at_link_tail[link]
                     this_link_head_node = node_at_link_head[link]
                     orientation = link_orientation[link]
                     new_link_state = (
                         orientation * num_node_states_sq +
                         node_state[this_link_tail_node] * num_node_states +
-                        node_state[this_link_head_node])
-                    update_link_state_new(link, new_link_state, event_time,
-                                          bnd_lnk,
-                                          node_state, node_at_link_tail,
-                                          node_at_link_head, link_orientation,
-                                          num_node_states, num_node_states_sq,
-                                          link_state, n_trn, priority_queue, next_update,
-                                          next_trn_id, trn_id, trn_rate)
+                        node_state[this_link_head_node]
+                    )
+                    update_link_state_new(
+                        link,
+                        new_link_state,
+                        event_time,
+                        bnd_lnk,
+                        node_state,
+                        node_at_link_tail,
+                        node_at_link_head,
+                        link_orientation,
+                        num_node_states,
+                        num_node_states_sq,
+                        link_state,
+                        n_trn,
+                        priority_queue,
+                        next_update,
+                        next_trn_id,
+                        trn_id,
+                        trn_rate,
+                    )
 
         # If requested, display a plot of the grid
         if plot_each_transition and (plotter is not None):
             plotter.update_plot()
 
         # If this event involves an exchange of properties (i.e., the
         # event involves motion of an object that posses properties we
@@ -951,41 +1108,44 @@
                 prop_data[propid[tail_node]] = prop_reset_value
             if status_at_node[head_node] != _CORE:
                 prop_data[propid[head_node]] = prop_reset_value
             if trn_prop_update_fn[this_trn_id] != 0:
                 trn_prop_update_fn[this_trn_id](
                     this_cts_model, tail_node, head_node, event_time)
 
-cpdef double run_cts_new(double run_to, double current_time,
-                     PriorityQueue priority_queue,
-                     np.ndarray[DTYPE_t, ndim=1] next_update,
-                     np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
-                     np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
-                     np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                     np.ndarray[DTYPE_INT_t, ndim=1] next_trn_id,
-                     np.ndarray[DTYPE_INT_t, ndim=1] trn_to,
-                     np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
-                     DTYPE_INT_t num_node_states,
-                     DTYPE_INT_t num_node_states_sq,
-                     np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
-                     np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
-                     np.ndarray[DTYPE_INT_t, ndim=1] link_state,
-                     np.ndarray[DTYPE_INT_t, ndim=1] n_trn,
-                     np.ndarray[DTYPE_INT_t, ndim=2] trn_id,
-                     np.ndarray[DTYPE_t, ndim=1] trn_rate,
-                     np.ndarray[DTYPE_INT_t, ndim=2] links_at_node,
-                     np.ndarray[DTYPE_INT8_t, ndim=2] active_link_dirs_at_node,
-                     np.ndarray[DTYPE_INT8_t, ndim=1] trn_propswap,
-                     np.ndarray[DTYPE_INT_t, ndim=1] propid,
-                     object prop_data,
-                     DTYPE_INT_t prop_reset_value,
-                     trn_prop_update_fn,
-                     this_cts_model,
-                     char plot_each_transition,
-                     object plotter):
+cpdef double run_cts_new(
+    double run_to,
+    double current_time,
+    PriorityQueue priority_queue,
+    np.ndarray[DTYPE_t, ndim=1] next_update,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] next_trn_id,
+    np.ndarray[DTYPE_INT_t, ndim=1] trn_to,
+    np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
+    DTYPE_INT_t num_node_states,
+    DTYPE_INT_t num_node_states_sq,
+    np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
+    np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_trn,
+    np.ndarray[DTYPE_INT_t, ndim=2] trn_id,
+    np.ndarray[DTYPE_t, ndim=1] trn_rate,
+    np.ndarray[DTYPE_INT_t, ndim=2] links_at_node,
+    np.ndarray[DTYPE_INT8_t, ndim=2] active_link_dirs_at_node,
+    np.ndarray[DTYPE_INT8_t, ndim=1] trn_propswap,
+    np.ndarray[DTYPE_INT_t, ndim=1] propid,
+    object prop_data,
+    DTYPE_INT_t prop_reset_value,
+    trn_prop_update_fn,
+    this_cts_model,
+    char plot_each_transition,
+    object plotter,
+):
     """Run the model forward for a specified period of time.
 
     Parameters
     ----------
     run_to : float
         Time to run to, starting from self.current_time
     node_state_grid : 1D array of ints (x number of nodes) (optional)
@@ -994,91 +1154,99 @@
         Option to display the grid after each transition
     plotter : CAPlotter object (optional)
         Needed if caller wants to plot after every transition
     (see celllab_cts.py for other parameters)
     """
     import sys
     cdef double ev_time
-    cdef int ev_idx
+    cdef int _ev_idx
     cdef int ev_link
 
     # Continue until we've run out of either time or events
     while current_time < run_to and priority_queue._queue:
 
         if _DEBUG:
-            print('current time = ', current_time)
+            print("current time = ", current_time)
 
         # Is there an event scheduled to occur within this run?
         if priority_queue._queue[0][0] <= run_to:
 
             # If so, pick the next transition event from the event queue
-            (ev_time, ev_idx, ev_link) = priority_queue.pop()
+            (ev_time, _ev_idx, ev_link) = priority_queue.pop()
 
             # ... and execute the transition
-            do_transition_new(ev_link, ev_time, priority_queue, next_update,
-                              node_at_link_tail,
-                              node_at_link_head,
-                              node_state,
-                              next_trn_id,
-                              trn_to,
-                              status_at_node,
-                              num_node_states,
-                              num_node_states_sq,
-                              bnd_lnk,
-                              link_orientation,
-                              link_state,
-                              n_trn,
-                              trn_id,
-                              trn_rate,
-                              links_at_node,
-                              active_link_dirs_at_node,
-                              trn_propswap,
-                              propid, prop_data,
-                              prop_reset_value,
-                              trn_prop_update_fn,
-                              this_cts_model,
-                              plot_each_transition,
-                              plotter)
+            do_transition_new(
+                ev_link,
+                ev_time,
+                priority_queue,
+                next_update,
+                node_at_link_tail,
+                node_at_link_head,
+                node_state,
+                next_trn_id,
+                trn_to,
+                status_at_node,
+                num_node_states,
+                num_node_states_sq,
+                bnd_lnk,
+                link_orientation,
+                link_state,
+                n_trn,
+                trn_id,
+                trn_rate,
+                links_at_node,
+                active_link_dirs_at_node,
+                trn_propswap,
+                propid, prop_data,
+                prop_reset_value,
+                trn_prop_update_fn,
+                this_cts_model,
+                plot_each_transition,
+                plotter,
+            )
 
             # Update current time
             current_time = ev_time
 
         # If there is no event scheduled for this span of time, simply
         # advance current_time to the end of the current run period.
         else:
             current_time = run_to
 
     return current_time
 
 
-cpdef double run_cts(double run_to, double current_time,
-                     char plot_each_transition,
-                     object plotter,
-                     object event_queue,
-                     np.ndarray[DTYPE_t, ndim=1] next_update,
-                     np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
-                     np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
-                     np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                     np.ndarray[DTYPE_INT_t, ndim=1] link_state,
-                     np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
-                     np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
-                     np.ndarray[DTYPE_INT_t, ndim=1] propid,
-                     object prop_data,
-                     np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
-                     np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
-                     np.ndarray[DTYPE_t, ndim=2] xn_rate,
-                     np.ndarray[DTYPE_INT_t, ndim=2] links_at_node,
-                     np.ndarray[DTYPE_INT8_t, ndim=2] active_link_dirs_at_node,
-                     DTYPE_INT_t num_node_states,
-                     DTYPE_INT_t num_node_states_sq,
-                     DTYPE_INT_t prop_reset_value,
-                     np.ndarray[DTYPE_INT8_t, ndim=2] xn_propswap,
-                     xn_prop_update_fn,
-                     np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
-                     this_cts_model):
+cpdef double run_cts(
+    double run_to,
+    double current_time,
+    char plot_each_transition,
+    object plotter,
+    object event_queue,
+    np.ndarray[DTYPE_t, ndim=1] next_update,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_state,
+    np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
+    np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
+    np.ndarray[DTYPE_INT_t, ndim=1] propid,
+    object prop_data,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
+    np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
+    np.ndarray[DTYPE_t, ndim=2] xn_rate,
+    np.ndarray[DTYPE_INT_t, ndim=2] links_at_node,
+    np.ndarray[DTYPE_INT8_t, ndim=2] active_link_dirs_at_node,
+    DTYPE_INT_t num_node_states,
+    DTYPE_INT_t num_node_states_sq,
+    DTYPE_INT_t prop_reset_value,
+    np.ndarray[DTYPE_INT8_t, ndim=2] xn_propswap,
+    xn_prop_update_fn,
+    np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
+    this_cts_model,
+):
     """Run the model forward for a specified period of time.
 
     Parameters
     ----------
     run_to : float
         Time to run to, starting from self.current_time
     node_state_grid : 1D array of ints (x number of nodes) (optional)
@@ -1097,49 +1265,63 @@
         # Is there an event scheduled to occur within this run?
         if event_queue[0].time <= run_to:
 
             # If so, pick the next transition event from the event queue
             ev = heappop(event_queue)
 
             # ... and execute the transition
-            do_transition(ev, next_update,
-                              node_at_link_tail,
-                              node_at_link_head,
-                              node_state, link_state,
-                              status_at_node, link_orientation,
-                              propid, prop_data,
-                              n_xn, xn_to, xn_rate,
-                              links_at_node,
-                              active_link_dirs_at_node,
-                              num_node_states, num_node_states_sq,
-                              prop_reset_value, xn_propswap,
-                              xn_prop_update_fn,
-                              bnd_lnk, event_queue,
-                              this_cts_model,
-                              plot_each_transition,
-                              plotter)
+            do_transition(
+                ev,
+                next_update,
+                node_at_link_tail,
+                node_at_link_head,
+                node_state,
+                link_state,
+                status_at_node,
+                link_orientation,
+                propid,
+                prop_data,
+                n_xn,
+                xn_to,
+                xn_rate,
+                links_at_node,
+                active_link_dirs_at_node,
+                num_node_states,
+                num_node_states_sq,
+                prop_reset_value,
+                xn_propswap,
+                xn_prop_update_fn,
+                bnd_lnk,
+                event_queue,
+                this_cts_model,
+                plot_each_transition,
+                plotter,
+            )
 
             # Update current time
             current_time = ev.time
 
         # If there is no event scheduled for this span of time, simply
         # advance current_time to the end of the current run period.
         else:
             current_time = run_to
 
     return current_time
 
 
 @cython.boundscheck(False)
 @cython.wraparound(False)
-cpdef get_next_event_lean(DTYPE_INT_t link, DTYPE_INT_t current_state,
-                   DTYPE_t current_time,
-                   np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
-                   np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
-                   np.ndarray[DTYPE_t, ndim=2] xn_rate):
+cpdef get_next_event_lean(
+    DTYPE_INT_t link,
+    DTYPE_INT_t current_state,
+    DTYPE_t current_time,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
+    np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
+    np.ndarray[DTYPE_t, ndim=2] xn_rate,
+):
     """Get the next event for a link.
 
     Returns the next event for link with ID "link", which is in state
     "current state". This "lean" version omits parameters related to property
     exchange and callback function.
 
     Parameters
@@ -1168,55 +1350,57 @@
     chosen for each, and the smallest of these applied.
 
     Assumes that there is at least one potential transition from the
     current state.
     """
     cdef int my_xn_to
     cdef int i
-    cdef char propswap
     cdef double next_time, this_next
     cdef Event my_event
 
     # Find next event time for each potential transition
     if n_xn[current_state] == 1:
         my_xn_to = xn_to[current_state, 0]
         next_time = np.random.exponential(1.0 / xn_rate[current_state, 0])
-        #next_time = -(1.0 / xn_rate[current_state, 0]) * log(1.0 - rand())
+        # next_time = -(1.0 / xn_rate[current_state, 0]) * log(1.0 - rand())
     else:
         next_time = _NEVER
         my_xn_to = 0
         for i in range(n_xn[current_state]):
             this_next = np.random.exponential(1.0 / xn_rate[current_state, i])
-            #this_next = -(1.0 / xn_rate[current_state, i]) * log(1.0 - rand())
+            # this_next = -(1.0 / xn_rate[current_state, i]) * log(1.0 - rand())
             if this_next < next_time:
                 next_time = this_next
                 my_xn_to = xn_to[current_state, i]
 
     # Create and setup event, and return it
     my_event = Event(next_time + current_time, link, my_xn_to)
 
     return my_event
 
 
 @cython.boundscheck(False)
 @cython.wraparound(False)
-cdef void update_link_state_lean(DTYPE_INT_t link, DTYPE_INT_t new_link_state,
-                      DTYPE_t current_time,
-                      np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
-                      np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                      np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
-                      np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
-                      np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
-                      DTYPE_INT_t num_node_states,
-                      DTYPE_INT_t num_node_states_sq,
-                      np.ndarray[DTYPE_INT_t, ndim=1] link_state,
-                      np.ndarray[DTYPE_INT_t, ndim=1] n_xn, event_queue,
-                      np.ndarray[DTYPE_t, ndim=1] next_update,
-                      np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
-                      np.ndarray[DTYPE_t, ndim=2] xn_rate):
+cdef void update_link_state_lean(
+    DTYPE_INT_t link,
+    DTYPE_INT_t new_link_state,
+    DTYPE_t current_time,
+    np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
+    np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
+    DTYPE_INT_t num_node_states,
+    DTYPE_INT_t num_node_states_sq,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_xn, event_queue,
+    np.ndarray[DTYPE_t, ndim=1] next_update,
+    np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
+    np.ndarray[DTYPE_t, ndim=2] xn_rate,
+):
     """
     Implements a link transition by updating the current state of the link
     and (if appropriate) choosing the next transition event and pushing it
     on to the event queue. This "lean" version omits parameters related to
     property exchange and callback function.
 
     Parameters
@@ -1235,46 +1419,48 @@
 
     # If the link connects to a boundary, we might have a different state
     # than the one we planned
     if bnd_lnk[link]:
         fns = node_state[node_at_link_tail[link]]
         tns = node_state[node_at_link_head[link]]
         orientation = link_orientation[link]
-        new_link_state = orientation * num_node_states_sq + \
-            fns * num_node_states + tns
+        new_link_state = orientation * num_node_states_sq + fns * num_node_states + tns
 
     link_state[link] = new_link_state
     if n_xn[new_link_state] > 0:
-        event = get_next_event_lean(link, new_link_state, current_time, n_xn, xn_to,
-                               xn_rate)
+        event = get_next_event_lean(
+            link, new_link_state, current_time, n_xn, xn_to, xn_rate
+        )
         heappush(event_queue, event)
         next_update[link] = event.time
     else:
         next_update[link] = _NEVER
 
 
 @cython.boundscheck(False)
 @cython.wraparound(False)
-cdef void do_transition_lean(Event event,
-                  np.ndarray[DTYPE_t, ndim=1] next_update,
-                  np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
-                  np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
-                  np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                  np.ndarray[DTYPE_INT_t, ndim=1] link_state,
-                  np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
-                  np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
-                  np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
-                  np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
-                  np.ndarray[DTYPE_t, ndim=2] xn_rate,
-                  np.ndarray[DTYPE_INT_t, ndim=2] links_at_node,
-                  np.ndarray[DTYPE_INT8_t, ndim=2] active_link_dirs_at_node,
-                  DTYPE_INT_t num_node_states,
-                  DTYPE_INT_t num_node_states_sq,
-                  np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
-                  object event_queue):
+cdef void do_transition_lean(
+    Event event,
+    np.ndarray[DTYPE_t, ndim=1] next_update,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_state,
+    np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
+    np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
+    np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
+    np.ndarray[DTYPE_t, ndim=2] xn_rate,
+    np.ndarray[DTYPE_INT_t, ndim=2] links_at_node,
+    np.ndarray[DTYPE_INT8_t, ndim=2] active_link_dirs_at_node,
+    DTYPE_INT_t num_node_states,
+    DTYPE_INT_t num_node_states_sq,
+    np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
+    object event_queue,
+):
     """Transition state.
 
     Implements a state transition. This "lean" version omits parameters related
     to property exchange and callback function.
 
     Parameters
     ----------
@@ -1299,21 +1485,19 @@
     cdef int tail_node, head_node  # IDs of tail and head nodes at link
     cdef int old_tail_node_state
     cdef int old_head_node_state
     cdef int this_link_tail_node   # Tail ID for an adjacent link
     cdef int this_link_head_node   # Head ID for an adjacent link
     cdef int link                  # ID of a link
     cdef int new_link_state        # New link state after transition
-    cdef int tmp                   # Used to exchange property IDs
-    cdef char tail_changed, head_changed,  # Booleans
     cdef char dir_code             # Direction code for link at node
     cdef char orientation          # Orientation code for link
     cdef int i
 
-    #print 'dtl'
+    # print 'dtl'
 
     # We'll process the event if its update time matches the one we have
     # recorded for the link in question. If not, it means that the link has
     # changed state since the event was pushed onto the event queue, and
     # in that case we'll ignore it.
     if event.time == next_update[event.link]:
 
@@ -1321,24 +1505,40 @@
         head_node = node_at_link_head[event.link]
 
         # Remember the previous state of each node so we can detect whether the
         # state has changed
         old_tail_node_state = node_state[tail_node]
         old_head_node_state = node_state[head_node]
 
-        update_node_states(node_state, status_at_node, tail_node,
-                           head_node, event.xn_to, num_node_states)
-        update_link_state_lean(event.link, event.xn_to, event.time,
-                          bnd_lnk, node_state,
-                          node_at_link_tail,
-                          node_at_link_head,
-                          link_orientation, num_node_states,
-                          num_node_states_sq, link_state,
-                          n_xn, event_queue,
-                          next_update, xn_to, xn_rate)
+        update_node_states(
+            node_state,
+            status_at_node,
+            tail_node,
+            head_node,
+            event.xn_to,
+            num_node_states,
+        )
+        update_link_state_lean(
+            event.link,
+            event.xn_to,
+            event.time,
+            bnd_lnk,
+            node_state,
+            node_at_link_tail,
+            node_at_link_head,
+            link_orientation,
+            num_node_states,
+            num_node_states_sq,
+            link_state,
+            n_xn,
+            event_queue,
+            next_update,
+            xn_to,
+            xn_rate,
+        )
 
         # Next, when the state of one of the link's nodes changes, we have
         # to update the states of the OTHER links attached to it. This
         # could happen to one or both nodes.
         if node_state[tail_node] != old_tail_node_state:
 
             for i in range(links_at_node.shape[1]):
@@ -1350,23 +1550,34 @@
 
                     this_link_tail_node = node_at_link_tail[link]
                     this_link_head_node = node_at_link_head[link]
                     orientation = link_orientation[link]
                     new_link_state = (
                         orientation * num_node_states_sq +
                         node_state[this_link_tail_node] * num_node_states +
-                        node_state[this_link_head_node])
-                    update_link_state_lean(link, new_link_state, event.time,
-                                      bnd_lnk, node_state,
-                                      node_at_link_tail,
-                                      node_at_link_head,
-                                      link_orientation, num_node_states,
-                                      num_node_states_sq, link_state,
-                                      n_xn, event_queue,
-                                      next_update, xn_to, xn_rate)
+                        node_state[this_link_head_node]
+                    )
+                    update_link_state_lean(
+                        link,
+                        new_link_state,
+                        event.time,
+                        bnd_lnk,
+                        node_state,
+                        node_at_link_tail,
+                        node_at_link_head,
+                        link_orientation,
+                        num_node_states,
+                        num_node_states_sq,
+                        link_state,
+                        n_xn,
+                        event_queue,
+                        next_update,
+                        xn_to,
+                        xn_rate,
+                    )
 
         if node_state[head_node] != old_head_node_state:
 
             for i in range(links_at_node.shape[1]):
 
                 link = links_at_node[head_node, i]
                 dir_code = active_link_dirs_at_node[head_node, i]
@@ -1374,43 +1585,57 @@
                 if dir_code != 0 and link != event.link:
                     this_link_tail_node = node_at_link_tail[link]
                     this_link_head_node = node_at_link_head[link]
                     orientation = link_orientation[link]
                     new_link_state = (
                         orientation * num_node_states_sq +
                         node_state[this_link_tail_node] * num_node_states +
-                        node_state[this_link_head_node])
-                    update_link_state_lean(link, new_link_state, event.time,
-                                      bnd_lnk, node_state,
-                                      node_at_link_tail,
-                                      node_at_link_head,
-                                      link_orientation, num_node_states,
-                                      num_node_states_sq, link_state,
-                                      n_xn, event_queue,
-                                      next_update, xn_to, xn_rate)
+                        node_state[this_link_head_node]
+                    )
+                    update_link_state_lean(
+                        link,
+                        new_link_state,
+                        event.time,
+                        bnd_lnk,
+                        node_state,
+                        node_at_link_tail,
+                        node_at_link_head,
+                        link_orientation,
+                        num_node_states,
+                        num_node_states_sq,
+                        link_state,
+                        n_xn,
+                        event_queue,
+                        next_update,
+                        xn_to,
+                        xn_rate,
+                    )
 
 
 @cython.boundscheck(False)
-cpdef double run_cts_lean(double run_to, double current_time,
-                     object event_queue,
-                     np.ndarray[DTYPE_t, ndim=1] next_update,
-                     np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
-                     np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
-                     np.ndarray[DTYPE_INT_t, ndim=1] node_state,
-                     np.ndarray[DTYPE_INT_t, ndim=1] link_state,
-                     np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
-                     np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
-                     np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
-                     np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
-                     np.ndarray[DTYPE_t, ndim=2] xn_rate,
-                     np.ndarray[DTYPE_INT_t, ndim=2] links_at_node,
-                     np.ndarray[DTYPE_INT8_t, ndim=2] active_link_dirs_at_node,
-                     DTYPE_INT_t num_node_states,
-                     DTYPE_INT_t num_node_states_sq,
-                     np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk):
+cpdef double run_cts_lean(
+    double run_to,
+    double current_time,
+    object event_queue,
+    np.ndarray[DTYPE_t, ndim=1] next_update,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_tail,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_at_link_head,
+    np.ndarray[DTYPE_INT_t, ndim=1] node_state,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_state,
+    np.ndarray[DTYPE_UINT8_t, ndim=1] status_at_node,
+    np.ndarray[DTYPE_INT8_t, ndim=1] link_orientation,
+    np.ndarray[DTYPE_INT_t, ndim=1] n_xn,
+    np.ndarray[DTYPE_INT_t, ndim=2] xn_to,
+    np.ndarray[DTYPE_t, ndim=2] xn_rate,
+    np.ndarray[DTYPE_INT_t, ndim=2] links_at_node,
+    np.ndarray[DTYPE_INT8_t, ndim=2] active_link_dirs_at_node,
+    DTYPE_INT_t num_node_states,
+    DTYPE_INT_t num_node_states_sq,
+    np.ndarray[DTYPE_INT8_t, ndim=1] bnd_lnk,
+):
     """Run the model forward for a specified period of time. This "lean"
     version omits parameters related to property exchange and callback fn.
 
     Parameters
     ----------
     run_to : float
         Time to run to, starting from self.current_time
@@ -1420,30 +1645,39 @@
 
     # Continue until we've run out of either time or events
     while current_time < run_to and event_queue:
 
         # Is there an event scheduled to occur within this run?
         if event_queue[0].time <= run_to:
 
-            #print 'popping'
+            # print 'popping'
 
             # If so, pick the next transition event from the event queue
             ev = heappop(event_queue)
 
             # ... and execute the transition
-            do_transition_lean(ev, next_update,
-                              node_at_link_tail,
-                              node_at_link_head,
-                              node_state, link_state,
-                              status_at_node, link_orientation,
-                              n_xn, xn_to, xn_rate,
-                              links_at_node,
-                              active_link_dirs_at_node,
-                              num_node_states, num_node_states_sq,
-                              bnd_lnk, event_queue)
+            do_transition_lean(
+                ev,
+                next_update,
+                node_at_link_tail,
+                node_at_link_head,
+                node_state,
+                link_state,
+                status_at_node,
+                link_orientation,
+                n_xn,
+                xn_to,
+                xn_rate,
+                links_at_node,
+                active_link_dirs_at_node,
+                num_node_states,
+                num_node_states_sq,
+                bnd_lnk,
+                event_queue,
+            )
 
             # Update current time
             current_time = ev.time
 
         # If there is no event scheduled for this span of time, simply
         # advance current_time to the end of the current run period.
         else:
```

### Comparing `landlab-2.7.0/landlab/ca/hex_cts.py` & `landlab-2.8.0/landlab/ca/hex_cts.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/ca/oriented_hex_cts.py` & `landlab-2.8.0/landlab/ca/oriented_hex_cts.py`

 * *Files 0% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 import numpy as np
 
 from ..grid import HexModelGrid
 from .celllab_cts import CellLabCTSModel
 
 
 class OrientedHexCTS(CellLabCTSModel):
-
     """Oriented hex-grid CellLab-CTS model.
 
     OrientedHexCTS constructor: sets number of orientations to 3 and calls
     base-class constructor.
 
     Parameters
     ----------
```

### Comparing `landlab-2.7.0/landlab/ca/oriented_raster_cts.py` & `landlab-2.8.0/landlab/ca/oriented_raster_cts.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,15 +16,14 @@
 import numpy as np
 
 from ..grid import RasterModelGrid
 from .celllab_cts import CellLabCTSModel
 
 
 class OrientedRasterCTS(CellLabCTSModel):
-
     """Oriented raster CellLab-CTS model.
 
     RasterCTS constructor: sets number of orientations to 2 and calls
     base-class constructor.
 
     Parameters
     ----------
```

### Comparing `landlab-2.7.0/landlab/ca/raster_cts.py` & `landlab-2.8.0/landlab/ca/raster_cts.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/cmd/authors.py` & `landlab-2.8.0/landlab/cmd/authors.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 import itertools
 import os
 import subprocess
 import textwrap
-from collections import ChainMap, UserDict
+from collections import ChainMap
+from collections import UserDict
 
 try:
     import tomllib
 except ModuleNotFoundError:
     import tomli as tomllib
```

### Comparing `landlab-2.7.0/landlab/cmd/landlab.py` & `landlab-2.8.0/landlab/cmd/landlab.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,30 +1,33 @@
 import contextlib
 import inspect
 import itertools
 import os
 import pathlib
+import re
 import sys
 import textwrap
 from collections import defaultdict
+from collections.abc import Iterable
 from functools import partial
 
 import numpy as np
 import rich_click as click
 
-from landlab import (
-    FramedVoronoiGrid,
-    HexModelGrid,
-    ModelGrid,
-    RadialModelGrid,
-    RasterModelGrid,
-    VoronoiDelaunayGrid,
-)
-
-from .authors import AuthorList, AuthorsConfig, AuthorsSubprocessError, GitLog
+from landlab import FramedVoronoiGrid
+from landlab import HexModelGrid
+from landlab import ModelGrid
+from landlab import RadialModelGrid
+from landlab import RasterModelGrid
+from landlab import VoronoiDelaunayGrid
+
+from .authors import AuthorList
+from .authors import AuthorsConfig
+from .authors import AuthorsSubprocessError
+from .authors import GitLog
 
 GRIDS = [
     ModelGrid,
     RasterModelGrid,
     VoronoiDelaunayGrid,
     HexModelGrid,
     RadialModelGrid,
@@ -140,28 +143,27 @@
     if failures:
         click.Abort()
     else:
         out(" All good! ")
 
 
 @landlab.group()
-@click.option("--ignore", help="users to ignore", multiple=True, type=str)
 @click.option(
     "--authors-file",
     type=click.Path(exists=False, file_okay=True, dir_okay=False, readable=True),
     help="existing authors file",
 )
 @click.option(
     "--credits-file",
     default=".credits.toml",
     type=click.Path(exists=False, file_okay=True, dir_okay=False, readable=True),
     help="The file that contains a list of authors",
 )
 @click.pass_context
-def authors(ctx, ignore, authors_file, credits_file):
+def authors(ctx, authors_file, credits_file):
     """Commands for working with lists of authors."""
     verbose = ctx.parent.params["verbose"]
     silent = ctx.parent.params["silent"]
 
     config = AuthorsConfig(**{k: v for k, v in ctx.params.items() if v})
 
     for k, v in config.items():
@@ -212,15 +214,15 @@
 
 @authors.command()
 @click.pass_context
 def build(ctx):
     """Build an authors file."""
     verbose = ctx.parent.parent.params["verbose"]
     silent = ctx.parent.parent.params["silent"]
-    ignore = set(ctx.parent.params["ignore"])
+    exclude = ctx.parent.params["exclude"]
     authors_file = pathlib.Path(ctx.parent.params["authors_file"])
     author_format = ctx.parent.params["author_format"]
     credits_file = pathlib.Path(ctx.parent.params["credits_file"])
 
     git_log = GitLog("%aN")
     try:
         commit_authors = git_log()
@@ -253,15 +255,15 @@
 
     lines = [intro]
     for author in sorted(authors, key=lambda a: commits[a.name], reverse=True):
         github = _guess_github_user(author)
         if github is None:
             github = "landlab"
         author.github = github
-        if ignore.isdisjoint(author.names):
+        if not exclude_matches_any(author.names, exclude):
             lines.append(
                 author_format.format(
                     name=author.name, github=author.github, email=author.email
                 )
             )
 
     print(os.linesep.join(lines))
@@ -363,26 +365,26 @@
         good_name, good_email = author.name, author.email
         for bad_name, bad_email in itertools.product(
             sorted(author.names), sorted(author.emails)
         ):
             print(f"{good_name} <{good_email}> {bad_name} <{bad_email}>")
 
 
-@authors.command()
+@authors.command(name="list")
 @click.option(
     "--file",
     default="authors.toml",
     type=click.Path(exists=True, file_okay=True, dir_okay=False, readable=True),
     help="existing authors file",
 )
 @click.pass_context
-def list(ctx, file):
-    ignore = set(ctx.parent.params["ignore"])
+def authors_list(ctx, file):
     verbose = ctx.parent.parent.params["verbose"]
     silent = ctx.parent.parent.params["silent"]
+    exclude = ctx.parent.params["exclude"]
 
     git_log = GitLog("%aN")
     try:
         commit_authors = git_log()
     except AuthorsSubprocessError as error:
         err(error)
         raise click.Abort() from error
@@ -397,18 +399,26 @@
     commits = defaultdict(int)
     for author in commit_authors.splitlines():
         canonical_name = authors.find_author(author.strip()).name
         commits[canonical_name] += 1
 
     for name, n_commits in sorted(commits.items(), key=lambda x: x[1], reverse=True):
         author = authors.find_author(name)
-        if ignore.isdisjoint(author.names):
+        if not exclude_matches_any(author.names, exclude):
             print(f"{author.name} <{author.email}> ({n_commits})")
 
 
+def exclude_matches_any(names: Iterable[str], exclude: str):
+    exclude_re = re.compile(exclude)
+    for name in names:
+        if exclude_re.search(name):
+            return True
+    return False
+
+
 @landlab.group(chain=True)
 @click.pass_context
 def index(ctx):
     pass
 
 
 @index.command()
```

### Comparing `landlab-2.7.0/landlab/components/__init__.py` & `landlab-2.8.0/landlab/components/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,97 +1,110 @@
 from .advection import AdvectionSolverTVD
 from .area_slope_transporter import AreaSlopeTransporter
 from .bedrock_landslider import BedrockLandslider
 from .carbonate import CarbonateProducer
 from .chi_index import ChiFinder
+from .concentration_tracker import ConcentrationTrackerForDiffusion
 from .depression_finder import DepressionFinderAndRouter
 from .depth_dependent_diffusion import DepthDependentDiffuser
 from .depth_dependent_taylor_soil_creep import DepthDependentTaylorDiffuser
-from .detachment_ltd_erosion import DepthSlopeProductErosion, DetachmentLtdErosion
+from .detachment_ltd_erosion import DepthSlopeProductErosion
+from .detachment_ltd_erosion import DetachmentLtdErosion
 from .diffusion import LinearDiffuser
 from .dimensionless_discharge import DimensionlessDischarge
 from .discharge_diffuser import DischargeDiffuser
 from .drainage_density import DrainageDensity
 from .erosion_deposition import ErosionDeposition
 from .fire_generator import FireGenerator
-from .flexure import Flexure, Flexure1D
-from .flow_accum import FlowAccumulator, LossyFlowAccumulator
-from .flow_director import (
-    FlowDirectorD8,
-    FlowDirectorDINF,
-    FlowDirectorMFD,
-    FlowDirectorSteepest,
-)
+from .flexure import Flexure
+from .flexure import Flexure1D
+from .flow_accum import FlowAccumulator
+from .flow_accum import LossyFlowAccumulator
+from .flow_director import FlowDirectorD8
+from .flow_director import FlowDirectorDINF
+from .flow_director import FlowDirectorMFD
+from .flow_director import FlowDirectorSteepest
 from .fracture_grid import FractureGridGenerator
 from .gflex import gFlex
 from .gravel_bedrock_eroder import GravelBedrockEroder
 from .gravel_river_transporter import GravelRiverTransporter
 from .groundwater import GroundwaterDupuitPercolator
 from .hack_calculator import HackCalculator
 from .hand_calculator import HeightAboveDrainageCalculator
 from .lake_fill import LakeMapperBarnes
 from .landslides import LandslideProbability
 from .lateral_erosion import LateralEroder
-from .lithology import LithoLayers, Lithology
+from .lithology import LithoLayers
+from .lithology import Lithology
 from .marine_sediment_transport import SimpleSubmarineDiffuser
+from .mass_wasting_runout import MassWastingRunout
 from .network_sediment_transporter import NetworkSedimentTransporter
 from .network_sediment_transporter.bed_parcel_initializers import (
     BedParcelInitializerArea,
+)
+from .network_sediment_transporter.bed_parcel_initializers import (
     BedParcelInitializerDepth,
+)
+from .network_sediment_transporter.bed_parcel_initializers import (
     BedParcelInitializerDischarge,
+)
+from .network_sediment_transporter.bed_parcel_initializers import (
     BedParcelInitializerUserD50,
 )
 from .network_sediment_transporter.sediment_pulser_at_links import SedimentPulserAtLinks
 from .network_sediment_transporter.sediment_pulser_each_parcel import (
     SedimentPulserEachParcel,
 )
 from .nonlinear_diffusion import PerronNLDiffuse
 from .normal_fault import NormalFault
-from .overland_flow import (
-    KinematicWaveRengers,
-    KinwaveImplicitOverlandFlow,
-    KinwaveOverlandFlowModel,
-    LinearDiffusionOverlandFlowRouter,
-    OverlandFlow,
-    OverlandFlowBates,
-)
+from .overland_flow import KinematicWaveRengers
+from .overland_flow import KinwaveImplicitOverlandFlow
+from .overland_flow import KinwaveOverlandFlowModel
+from .overland_flow import LinearDiffusionOverlandFlowRouter
+from .overland_flow import OverlandFlow
+from .overland_flow import OverlandFlowBates
 from .pet import PotentialEvapotranspiration
 from .plant_competition_ca import VegCA
 from .potentiality_flowrouting import PotentialityFlowRouter
 from .priority_flood_flow_router import PriorityFloodFlowRouter
-from .profiler import ChannelProfiler, Profiler, TrickleDownProfiler
+from .profiler import ChannelProfiler
+from .profiler import Profiler
+from .profiler import TrickleDownProfiler
 from .radiation import Radiation
-from .sink_fill import SinkFiller, SinkFillerBarnes
-from .soil_moisture import SoilInfiltrationGreenAmpt, SoilMoisture
-from .space import Space, SpaceLargeScaleEroder
+from .sink_fill import SinkFiller
+from .sink_fill import SinkFillerBarnes
+from .soil_moisture import SoilInfiltrationGreenAmpt
+from .soil_moisture import SoilMoisture
+from .space import Space
+from .space import SpaceLargeScaleEroder
 from .spatial_precip import SpatialPrecipitationDistribution
 from .species_evolution import SpeciesEvolver
 from .steepness_index import SteepnessFinder
-from .stream_power import (
-    FastscapeEroder,
-    SedDepEroder,
-    StreamPowerEroder,
-    StreamPowerSmoothThresholdEroder,
-)
+from .stream_power import FastscapeEroder
+from .stream_power import SedDepEroder
+from .stream_power import StreamPowerEroder
+from .stream_power import StreamPowerSmoothThresholdEroder
 from .taylor_nonlinear_hillslope_flux import TaylorNonLinearDiffuser
 from .tectonics import ListricKinematicExtender
 from .threshold_eroder import ThresholdEroder
 from .tidal_flow import TidalFlowCalculator
 from .transport_length_diffusion import TransportLengthHillslopeDiffuser
 from .uniform_precip import PrecipitationDistribution
 from .vegetation_dynamics import Vegetation
-from .weathering import ExponentialWeatherer, ExponentialWeathererIntegrated
+from .weathering import ExponentialWeatherer
+from .weathering import ExponentialWeathererIntegrated
 
 COMPONENTS = [
     AdvectionSolverTVD,
     AreaSlopeTransporter,
     BedrockLandslider,
     CarbonateProducer,
     ChannelProfiler,
     ChiFinder,
+    ConcentrationTrackerForDiffusion,
     DepressionFinderAndRouter,
     DepthDependentDiffuser,
     DepthDependentTaylorDiffuser,
     DepthSlopeProductErosion,
     DetachmentLtdErosion,
     DischargeDiffuser,
     DimensionlessDischarge,
@@ -124,14 +137,15 @@
     LateralEroder,
     LinearDiffuser,
     LinearDiffusionOverlandFlowRouter,
     ListricKinematicExtender,
     LithoLayers,
     Lithology,
     LossyFlowAccumulator,
+    MassWastingRunout,
     NetworkSedimentTransporter,
     NormalFault,
     OverlandFlow,
     OverlandFlowBates,
     PerronNLDiffuse,
     PotentialEvapotranspiration,
     PotentialityFlowRouter,
```

### Comparing `landlab-2.7.0/landlab/components/advection/advection_solver_tvd.py` & `landlab-2.8.0/landlab/components/advection/advection_solver_tvd.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,18 @@
 #!/usr/bin/env python3
 """Solve advection numerically using Total Variation Diminishing method."""
 
 import numpy as np
 
-from landlab import Component, LinkStatus
+from landlab import Component
+from landlab import LinkStatus
 from landlab.components.advection.flux_limiters import flux_lim_vanleer
 from landlab.field.errors import FieldError
-from landlab.utils.return_array import return_array_at_link, return_array_at_node
+from landlab.utils.return_array import return_array_at_link
+from landlab.utils.return_array import return_array_at_node
 
 
 def find_upwind_link_at_link(grid, u):
     """Return the upwind link at every link.
 
     For all links, return ID of upwind link, defined based on the sign of `u`.
     If `u` is zero, the upwind link is found as though `u` were positive.
```

### Comparing `landlab-2.7.0/landlab/components/area_slope_transporter/area_slope_transporter.py` & `landlab-2.8.0/landlab/components/area_slope_transporter/area_slope_transporter.py`

 * *Files 1% similar despite different names*

```diff
@@ -196,19 +196,19 @@
         >>> grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
         >>> grid.status_at_node[4] = grid.BC_NODE_IS_FIXED_VALUE
         >>> fa = FlowAccumulator(grid)
         >>> fa.run_one_step()
         >>> transporter = AreaSlopeTransporter(grid)
         >>> transporter.calc_sediment_rate_of_change()
         >>> np.round(transporter._sediment_outflux[4:7], 3)
-        array([ 0.   ,  0.365,  0.138])
+        array([0.   , 0.365, 0.138])
         >>> np.round(transporter._sediment_influx[4:7], 3)
-        array([ 0.365,  0.138,  0.   ])
+        array([0.365, 0.138, 0.   ])
         >>> np.round(transporter._dzdt[5:7], 8)
-        array([ -2.26400000e-05,  -1.38200000e-05])
+        array([-2.264e-05, -1.382e-05])
         """
         self.calc_transport_capacity()
         cores = self.grid.core_nodes
         self._sediment_influx[:] = 0.0
         for c in cores:  # send sediment downstream
             r = self._receiver_node[c]
             self._sediment_influx[r] += self._sediment_outflux[c]
@@ -230,11 +230,11 @@
         >>> grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
         >>> grid.status_at_node[4] = grid.BC_NODE_IS_FIXED_VALUE
         >>> fa = FlowAccumulator(grid)
         >>> fa.run_one_step()
         >>> transporter = AreaSlopeTransporter(grid)
         >>> transporter.run_one_step(10000.0)
         >>> np.round(elev[4:7], 4)
-        array([ 0.    ,  0.7736,  1.8618])
+        array([0.    , 0.7736, 1.8618])
         """
         self.calc_sediment_rate_of_change()
         self._elev += self._dzdt * dt
```

### Comparing `landlab-2.7.0/landlab/components/bedrock_landslider/bedrock_landslider.py` & `landlab-2.8.0/landlab/components/bedrock_landslider/bedrock_landslider.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/bedrock_landslider/cfuncs.pyx` & `landlab-2.8.0/landlab/components/bedrock_landslider/cfuncs.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 
 DTYPE_INT = int
 ctypedef np.int_t DTYPE_INT_t
 
 DTYPE_FLOAT = np.float64
 ctypedef np.float64_t DTYPE_FLOAT_t
 
+
 @cython.boundscheck(False)
 cpdef _landslide_runout(
     DTYPE_FLOAT_t dx,
     DTYPE_FLOAT_t phi,
     DTYPE_FLOAT_t min_deposition_slope,
     np.ndarray[DTYPE_INT_t, ndim=1] stack_rev_sel,
     np.ndarray[DTYPE_INT_t, ndim=2] receivers,
@@ -23,22 +24,23 @@
     np.ndarray[DTYPE_FLOAT_t, ndim=1] dH_Hill,
     np.ndarray[DTYPE_FLOAT_t, ndim=1] H_i_temp,
     np.ndarray[DTYPE_FLOAT_t, ndim=1] max_D,
     np.ndarray[DTYPE_FLOAT_t, ndim=1] length_adjacent_cells,
 ):
     """
     Calculate landslide runout using a non-local deposition algorithm, see:
-        * Campforts B., Shobe C.M., Steer P., Vanmaercke M., Lague D., Braun J.
-          (2020) HyLands 1.0: a hybrid landscape evolution model to simulate
-          the impact of landslides and landslide-derived sediment on landscape
-          evolution. Geosci Model Dev: 13(9):386386.
+
+    * Campforts B., Shobe C.M., Steer P., Vanmaercke M., Lague D., Braun J.
+      (2020) HyLands 1.0: a hybrid landscape evolution model to simulate
+      the impact of landslides and landslide-derived sediment on landscape
+      evolution. Geosci Model Dev: 13(9):386386.
     """
     # define internal variables
     cdef int donor, rcvr, r
-    cdef double accum, proportion, dH
+    cdef double proportion, dH
 
     # Iterate backward through the stack, which means we work from upstream to
     # downstream.
     for donor in stack_rev_sel:
         dH = max(
                 0,
                 min(((Qs_in[donor] / dx) / L_Hill[donor]) / (1 - phi), max_D[donor])
@@ -48,14 +50,20 @@
 
         Qs_in[donor] -= dH * dx * dx * (1 - phi)
         Qs_out[donor] += Qs_in[donor]
 
         for r in range(receivers.shape[1]):
             rcvr = receivers[donor, r]
 
-            max_D_angle = H_i_temp[donor] - min_deposition_slope*length_adjacent_cells[r] - H_i_temp[rcvr]
-            max_D[rcvr] = min(max(max_D[rcvr] , H_i_temp[donor] - H_i_temp[rcvr]),max_D_angle)
+            max_D_angle = (
+                H_i_temp[donor]
+                - min_deposition_slope * length_adjacent_cells[r]
+                - H_i_temp[rcvr]
+            )
+            max_D[rcvr] = min(
+                max(max_D[rcvr], H_i_temp[donor] - H_i_temp[rcvr]), max_D_angle
+            )
 
             proportion = fract[donor, r]
             if proportion > 0. and donor != rcvr:
                 Qs_in[rcvr] += Qs_out[donor] * proportion
                 Qs_in[donor] -= Qs_out[donor] * proportion
```

### Comparing `landlab-2.7.0/landlab/components/carbonate/carbonate_producer.py` & `landlab-2.8.0/landlab/components/carbonate/carbonate_producer.py`

 * *Files 1% similar despite different names*

```diff
@@ -29,17 +29,17 @@
     out : array (default None)
         Optional array in which to store result; must have len(x)
 
     Examples
     --------
     >>> import numpy as np
     >>> np.round(smooth_heaviside(np.array([-1, 0, 1])), 3)
-    array([ 0.018,  0.5  ,  0.982])
+    array([0.018, 0.5  , 0.982])
     >>> smooth_heaviside(np.array([-1, 0, 1]), width=0.0)
-    array([ 0. ,  0.5,  1. ])
+    array([0. , 0.5, 1. ])
     """
     if width > 0.0:
         with set_numpy_err(over="ignore"):
             return np.divide(1.0, (1.0 + np.exp(-2.0 / width * np.asarray(x))), out=out)
     else:
         return np.heaviside(x, 0.5)
 
@@ -259,20 +259,23 @@
         Returns
         -------
         float array x number of grid nodes
             Reference to updated carbonate_production_rate field
         """
         self._depth[:] = self.sea_level - self._grid.at_node["topographic__elevation"]
         self._depth.clip(min=-2.0 * self._tidal_range - _EPSILON, out=self._depth)
-        self._carb_prod_rate[
-            self.grid.core_nodes
-        ] = self._max_carbonate_production_rate * np.tanh(
-            self.surface_light
-            * np.exp(-self.extinction_coefficient * self._depth[self.grid.core_nodes])
-            / self.saturating_light
+        self._carb_prod_rate[self.grid.core_nodes] = (
+            self._max_carbonate_production_rate
+            * np.tanh(
+                self.surface_light
+                * np.exp(
+                    -self.extinction_coefficient * self._depth[self.grid.core_nodes]
+                )
+                / self.saturating_light
+            )
         )
         self._carb_prod_rate *= smooth_heaviside(self._depth, width=self.tidal_range)
         return self._carb_prod_rate
 
     def produce_carbonate(self, dt):
         """Grow carbonate for one time step & add to carbonate thickness field.
```

### Comparing `landlab-2.7.0/landlab/components/chi_index/channel_chi.py` & `landlab-2.8.0/landlab/components/chi_index/channel_chi.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 """Created March 2016.
 
 @author: dejh
 """
 
-
 import numpy as np
 
-from landlab import Component, RasterModelGrid
+from landlab import Component
+from landlab import RasterModelGrid
 
 try:
     from itertools import izip
 except ImportError:
     izip = zip
 
 
@@ -36,15 +36,15 @@
     ...     mg.status_at_node[nodes] = mg.BC_NODE_IS_CLOSED
     >>> _ = mg.add_field("topographic__elevation", mg.node_x, at="node")
     >>> fr = FlowAccumulator(mg, flow_director="D8")
     >>> cf = ChiFinder(mg, min_drainage_area=1.0, reference_concavity=1.0)
     >>> fr.run_one_step()
     >>> cf.calculate_chi()
     >>> mg.at_node["channel__chi_index"].reshape(mg.shape)[1, :]
-    array([ 0.5,  1. ,  2. ,  0. ])
+    array([0.5, 1. , 2. , 0. ])
 
     >>> mg2 = RasterModelGrid((5, 5), xy_spacing=100.0)
     >>> for nodes in (
     ...     mg2.nodes_at_right_edge,
     ...     mg2.nodes_at_bottom_edge,
     ...     mg2.nodes_at_top_edge,
     ... ):
@@ -64,41 +64,41 @@
     ...     mg2.at_node["topographic__elevation"][mg2.core_nodes] += 10.0
     ...     fr2.run_one_step()
     ...     sp2.run_one_step(1000.0)
     ...
     >>> fr2.run_one_step()
     >>> cf2.calculate_chi()
     >>> mg2.at_node["channel__chi_index"].reshape(mg2.shape)
-    array([[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ],
-           [ 0.77219416,  1.54438833,  2.63643578,  2.61419437,  0.        ],
-           [ 1.09204746,  2.18409492,  1.52214691,  2.61419437,  0.        ],
-           [ 0.44582651,  0.89165302,  1.66384718,  2.75589464,  0.        ],
-           [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
+    array([[0.        , 0.        , 0.        , 0.        , 0.        ],
+           [0.77219416, 1.54438833, 2.63643578, 2.61419437, 0.        ],
+           [1.09204746, 2.18409492, 1.52214691, 2.61419437, 0.        ],
+           [0.44582651, 0.89165302, 1.66384718, 2.75589464, 0.        ],
+           [0.        , 0.        , 0.        , 0.        , 0.        ]])
 
     >>> cf3 = ChiFinder(
     ...     mg2,
     ...     min_drainage_area=20000.0,
     ...     use_true_dx=True,
     ...     reference_concavity=0.5,
     ...     reference_area=mg2.at_node["drainage_area"].max(),
     ...     clobber=True,
     ... )
     >>> cf3.calculate_chi()
     >>> cf3.chi_indices.reshape(mg2.shape)
-    array([[   0. ,   0.        ,   0.        ,   0. ,   0. ],
-           [   0. , 173.20508076,   0.        ,   0. ,   0. ],
-           [   0. ,   0.        , 270.71067812,   0. ,   0. ],
-           [   0. , 100.        , 236.60254038,   0. ,   0. ],
-           [   0. ,   0.        ,   0.        ,   0. ,   0. ]])
+    array([[  0. ,   0.        ,   0.        ,   0. ,  0. ],
+           [  0. , 173.20508076,   0.        ,   0. ,  0. ],
+           [  0. ,   0.        , 270.71067812,   0. ,  0. ],
+           [  0. , 100.        , 236.60254038,   0. ,  0. ],
+           [  0. ,   0.        ,   0.        ,   0. ,  0. ]])
     >>> cf3.hillslope_mask.reshape(mg2.shape)
     array([[ True,  True,  True,  True,  True],
            [False, False,  True,  True,  True],
            [ True,  True, False,  True,  True],
            [False, False, False,  True,  True],
-           [ True,  True,  True,  True,  True]], dtype=bool)
+           [ True,  True,  True,  True,  True]])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     None Listed
 
@@ -319,19 +319,19 @@
         >>> cf = ChiFinder(mg)
         >>> fr.run_one_step()
         >>> ch_nodes = np.array([4, 8, 12, 5, 9, 13, 6, 10, 14])
         >>> ch_integrand = 3.0 * np.ones(9, dtype=float)  # to make calc clearer
         >>> chi_array = np.zeros(mg.number_of_nodes, dtype=float)
         >>> cf.integrate_chi_avg_dx(ch_nodes, ch_integrand, chi_array, 0.5)
         >>> chi_array.reshape(mg.shape)
-        array([[ 0. ,  0. ,  0. ,  0. ],
-               [ 1.5,  3. ,  4.5,  0. ],
-               [ 1.5,  3. ,  4.5,  0. ],
-               [ 1.5,  3. ,  4.5,  0. ],
-               [ 0. ,  0. ,  0. ,  0. ]])
+        array([[0. , 0. , 0. , 0. ],
+               [1.5, 3. , 4.5, 0. ],
+               [1.5, 3. , 4.5, 0. ],
+               [1.5, 3. , 4.5, 0. ],
+               [0. , 0. , 0. , 0. ]])
         """
         receivers = self._grid.at_node["flow__receiver_node"]
         # because chi_array is all zeros, BC cases where node is receiver
         # resolve themselves
         for node, integrand in izip(valid_upstr_order, chi_integrand):
             dstr_node = receivers[node]
             chi_array[node] = chi_array[dstr_node] + integrand
@@ -377,19 +377,19 @@
         >>> ch_nodes = np.array([4, 8, 12, 5, 9, 13, 6, 10, 14])
         >>> ch_integrand = 2.0 * np.ones(
         ...     mg.number_of_nodes, dtype=float
         ... )  # to make calc clearer
         >>> chi_array = np.zeros(mg.number_of_nodes, dtype=float)
         >>> cf.integrate_chi_each_dx(ch_nodes, ch_integrand, chi_array)
         >>> chi_array.reshape(mg.shape)
-        array([[  0.        ,   0.        ,   0.        ,   0.        ],
-               [  0.        ,   6.        ,  14.48528137,   0.        ],
-               [  0.        ,   6.        ,  12.        ,   0.        ],
-               [  0.        ,   6.        ,  14.48528137,   0.        ],
-               [  0.        ,   0.        ,   0.        ,   0.        ]])
+        array([[ 0.        ,  0.        ,  0.        ,  0.        ],
+               [ 0.        ,  6.        , 14.48528137,  0.        ],
+               [ 0.        ,  6.        , 12.        ,  0.        ],
+               [ 0.        ,  6.        , 14.48528137,  0.        ],
+               [ 0.        ,  0.        ,  0.        ,  0.        ]])
         >>> from landlab.components import FastscapeEroder
         >>> mg2 = RasterModelGrid((5, 5), xy_spacing=100.0)
         >>> for nodes in (
         ...     mg2.nodes_at_right_edge,
         ...     mg2.nodes_at_bottom_edge,
         ...     mg2.nodes_at_top_edge,
         ... ):
@@ -416,19 +416,19 @@
         >>> output_array = np.zeros(25, dtype=float)
         >>> cf2.integrate_chi_each_dx(
         ...     mg2.at_node["flow__upstream_node_order"],
         ...     np.ones(25, dtype=float),
         ...     output_array,
         ... )
         >>> output_array.reshape(mg2.shape)
-        array([[   0. ,    0. ,    0.        ,    0.        ,    0. ],
-               [   0. ,  100. ,  200.        ,  382.84271247,    0. ],
-               [   0. ,  100. ,  241.42135624,  341.42135624,    0. ],
-               [   0. ,  100. ,  200.        ,  300.        ,    0. ],
-               [   0. ,    0. ,    0.        ,    0.        ,    0. ]])
+        array([[  0. ,   0. ,   0.        ,   0.        ,   0. ],
+               [  0. , 100. , 200.        , 382.84271247,   0. ],
+               [  0. , 100. , 241.42135624, 341.42135624,   0. ],
+               [  0. , 100. , 200.        , 300.        ,   0. ],
+               [  0. ,   0. ,   0.        ,   0.        ,   0. ]])
         """
         receivers = self._grid.at_node["flow__receiver_node"]
         links = self._grid.at_node["flow__link_to_receiver_node"]
 
         # because chi_array is all zeros, BC cases where node is receiver
         # resolve themselves
         half_integrand = 0.5 * chi_integrand_at_nodes
@@ -530,15 +530,15 @@
         >>> z = mg.add_field("topographic__elevation", mg.node_x.copy(), at="node")
         >>> z[4:8] = np.array([0.5, 1.0, 2.0, 0.0])
         >>> fr = FlowAccumulator(mg, flow_director="D8")
         >>> cf = ChiFinder(mg, min_drainage_area=1.0, reference_concavity=1.0)
         >>> fr.run_one_step()
         >>> cf.calculate_chi()
         >>> mg.at_node["channel__chi_index"].reshape(mg.shape)[1, :]
-        array([ 0.5,  1. ,  2. ,  0. ])
+        array([0.5, 1. , 2. , 0. ])
         >>> coeffs = cf.best_fit_chi_elevation_gradient_and_intercept()
         >>> np.allclose(np.array([1.0, 0.0]), coeffs)
         True
         """
         if ch_nodes is None:
             good_vals = np.logical_not(self._mask)
         else:
@@ -617,15 +617,19 @@
             A matplotlib-style string for the style to use for the points.
         plot_line : bool
             If True, will plot a linear best fit line through the data cloud.
         line_symbol : str
             A matplotlib-style string for the style to use for the line, if
             plot_line.
         """
-        from matplotlib.pyplot import clf, figure, plot, xlabel, ylabel
+        from matplotlib.pyplot import clf
+        from matplotlib.pyplot import figure
+        from matplotlib.pyplot import plot
+        from matplotlib.pyplot import xlabel
+        from matplotlib.pyplot import ylabel
 
         figure("Chi plot")
         clf()
         if channel_heads is not None:
             if plot_line:
                 good_nodes = set()
             if isinstance(channel_heads, int):
```

### Comparing `landlab-2.7.0/landlab/components/depression_finder/cfuncs.pyx` & `landlab-2.8.0/landlab/components/depression_finder/cfuncs.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -15,16 +15,16 @@
 @cython.boundscheck(False)
 cpdef find_lowest_node_on_lake_perimeter_c(
         np.ndarray[DTYPE_INT_t, ndim=2] node_nbrs,
         np.ndarray[DTYPE_INT_t, ndim=1] flood_status,
         np.ndarray[DTYPE_FLOAT_t, ndim=1] elev,
         np.ndarray[DTYPE_INT_t, ndim=1] nodes_this_depression,
         DTYPE_INT_t pit_count,
-        DTYPE_FLOAT_t BIG_ELEV
-    ):
+        DTYPE_FLOAT_t BIG_ELEV,
+):
     """Locate the lowest node on the margin of the "lake".
 
     Parameters
     ----------
     node_nbrs : (nnodes, 4) or (nnodes, 8) array of int
         The node neighbors, as stored by a DepressionFinderAndRouter
         component
@@ -46,15 +46,17 @@
     (int, int)
         (Lowest node on the perimeter of a depression, updated pit_count)
 
     Examples
     --------
     >>> from landlab import RasterModelGrid
     >>> from landlab.components import FlowAccumulator, DepressionFinderAndRouter
-    >>> from landlab.components.flow_routing.cfuncs import find_lowest_node_on_lake_perimeter_c
+    >>> from landlab.components.flow_routing.cfuncs import (
+    ...     find_lowest_node_on_lake_perimeter_c
+    ... )
     >>> mg = RasterModelGrid((7, 7), xy_spacing=0.5)
     >>> z = mg.add_field('node', 'topographic__elevation', mg.node_x.copy())
     >>> z += 0.01 * mg.node_y
     >>> mg.at_node['topographic__elevation'].reshape(mg.shape)[2:5, 2:5] *= 0.1
     >>> fr = FlowAccumulator(mg, flow_director='D8')
     >>> fr.run_one_step()  # the flow "gets stuck" in the hole
     >>> df = DepressionFinderAndRouter(mg)
```

### Comparing `landlab-2.7.0/landlab/components/depression_finder/lake_mapper.py` & `landlab-2.8.0/landlab/components/depression_finder/lake_mapper.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 """Find depressions on a topographic surface.
 
 .. codeauthor:: gtucker, DEJH (Flow routing)
 """
+
 # Routing by DEJH, Oct 15.
 
 
 import numpy as np
 
 from ...core.model_component import Component
 from ...core.utils import as_id_array
@@ -20,15 +21,14 @@
 _FLOODED = FloodStatus._FLOODED
 _PIT = FloodStatus._PIT
 
 use_cfuncs = True
 
 
 class DepressionFinderAndRouter(Component):
-
     """Find depressions on a topographic surface.
 
     This component identifies depressions in a topographic surface, finds an
     outlet for each depression.  If directed to do so (default True), and the
     component is able to find existing routing fields output from the
     'route_flow_dn' component, it will then modify the drainage directions and
     accumulations already stored in the grid to route flow across these
@@ -68,61 +68,61 @@
            [ 7,  7, 16, 17, 18, 18, 13],
            [14, 14, 16, 16, 17, 18, 20],
            [21, 21, 16, 23, 24, 25, 27],
            [28, 28, 23, 30, 31, 32, 34],
            [35, 35, 30, 31, 32, 32, 41],
            [42, 43, 44, 45, 46, 47, 48]])
     >>> mg.at_node["drainage_area"].reshape(mg.shape)
-    array([[ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ],
-           [ 0.25,  0.25,  0.25,  0.25,  0.25,  0.25,  0.  ],
-           [ 0.25,  0.25,  5.  ,  1.5 ,  1.  ,  0.25,  0.  ],
-           [ 0.25,  0.25,  3.  ,  0.75,  0.5 ,  0.25,  0.  ],
-           [ 0.25,  0.25,  2.  ,  1.5 ,  1.  ,  0.25,  0.  ],
-           [ 0.25,  0.25,  0.25,  0.25,  0.25,  0.25,  0.  ],
-           [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ]])
+    array([[0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
+           [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.  ],
+           [0.25, 0.25, 5.  , 1.5 , 1.  , 0.25, 0.  ],
+           [0.25, 0.25, 3.  , 0.75, 0.5 , 0.25, 0.  ],
+           [0.25, 0.25, 2.  , 1.5 , 1.  , 0.25, 0.  ],
+           [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.  ],
+           [0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ]])
     >>> df = DepressionFinderAndRouter(mg)
     >>> df.map_depressions()  # reroute_flow defaults to True
     >>> mg.at_node["flow__receiver_node"].reshape(mg.shape)
     array([[ 0,  1,  2,  3,  4,  5,  6],
            [ 7,  7, 16, 17, 18, 18, 13],
            [14, 14,  8, 16, 17, 18, 20],
            [21, 21, 16, 16, 24, 25, 27],
            [28, 28, 23, 24, 24, 32, 34],
            [35, 35, 30, 31, 32, 32, 41],
            [42, 43, 44, 45, 46, 47, 48]])
     >>> mg.at_node["drainage_area"].reshape(mg.shape)
-    array([[ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ],
-           [ 5.25,  5.25,  0.25,  0.25,  0.25,  0.25,  0.  ],
-           [ 0.25,  0.25,  5.  ,  1.5 ,  1.  ,  0.25,  0.  ],
-           [ 0.25,  0.25,  0.75,  2.25,  0.5 ,  0.25,  0.  ],
-           [ 0.25,  0.25,  0.5 ,  0.5 ,  1.  ,  0.25,  0.  ],
-           [ 0.25,  0.25,  0.25,  0.25,  0.25,  0.25,  0.  ],
-           [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ]])
+    array([[0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
+           [5.25, 5.25, 0.25, 0.25, 0.25, 0.25, 0.  ],
+           [0.25, 0.25, 5.  , 1.5 , 1.  , 0.25, 0.  ],
+           [0.25, 0.25, 0.75, 2.25, 0.5 , 0.25, 0.  ],
+           [0.25, 0.25, 0.5 , 0.5 , 1.  , 0.25, 0.  ],
+           [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.  ],
+           [0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ]])
     >>> df.lake_at_node.reshape(mg.shape)
     array([[False, False, False, False, False, False, False],
            [False, False, False, False, False, False, False],
            [False, False,  True,  True,  True, False, False],
            [False, False,  True,  True,  True, False, False],
            [False, False,  True,  True,  True, False, False],
            [False, False, False, False, False, False, False],
-           [False, False, False, False, False, False, False]], dtype=bool)
+           [False, False, False, False, False, False, False]])
     >>> df.lake_map.reshape(mg.shape)
     array([[-1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1],
            [-1, -1, 16, 16, 16, -1, -1],
            [-1, -1, 16, 16, 16, -1, -1],
            [-1, -1, 16, 16, 16, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1]])
     >>> df.lake_codes  # a unique code for each lake present on the grid
     array([16])
     >>> df.lake_outlets  # the outlet node of each lake in lake_codes
     array([8])
     >>> df.lake_areas  # the area of each lake in lake_codes
-    array([ 2.25])
+    array([2.25])
 
     Because ``rereoute_flow`` defaults to ``True``, the flow connectivity fields
     created by the :py:class:`~landlab.components.flow_accum.FlowAccumulator`
     will have now been modified to route flow over the depressions in the
     surface. The topogrphy itself is not modified.
 
     References
@@ -399,20 +399,20 @@
         # equal elevations and one is an open boundary, the other is not a pit.
         act_links = self._grid.active_links
         h_orth = self._grid.node_at_link_head[act_links]
         t_orth = self._grid.node_at_link_tail[act_links]
 
         # These two lines assign the False flag to any node that is higher
         # than its partner on the other end of its link
-        self._is_pit[
-            h_orth[np.where(self._elev[h_orth] > self._elev[t_orth])[0]]
-        ] = False
-        self._is_pit[
-            t_orth[np.where(self._elev[t_orth] > self._elev[h_orth])[0]]
-        ] = False
+        self._is_pit[h_orth[np.where(self._elev[h_orth] > self._elev[t_orth])[0]]] = (
+            False
+        )
+        self._is_pit[t_orth[np.where(self._elev[t_orth] > self._elev[h_orth])[0]]] = (
+            False
+        )
 
         # If we have a raster grid, handle the diagonal active links too
         # (At the moment, their data structure is a bit different)
         # TODO: update the diagonal link data structures
         # DEJH doesn't understand why this can't be vectorized as above...
         if self._D8:
             for h, t in self._grid.nodes_at_diagonal[self._grid.active_diagonals]:
```

### Comparing `landlab-2.7.0/landlab/components/depth_dependent_diffusion/hillslope_depth_dependent_linear_flux.py` & `landlab-2.8.0/landlab/components/depth_dependent_diffusion/hillslope_depth_dependent_linear_flux.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 """Created on Fri Apr  8 08:32:48 2016.
 
 @author: RCGlade
 """
 
 import numpy as np
 
-from landlab import Component, LinkStatus
+from landlab import Component
+from landlab import LinkStatus
 
 
 class DepthDependentDiffuser(Component):
-
     """This component implements a depth and slope dependent linear diffusion
     rule in the style of Johnstone and Hilley (2014).
 
     Hillslope sediment flux uses depth dependent component inspired by
     Johnstone and Hilley (2014). The flux :math:`q_s` is given as:
 
     .. math::
```

### Comparing `landlab-2.7.0/landlab/components/depth_dependent_taylor_soil_creep/hillslope_depth_dependent_taylor_flux.py` & `landlab-2.8.0/landlab/components/depth_dependent_taylor_soil_creep/hillslope_depth_dependent_taylor_flux.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,15 +3,16 @@
 @author: R Glade
 @author: K Barnhart
 @author: G Tucker
 """
 
 import numpy as np
 
-from landlab import Component, LinkStatus
+from landlab import Component
+from landlab import LinkStatus
 from landlab.core.messages import deprecation_message
 
 
 class DepthDependentTaylorDiffuser(Component):
     r"""
     This component implements a depth-dependent Taylor series diffusion rule,
     combining concepts of Ganti et al. (2012) and Johnstone and Hilley (2014).
@@ -129,15 +130,15 @@
     >>> DDdiff = DepthDependentTaylorDiffuser(mg, if_unstable="warn")
     >>> DDdiff.run_one_step(2.0)
     Topographic slopes are high enough such that the Courant condition is
     exceeded AND you have not selected dynamic timestepping with
     dynamic_dt=True. This may lead to infinite and/or nan values for slope,
     elevation, and soil depth. Consider using a smaller time step or dynamic
     timestepping. The Courant condition recommends a timestep of
-    0.0953407607307 or smaller.
+    0.09534076073069653 or smaller.
 
     Alternatively you can specify if_unstable='raise', and a Runtime Error will
     be raised if this condition is not met.
 
     Next, lets do an example with dynamic timestepping.
 
     >>> mg = RasterModelGrid((3, 5))
```

### Comparing `landlab-2.7.0/landlab/components/detachment_ltd_erosion/generate_detachment_ltd_erosion.py` & `landlab-2.8.0/landlab/components/detachment_ltd_erosion/generate_detachment_ltd_erosion.py`

 * *Files 4% similar despite different names*

```diff
@@ -88,18 +88,18 @@
     'node'
 
 
     Now we test to see how the topography changed as a function of the erosion
     rate.
 
     >>> grid.at_node["topographic__elevation"].reshape(grid.shape)
-    array([[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ],
-           [ 0.99936754,  0.99910557,  0.99910557,  0.99910557,  0.99936754],
-           [ 1.99955279,  1.99936754,  1.99936754,  1.99936754,  1.99955279],
-           [ 2.99968377,  2.99955279,  2.99955279,  2.99955279,  2.99968377]])
+    array([[0.        , 0.        , 0.        , 0.        , 0.        ],
+           [0.99936754, 0.99910557, 0.99910557, 0.99910557, 0.99936754],
+           [1.99955279, 1.99936754, 1.99936754, 1.99936754, 1.99955279],
+           [2.99968377, 2.99955279, 2.99955279, 2.99955279, 2.99968377]])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     None Listed
```

### Comparing `landlab-2.7.0/landlab/components/detachment_ltd_erosion/generate_erosion_by_depth_slope.py` & `landlab-2.8.0/landlab/components/detachment_ltd_erosion/generate_erosion_by_depth_slope.py`

 * *Files 2% similar despite different names*

```diff
@@ -101,15 +101,15 @@
     Now putting slopes on nodes
 
     >>> grid.at_node["water_surface__slope"] = (
     ...     grid.at_link["water_surface__slope"][grid.links_at_node]
     ...     * grid.active_link_dirs_at_node
     ... ).max(axis=1)
     >>> grid.at_node["water_surface__slope"][grid.core_nodes]
-    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
+    array([1., 1., 1., 1., 1., 1., 1., 1., 1.])
 
 
     Instantiate the `DepthSlopeProductErosion` component to work on this grid, and
     run it. In this simple case, we need to pass it a time step ('dt') and also
     an erodibility factor ('k_e').
 
     >>> dt = 1.0
@@ -129,19 +129,19 @@
            [ 0.    , -1.4715, -1.4715, -1.4715,  0.    ],
            [ 0.    , -0.981 , -0.981 , -0.981 ,  0.    ],
            [ 0.    ,  0.    ,  0.    ,  0.    ,  0.    ]])
 
     Now, our updated topography...
 
     >>> grid.at_node["topographic__elevation"].reshape(grid.shape)
-    array([[ 10.    ,   7.5475,   7.5475,   7.5475,  10.    ],
-           [ 10.    ,   8.038 ,   8.038 ,   8.038 ,  10.    ],
-           [ 10.    ,   8.5285,   8.5285,   8.5285,  10.    ],
-           [ 10.    ,   9.019 ,   9.019 ,   9.019 ,  10.    ],
-           [ 10.    ,  10.    ,  10.    ,  10.    ,  10.    ]])
+    array([[10.    ,  7.5475,  7.5475,  7.5475, 10.    ],
+           [10.    ,  8.038 ,  8.038 ,  8.038 , 10.    ],
+           [10.    ,  8.5285,  8.5285,  8.5285, 10.    ],
+           [10.    ,  9.019 ,  9.019 ,  9.019 , 10.    ],
+           [10.    , 10.    , 10.    , 10.    , 10.    ]])
     """
 
     _name = "DepthSlopeProductErosion"
 
     _unit_agnostic = True
 
     _info = {
```

### Comparing `landlab-2.7.0/landlab/components/diffusion/diffusion.py` & `landlab-2.8.0/landlab/components/diffusion/diffusion.py`

 * *Files 0% similar despite different names*

```diff
@@ -4,15 +4,18 @@
 Created July 2013 GT Last updated March 2016 DEJH with LL v1.0 component
 style
 """
 
 
 import numpy as np
 
-from landlab import Component, LinkStatus, NodeStatus, RasterModelGrid
+from landlab import Component
+from landlab import LinkStatus
+from landlab import NodeStatus
+from landlab import RasterModelGrid
 
 _ALPHA = 0.15  # time-step stability factor
 # ^0.25 not restrictive enough at meter scales w S~1 (possible cases)
 
 
 class LinearDiffuser(Component):
     """Linear diffusion of a Landlab field.
```

### Comparing `landlab-2.7.0/landlab/components/dimensionless_discharge/dimensionless_discharge.py` & `landlab-2.8.0/landlab/components/dimensionless_discharge/dimensionless_discharge.py`

 * *Files 4% similar despite different names*

```diff
@@ -62,19 +62,17 @@
      ...     "channel_bottom_sediment_grain__d50_diameter", at="node"
      ... )
      >>> watershed_grid.at_node["topographic__elevation"] = np.array(
      ...     [[1.1, 2, 3, 4, 2, 3, 4, 5, 3]]
      ... )
      >>> dd = DimensionlessDischarge(watershed_grid, gravity=9.8)
      >>> dd.run_one_step()
-     >>> print(watershed_grid.at_node["dimensionless_discharge"])
-     [ 0.55372743  0.55372743  0.55372743  0.55372743  0.55372743
-             0.55372743  0.55372743  0.55372743  0.55372743]
-
-
+     >>> watershed_grid.at_node["dimensionless_discharge"]
+     array([0.55372743, 0.55372743, 0.55372743, 0.55372743, 0.55372743,
+            0.55372743, 0.55372743, 0.55372743, 0.55372743])
 
      References
      ----------
      Tang, H., McGuire, L. A., Rengers, F. K., Kean, J. W., Staley,
      D. M., & Smith, J. B. (2019). Developing and Testing Physically
      Based Triggering Thresholds for Runoff-Generated Debris Flows.
      Geophysical Research Letters, 46(15), 88308839.
```

### Comparing `landlab-2.7.0/landlab/components/discharge_diffuser/diffuse_by_discharge.py` & `landlab-2.8.0/landlab/components/discharge_diffuser/diffuse_by_discharge.py`

 * *Files 0% similar despite different names*

```diff
@@ -4,15 +4,16 @@
 Created on Fri Feb 20 09:32:27 2015
 
 @author: danhobley (SiccarPoint), after volle001@umn.edu
 """
 
 import numpy as np
 
-from landlab import Component, RasterModelGrid
+from landlab import Component
+from landlab import RasterModelGrid
 
 
 class DischargeDiffuser(Component):
     """Diffuse sediment proportional to an implicit water discharge value.
 
     This class implements Voller, Hobley, and Paola's scheme for sediment
     diffusion, where the diffusivity of the sediment is proportional to the
```

### Comparing `landlab-2.7.0/landlab/components/drainage_density/cfuncs.pyx` & `landlab-2.8.0/landlab/components/drainage_density/cfuncs.pyx`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/drainage_density/drainage_density.py` & `landlab-2.8.0/landlab/components/drainage_density/drainage_density.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 """Landlab component to calculate drainage density."""
+
 from warnings import warn
 
 import numpy as np
 
 from landlab import Component
 
 
@@ -64,34 +65,34 @@
     >>> from landlab.components import FlowAccumulator, FastscapeEroder
     >>> mg = RasterModelGrid((10, 10))
     >>> _ = mg.add_zeros("node", "topographic__elevation")
     >>> np.random.seed(50)
     >>> noise = np.random.rand(100)
     >>> mg.at_node["topographic__elevation"] += noise
     >>> mg.at_node["topographic__elevation"].reshape(mg.shape)
-    array([[ 0.49460165,  0.2280831 ,  0.25547392,  0.39632991,  0.3773151 ,
-             0.99657423,  0.4081972 ,  0.77189399,  0.76053669,  0.31000935],
-           [ 0.3465412 ,  0.35176482,  0.14546686,  0.97266468,  0.90917844,
-             0.5599571 ,  0.31359075,  0.88820004,  0.67457307,  0.39108745],
-           [ 0.50718412,  0.5241035 ,  0.92800093,  0.57137307,  0.66833757,
-             0.05225869,  0.3270573 ,  0.05640164,  0.17982769,  0.92593317],
-           [ 0.93801522,  0.71409271,  0.73268761,  0.46174768,  0.93132927,
-             0.40642024,  0.68320577,  0.64991587,  0.59876518,  0.22203939],
-           [ 0.68235717,  0.8780563 ,  0.79671726,  0.43200225,  0.91787822,
-             0.78183368,  0.72575028,  0.12485469,  0.91630845,  0.38771099],
-           [ 0.29492955,  0.61673141,  0.46784623,  0.25533891,  0.83899589,
-             0.1786192 ,  0.22711417,  0.65987645,  0.47911625,  0.07344734],
-           [ 0.13896007,  0.11230718,  0.47778497,  0.54029623,  0.95807105,
-             0.58379231,  0.52666409,  0.92226269,  0.91925702,  0.25200886],
-           [ 0.68263261,  0.96427612,  0.22696165,  0.7160172 ,  0.79776011,
-             0.9367512 ,  0.8537225 ,  0.42154581,  0.00543987,  0.03486533],
-           [ 0.01390537,  0.58890993,  0.3829931 ,  0.11481895,  0.86445401,
-             0.82165703,  0.73749168,  0.84034417,  0.4015291 ,  0.74862   ],
-           [ 0.55962945,  0.61323757,  0.29810165,  0.60237917,  0.42567684,
-             0.53854438,  0.48672986,  0.49989164,  0.91745948,  0.26287702]])
+    array([[0.49460165, 0.2280831 , 0.25547392, 0.39632991, 0.3773151 ,
+            0.99657423, 0.4081972 , 0.77189399, 0.76053669, 0.31000935],
+           [0.3465412 , 0.35176482, 0.14546686, 0.97266468, 0.90917844,
+            0.5599571 , 0.31359075, 0.88820004, 0.67457307, 0.39108745],
+           [0.50718412, 0.5241035 , 0.92800093, 0.57137307, 0.66833757,
+            0.05225869, 0.3270573 , 0.05640164, 0.17982769, 0.92593317],
+           [0.93801522, 0.71409271, 0.73268761, 0.46174768, 0.93132927,
+            0.40642024, 0.68320577, 0.64991587, 0.59876518, 0.22203939],
+           [0.68235717, 0.8780563 , 0.79671726, 0.43200225, 0.91787822,
+            0.78183368, 0.72575028, 0.12485469, 0.91630845, 0.38771099],
+           [0.29492955, 0.61673141, 0.46784623, 0.25533891, 0.83899589,
+            0.1786192 , 0.22711417, 0.65987645, 0.47911625, 0.07344734],
+           [0.13896007, 0.11230718, 0.47778497, 0.54029623, 0.95807105,
+            0.58379231, 0.52666409, 0.92226269, 0.91925702, 0.25200886],
+           [0.68263261, 0.96427612, 0.22696165, 0.7160172 , 0.79776011,
+            0.9367512 , 0.8537225 , 0.42154581, 0.00543987, 0.03486533],
+           [0.01390537, 0.58890993, 0.3829931 , 0.11481895, 0.86445401,
+            0.82165703, 0.73749168, 0.84034417, 0.4015291 , 0.74862   ],
+           [0.55962945, 0.61323757, 0.29810165, 0.60237917, 0.42567684,
+            0.53854438, 0.48672986, 0.49989164, 0.91745948, 0.26287702]])
     >>> fr = FlowAccumulator(mg, flow_director="D8")
     >>> fsc = FastscapeEroder(mg, K_sp=0.01, m_sp=0.5, n_sp=1)
     >>> for x in range(100):
     ...     fr.run_one_step()
     ...     fsc.run_one_step(dt=10.0)
     ...     mg.at_node["topographic__elevation"][mg.core_nodes] += 0.01
     ...
```

### Comparing `landlab-2.7.0/landlab/components/erosion_deposition/cfuncs.pyx` & `landlab-2.8.0/landlab/components/erosion_deposition/cfuncs.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,9 @@
 import numpy as np
 
-cimport cython
 cimport numpy as np
 
 
 cdef extern from "math.h":
     double exp(double x) nogil
 
 DTYPE_FLOAT = np.double
```

### Comparing `landlab-2.7.0/landlab/components/erosion_deposition/erosion_deposition.py` & `landlab-2.8.0/landlab/components/erosion_deposition/erosion_deposition.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,13 @@
 import numpy as np
 
 from landlab.components.erosion_deposition.generalized_erosion_deposition import (
     DEFAULT_MINIMUM_TIME_STEP,
+)
+from landlab.components.erosion_deposition.generalized_erosion_deposition import (
     _GeneralizedErosionDeposition,
 )
 from landlab.utils.return_array import return_array_at_node
 
 from .cfuncs import calculate_qs_in
 
 ROOT2 = np.sqrt(2.0)  # syntactic sugar for precalculated square root of 2
@@ -254,19 +256,19 @@
         ... )
         >>> fsc_dt = 100.0
         >>> ed_dt = 1.0
 
         Check initial topography
 
         >>> mg.at_node["topographic__elevation"].reshape(mg.shape)
-        array([[ 0.02290479,  1.03606698,  2.0727653 ,  3.01126678,  4.06077707],
-               [ 1.08157495,  2.09812694,  3.00637448,  4.07999597,  5.00969486],
-               [ 2.04008677,  3.06621577,  4.09655859,  5.04809001,  6.02641123],
-               [ 3.05874171,  4.00585786,  5.0595697 ,  6.04425233,  7.05334077],
-               [ 4.05922478,  5.0409473 ,  6.07035008,  7.0038935 ,  8.01034357]])
+        array([[0.02290479, 1.03606698, 2.0727653 , 3.01126678, 4.06077707],
+               [1.08157495, 2.09812694, 3.00637448, 4.07999597, 5.00969486],
+               [2.04008677, 3.06621577, 4.09655859, 5.04809001, 6.02641123],
+               [3.05874171, 4.00585786, 5.0595697 , 6.04425233, 7.05334077],
+               [4.05922478, 5.0409473 , 6.07035008, 7.0038935 , 8.01034357]])
 
         Instantiate Fastscape eroder, flow router, and depression finder
 
         >>> fr = FlowAccumulator(mg, flow_director="D8")
         >>> df = DepressionFinderAndRouter(mg)
         >>> fsc = FastscapeEroder(mg, K_sp=0.001, m_sp=0.5, n_sp=1)
```

### Comparing `landlab-2.7.0/landlab/components/erosion_deposition/generalized_erosion_deposition.py` & `landlab-2.8.0/landlab/components/erosion_deposition/generalized_erosion_deposition.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 import numpy as np
 
-from landlab import Component, RasterModelGrid
+from landlab import Component
+from landlab import RasterModelGrid
 from landlab.utils.return_array import return_array_at_node
 
 from ..depression_finder.lake_mapper import _FLOODED
 
 DEFAULT_MINIMUM_TIME_STEP = 0.001  # default minimum time step duration
 
 
@@ -174,20 +175,20 @@
 
         >>> rg = RasterModelGrid((3, 4))
         >>> z = rg.add_zeros("node", "topographic__elevation")
         >>> z[:] = rg.x_of_node + rg.y_of_node
         >>> fa = FlowAccumulator(rg, flow_director="FlowDirectorD8")
         >>> fa.run_one_step()
         >>> rg.at_node["topographic__steepest_slope"][5:7]
-        array([ 1.41421356,  1.41421356])
+        array([1.41421356, 1.41421356])
         >>> sp = _GeneralizedErosionDeposition(rg, v_s=0.001, m_sp=0.5, n_sp=1.0, F_f=0)
         >>> z *= 0.1
         >>> sp._update_flow_link_slopes()
         >>> rg.at_node["topographic__steepest_slope"][5:7]
-        array([ 0.14142136,  0.14142136])
+        array([0.14142136, 0.14142136])
         """
         self._slope[:] = (
             self._topographic__elevation
             - self._topographic__elevation[self._flow_receivers]
         ) / self._link_lengths[self._link_to_reciever]
 
     def _calc_hydrology(self):
```

### Comparing `landlab-2.7.0/landlab/components/fire_generator/generate_fire.py` & `landlab-2.8.0/landlab/components/fire_generator/generate_fire.py`

 * *Files 0% similar despite different names*

```diff
@@ -62,15 +62,14 @@
 
 from scipy import special
 
 from landlab import Component
 
 
 class FireGenerator(Component):
-
     """Generate a random fire event or time series.
 
     Parameters
     ----------
     mean_fire_recurrence : float
         Average time between fires for a given location
     shape_parameter : float
```

### Comparing `landlab-2.7.0/landlab/components/flexure/cfuncs.pyx` & `landlab-2.8.0/landlab/components/flexure/cfuncs.pyx`

 * *Files 15% similar despite different names*

```diff
@@ -8,79 +8,88 @@
 from libc.stdlib cimport abs
 
 DTYPE = np.double
 ctypedef np.double_t DTYPE_t
 
 
 @cython.boundscheck(False)
-def subside_parallel_row(np.ndarray[DTYPE_t, ndim=1] w,
-                         np.ndarray[DTYPE_t, ndim=1] load,
-                         np.ndarray[DTYPE_t, ndim=1] r,
-                         DTYPE_t alpha,
-                         DTYPE_t gamma_mantle):
-  cdef int ncols = w.shape[0]
-  cdef double inv_c = 1. / (2. * np.pi * gamma_mantle * alpha ** 2.)
-  cdef double c
-  cdef int i
-  cdef int j
-
-  for i in range(ncols):
-    if fabs(load[i]) > 1e-6:
-      c = load[i] * inv_c
-      for j in range(ncols):
-        w[j] += - c * r[abs(j - i)]
-
-
-def subside_grid(np.ndarray[DTYPE_t, ndim=2] w,
-                 np.ndarray[DTYPE_t, ndim=2] load,
-                 np.ndarray[DTYPE_t, ndim=2] r,
-                 DTYPE_t alpha, DTYPE_t gamma_mantle):
-  cdef int nrows = w.shape[0]
-  cdef int i
-  cdef int j
-
-  for i in range(nrows):
-    for j in range(nrows):
-      subside_parallel_row(w[j], load[i], r[abs(j - i)], alpha, gamma_mantle)
-
-
-def subside_grid_strip(np.ndarray[DTYPE_t, ndim=2] load,
-                       np.ndarray[DTYPE_t, ndim=2] r,
-                       DTYPE_t alpha, DTYPE_t gamma_mantle, strip_range):
-  (start, stop) = strip_range
-
-  cdef np.ndarray w = np.zeros((stop - start, load.shape[1]), dtype=DTYPE)
-  cdef i
-
-  for i in range(load.shape[0]):
-    for j in range(start, stop):
-      subside_parallel_row(w[j - start], load[i], r[abs(j - i)], alpha,
-                           gamma_mantle)
+def subside_parallel_row(
+    np.ndarray[DTYPE_t, ndim=1] w,
+    np.ndarray[DTYPE_t, ndim=1] load,
+    np.ndarray[DTYPE_t, ndim=1] r,
+    DTYPE_t alpha,
+    DTYPE_t gamma_mantle,
+):
+    cdef int ncols = w.shape[0]
+    cdef double inv_c = 1. / (2. * np.pi * gamma_mantle * alpha ** 2.)
+    cdef double c
+    cdef int i
+    cdef int j
+
+    for i in range(ncols):
+        if fabs(load[i]) > 1e-6:
+            c = load[i] * inv_c
+            for j in range(ncols):
+                w[j] += - c * r[abs(j - i)]
+
+
+def subside_grid(
+    np.ndarray[DTYPE_t, ndim=2] w,
+    np.ndarray[DTYPE_t, ndim=2] load,
+    np.ndarray[DTYPE_t, ndim=2] r,
+    DTYPE_t alpha, DTYPE_t gamma_mantle,
+):
+    cdef int nrows = w.shape[0]
+    cdef int i
+    cdef int j
+
+    for i in range(nrows):
+        for j in range(nrows):
+            subside_parallel_row(w[j], load[i], r[abs(j - i)], alpha, gamma_mantle)
+
+
+def subside_grid_strip(
+    np.ndarray[DTYPE_t, ndim=2] load,
+    np.ndarray[DTYPE_t, ndim=2] r,
+    DTYPE_t alpha, DTYPE_t gamma_mantle, strip_range,
+):
+    (start, stop) = strip_range
+
+    cdef np.ndarray w = np.zeros((stop - start, load.shape[1]), dtype=DTYPE)
+    cdef i
+
+    for i in range(load.shape[0]):
+        for j in range(start, stop):
+            subside_parallel_row(
+                w[j - start], load[i], r[abs(j - i)], alpha, gamma_mantle
+            )
 
-  return w, strip_range
+    return w, strip_range
 
 
 def tile_grid_into_strips(grid, n_strips):
     rows_per_strip = grid.shape[0] // n_strips
 
     starts = np.arange(0, grid.shape[0], rows_per_strip)
     stops = starts + rows_per_strip
     stops[-1] = grid.shape[0]
 
     return zip(starts, stops)
 
 
 def _subside_grid_strip_helper(args):
-  return subside_grid_strip(*args)
+    return subside_grid_strip(*args)
 
 
-def subside_grid_in_parallel(np.ndarray[DTYPE_t, ndim=2] w,
-                             np.ndarray[DTYPE_t, ndim=2] load,
-                             np.ndarray[DTYPE_t, ndim=2] r,
-                             DTYPE_t alpha, DTYPE_t gamma_mantle, n_procs):
+def subside_grid_in_parallel(
+    np.ndarray[DTYPE_t, ndim=2] w,
+    np.ndarray[DTYPE_t, ndim=2] load,
+    np.ndarray[DTYPE_t, ndim=2] r,
+    DTYPE_t alpha, DTYPE_t gamma_mantle, n_procs,
+):
     if n_procs == 1:
         return subside_grid(w, load, r, alpha, gamma_mantle)
 
     strips = tile_grid_into_strips(w, n_procs)
 
     args = [(load, r, alpha, gamma_mantle, strip) for strip in strips]
```

### Comparing `landlab-2.7.0/landlab/components/flexure/ext/flexure1d.pyx` & `landlab-2.8.0/landlab/components/flexure/ext/flexure1d.pyx`

 * *Files 5% similar despite different names*

```diff
@@ -25,19 +25,17 @@
                     &out[row, 0])
 
 
 @cython.cdivision(True)
 cdef double * subside_row(double * x, int n_points, double * loads,
                           double alpha, double rigidity, double * out) nogil:
     cdef int col
-    cdef double load
 
     for col in range(n_points):
-        subside_point_load(x, n_points, x[col], loads[col], alpha, rigidity,
-                           out)
+        subside_point_load(x, n_points, x[col], loads[col], alpha, rigidity, out)
 
     return out
 
 
 @cython.cdivision(True)
 cdef double * subside_point_load(double * x, int n_points, double x_at_load,
                                  double load, double alpha, double rigidity,
```

### Comparing `landlab-2.7.0/landlab/components/flexure/flexure.py` & `landlab-2.8.0/landlab/components/flexure/flexure.py`

 * *Files 4% similar despite different names*

```diff
@@ -46,30 +46,29 @@
 >>> dh[1:-1, 1:-1] = flex.gamma_mantle
 
 >>> flex.update()
 
 >>> flex.output_var_names
 ('lithosphere_surface__elevation_increment',)
 >>> flex.grid.at_node["lithosphere_surface__elevation_increment"].reshape(grid.shape)
-array([[ 0.,  0.,  0.,  0.],
-       [ 0.,  1.,  1.,  0.],
-       [ 0.,  1.,  1.,  0.],
-       [ 0.,  1.,  1.,  0.],
-       [ 0.,  0.,  0.,  0.]])
+array([[0., 0., 0., 0.],
+       [0., 1., 1., 0.],
+       [0., 1., 1., 0.],
+       [0., 1., 1., 0.],
+       [0., 0., 0., 0.]])
 """
 
 import numpy as np
 
 from landlab import Component
 
 from .funcs import get_flexure_parameter
 
 
 class Flexure(Component):
-
     """Deform the lithosphere with 1D or 2D flexure.
 
     Landlab component that implements a 1 and 2D lithospheric flexure
     model.
 
     Examples
     --------
```

### Comparing `landlab-2.7.0/landlab/components/flexure/flexure_1d.py` & `landlab-2.8.0/landlab/components/flexure/flexure_1d.py`

 * *Files 7% similar despite different names*

```diff
@@ -27,54 +27,53 @@
 In creating the component, a field (initialized with zeros) was
 added to the grid that represents the current loading distribution.
 If the grid already had this field, the component would use the
 existing field. This can be accessed either through the *grid*
 attribute in the same way as other landlab fields,
 
 >>> flex.grid.at_node["lithosphere__increment_of_overlying_pressure"]
-array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
+array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
 
 or through the `load_at_node` attribute of `Flexure1D`,
 
 >>> flex.load_at_node
-array([[ 0.,  0.,  0.,  0.],
-       [ 0.,  0.,  0.,  0.],
-       [ 0.,  0.,  0.,  0.]])
+array([[0., 0., 0., 0.],
+       [0., 0., 0., 0.],
+       [0., 0., 0., 0.]])
 
 Notice that `load_at_node` returns a reshaped view of the array
 whereas the field returns a flattened array. Change values in this
 array to add loads to the grid,
 
 >>> flex.load_at_node[1, 2:4] = flex.gamma_mantle
 >>> flex.run_one_step()
 
 The output deflections can be retrieved either using landlab fields
 as,
 
 >>> flex.grid.at_node["lithosphere_surface__increment_of_elevation"]
-array([ 0.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  0.,  0.])
+array([0., 0., 0., 0., 0., 0., 1., 1., 0., 0., 0., 0.])
 
 or through the `dz_at_node` attribute,
 
 >>> flex.dz_at_node
-array([[ 0.,  0.,  0.,  0.],
-       [ 0.,  0.,  1.,  1.],
-       [ 0.,  0.,  0.,  0.]])
+array([[0., 0., 0., 0.],
+       [0., 0., 1., 1.],
+       [0., 0., 0., 0.]])
 """
 import contextlib
 
 import numpy as np
 
 from landlab import Component
 
 from .ext import subside_load_1d
 
 
 class Flexure1D(Component):
-
     """Deform the lithosphere with 1D flexure.
 
     Landlab component that implements a 1D lithospheric flexure model.
 
     Parameters
     ----------
     grid : RasterModelGrid
```

### Comparing `landlab-2.7.0/landlab/components/flexure/funcs.py` & `landlab-2.8.0/landlab/components/flexure/funcs.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/flow_accum/cfuncs.pyx` & `landlab-2.8.0/landlab/components/flow_accum/cfuncs.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -7,19 +7,21 @@
 ctypedef np.int_t DTYPE_INT_t
 
 DTYPE_FLOAT = np.double
 ctypedef np.double_t DTYPE_FLOAT_t
 
 
 @cython.boundscheck(False)
-cpdef _add_to_stack(DTYPE_INT_t l, DTYPE_INT_t j,
-                    np.ndarray[DTYPE_INT_t, ndim=1] s,
-                    np.ndarray[DTYPE_INT_t, ndim=1] delta,
-                    np.ndarray[DTYPE_INT_t, ndim=1] donors):
-
+cpdef _add_to_stack(
+    DTYPE_INT_t l,
+    DTYPE_INT_t j,
+    np.ndarray[DTYPE_INT_t, ndim=1] s,
+    np.ndarray[DTYPE_INT_t, ndim=1] delta,
+    np.ndarray[DTYPE_INT_t, ndim=1] donors,
+):
     """
     Adds node l to the stack and increments the current index (j).
     """
     cdef int m, n, delta_l, delta_lplus1
 
     s[j] = l
     j += 1
@@ -31,92 +33,100 @@
         if m != l:
             j = _add_to_stack(m, j, s, delta, donors)
 
     return j
 
 
 @cython.boundscheck(False)
-cpdef _accumulate_to_n(DTYPE_INT_t np, DTYPE_INT_t q,
-                       np.ndarray[DTYPE_INT_t, ndim=1] s,
-                       np.ndarray[DTYPE_INT_t, ndim=2] r,
-                       np.ndarray[DTYPE_FLOAT_t, ndim=2] p,
-                       np.ndarray[DTYPE_FLOAT_t, ndim=1] drainage_area,
-                       np.ndarray[DTYPE_FLOAT_t, ndim=1] discharge):
+cpdef _accumulate_to_n(
+    DTYPE_INT_t size,
+    DTYPE_INT_t q,
+    np.ndarray[DTYPE_INT_t, ndim=1] s,
+    np.ndarray[DTYPE_INT_t, ndim=2] r,
+    np.ndarray[DTYPE_FLOAT_t, ndim=2] p,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] drainage_area,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] discharge,
+):
     """
     Accumulates drainage area and discharge, permitting transmission losses.
     """
     cdef int donor, recvr, i, v
     cdef float accum, proportion
 
     # Iterate backward through the list, which means we work from upstream to
     # downstream.
-    for i in range(np-1, -1, -1):
+    for i in range(size - 1, -1, -1):
         donor = s[i]
         for v in range(q):
             recvr = r[donor, v]
             proportion = p[donor, v]
             if proportion > 0.:
                 if donor != recvr:
                     drainage_area[recvr] += proportion*drainage_area[donor]
                     accum = discharge[recvr] + proportion*discharge[donor]
                     if accum < 0.:
                         accum = 0.
                     discharge[recvr] = accum
 
 
 @cython.boundscheck(False)
-cpdef _accumulate_bw(DTYPE_INT_t np,
-                     np.ndarray[DTYPE_INT_t, ndim=1] s,
-                     np.ndarray[DTYPE_INT_t, ndim=1] r,
-                     np.ndarray[DTYPE_FLOAT_t, ndim=1] drainage_area,
-                     np.ndarray[DTYPE_FLOAT_t, ndim=1] discharge):
+cpdef _accumulate_bw(
+    DTYPE_INT_t size,
+    np.ndarray[DTYPE_INT_t, ndim=1] s,
+    np.ndarray[DTYPE_INT_t, ndim=1] r,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] drainage_area,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] discharge,
+):
     """
     Accumulates drainage area and discharge, permitting transmission losses.
     """
     cdef int donor, recvr, i
     cdef float accum
 
     # Iterate backward through the list, which means we work from upstream to
     # downstream.
-    for i in range(np-1, -1, -1):
+    for i in range(size - 1, -1, -1):
         donor = s[i]
         recvr = r[donor]
         if donor != recvr:
             drainage_area[recvr] += drainage_area[donor]
             accum = discharge[recvr] + discharge[donor]
             if accum < 0.:
                 accum = 0.
             discharge[recvr] = accum
 
 
 @cython.boundscheck(False)
-cpdef _make_donors(DTYPE_INT_t np,
-                   np.ndarray[DTYPE_INT_t, ndim=1] w,
-                   np.ndarray[DTYPE_INT_t, ndim=1] D,
-                   np.ndarray[DTYPE_INT_t, ndim=1] delta,
-                   np.ndarray[DTYPE_INT_t, ndim=1] r):
+cpdef _make_donors(
+    DTYPE_INT_t size,
+    np.ndarray[DTYPE_INT_t, ndim=1] w,
+    np.ndarray[DTYPE_INT_t, ndim=1] D,
+    np.ndarray[DTYPE_INT_t, ndim=1] delta,
+    np.ndarray[DTYPE_INT_t, ndim=1] r,
+):
     """Determines number of donors"""
     cdef int ri, i
-    for i in range(np):
+    for i in range(size):
         ri = r[i]
         D[delta[ri] + w[ri]] = i
         w[ri] += 1
 
 
 @cython.boundscheck(False)
-cpdef _make_donors_to_n(DTYPE_INT_t np,
-                  DTYPE_INT_t q,
-                  np.ndarray[DTYPE_INT_t, ndim=1] w,
-                  np.ndarray[DTYPE_INT_t, ndim=1] D,
-                  np.ndarray[DTYPE_INT_t, ndim=1] delta,
-                  np.ndarray[DTYPE_INT_t, ndim=2] r,
-                  np.ndarray[DTYPE_FLOAT_t, ndim=2] p,
-                  ):
+cpdef _make_donors_to_n(
+    DTYPE_INT_t size,
+    DTYPE_INT_t q,
+    np.ndarray[DTYPE_INT_t, ndim=1] w,
+    np.ndarray[DTYPE_INT_t, ndim=1] D,
+    np.ndarray[DTYPE_INT_t, ndim=1] delta,
+    np.ndarray[DTYPE_INT_t, ndim=2] r,
+    np.ndarray[DTYPE_FLOAT_t, ndim=2] p,
+):
     """Determines number of donors for route to n"""
     cdef int ri, i, v, ind
     for v in range(q):
-        for i in range(np):
+        for i in range(size):
             ri = r[i, v]
             if p[i, v] > 0:
                 ind = delta[ri] + w[ri]
                 D[ind] = i
                 w[ri] += 1
```

### Comparing `landlab-2.7.0/landlab/components/flow_accum/flow_accum_bw.py` & `landlab-2.8.0/landlab/components/flow_accum/flow_accum_bw.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,19 +24,20 @@
 
 Created: GT Nov 2013
 """
 import numpy
 
 from landlab.core.utils import as_id_array
 
-from .cfuncs import _accumulate_bw, _add_to_stack, _make_donors
+from .cfuncs import _accumulate_bw
+from .cfuncs import _add_to_stack
+from .cfuncs import _make_donors
 
 
 class _DrainageStack:
-
     """Implements Braun & Willett's add_to_stack function.
 
     The _DrainageStack() class implements Braun & Willett's add_to_stack
     function (as a method) and also keeps track of the counter (j) and
     the stack (s). It is used by the make_ordered_node_array() function.
     """
 
@@ -353,17 +354,17 @@
     >>> def lossfunc(Qw, dummyn, dummyl, dummygrid):
     ...     return 0.5 * Qw
     ...
     >>> mg = RasterModelGrid((3, 4))  # some grid big enough to make go
     >>> _ = mg.add_zeros("node", "surface_water__discharge_loss", dtype=float)
     >>> a, q = find_drainage_area_and_discharge_lossy(s, r, l, lossfunc, mg)
     >>> a
-    array([  1.,   3.,   1.,   1.,  10.,   4.,   3.,   2.,   1.,   1.])
+    array([ 1.,  3.,  1.,  1., 10.,  4.,  3.,  2.,  1.,  1.])
     >>> q
-    array([  1.  ,   2.  ,   1.  ,   1.  ,  3.75,   2.  ,   2.  ,   1.5 ,   1.  ,   1.  ])
+    array([1.  , 2.  , 1.  , 1.  , 3.75, 2.  , 2.  , 1.5 , 1.  , 1.  ])
     >>> np.allclose(
     ...     mg.at_node["surface_water__discharge_loss"][nodes_wo_outlet],
     ...     0.5 * q[nodes_wo_outlet],
     ... )
     True
     >>> np.isclose(mg.at_node["surface_water__discharge_loss"][4], 0.0)
     True
@@ -371,31 +372,31 @@
     >>> lossfield = mg.add_ones("loss_field", at="node", dtype=float)
     >>> lossfield *= 0.5
     >>> def lossfunc2(Qw, nodeID, dummyl, grid):
     ...     return grid.at_node["loss_field"][nodeID] * Qw
     ...
     >>> a, q = find_drainage_area_and_discharge_lossy(s, r, l, lossfunc2, mg)
     >>> a
-    array([  1.,   3.,   1.,   1.,  10.,   4.,   3.,   2.,   1.,   1.])
+    array([ 1.,  3.,  1.,  1., 10.,  4.,  3.,  2.,  1.,  1.])
     >>> q
-    array([  1.  ,   2.  ,   1.  ,   1.  ,  3.75,   2.  ,   2.  ,   1.5 ,   1.  ,   1.  ])
+    array([1.  , 2.  , 1.  , 1.  , 3.75, 2.  , 2.  , 1.5 , 1.  , 1.  ])
     >>> np.allclose(
     ...     mg.at_node["surface_water__discharge_loss"][nodes_wo_outlet],
     ...     lossfield[nodes_wo_outlet] * q[nodes_wo_outlet],
     ... )
     True
 
     >>> def lossfunc3(Qw, nodeID, dummyl, dummygrid):
     ...     return Qw - 100.0  # a huge loss
     ...
     >>> a, q = find_drainage_area_and_discharge_lossy(s, r, l, lossfunc3, mg)
     >>> a
-    array([  1.,   3.,   1.,   1.,  10.,   4.,   3.,   2.,   1.,   1.])
+    array([ 1.,  3.,  1.,  1., 10.,  4.,  3.,  2.,  1.,  1.])
     >>> q
-    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
+    array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])
     """
     # Number of points
     np = len(s)
 
     # Initialize the drainage_area and discharge arrays. Drainage area starts
     # out as the area of the cell in question, then (unless the cell has no
     # donors) grows from there. Discharge starts out as the cell's local runoff
```

### Comparing `landlab-2.7.0/landlab/components/flow_accum/flow_accum_to_n.py` & `landlab-2.8.0/landlab/components/flow_accum/flow_accum_to_n.py`

 * *Files 1% similar despite different names*

```diff
@@ -46,19 +46,19 @@
 
 Created: KRB Oct 2016 (modified from flow_accumu_bw)
 """
 import numpy
 
 from landlab.core.utils import as_id_array
 
-from .cfuncs import _accumulate_to_n, _make_donors_to_n
+from .cfuncs import _accumulate_to_n
+from .cfuncs import _make_donors_to_n
 
 
 class _DrainageStack_to_n:
-
     """Implementation of the DrainageStack_to_n class.
 
     The _DrainageStack_to_n() class implements a set based approach to
     constructing a stack with similar properties to the stack constructed by
     Braun & Willet (2013). It constructs an list, s, of all nodes in the grid
     such that a given node is always located earlier in the list than all
     upstream nodes that contribute to it.
@@ -649,33 +649,33 @@
     >>> lossy *= 0.5
     >>> def lossfunc(Qw, dummyn, linkID, grid):
     ...     return grid.at_link["lossy"][linkID] * Qw
     ...
 
     >>> a, q = find_drainage_area_and_discharge_to_n_lossy(s, r, l, p, lossfunc, mg)
     >>> a
-    array([ 1. ,  2.7,  1.5,  4. ])
+    array([1. , 2.7, 1.5, 4. ])
     >>> q
-    array([ 1.  ,  1.75,  1.25,  2.  ])
+    array([1.  , 1.75, 1.25, 2.  ])
     >>> np.allclose(mg.at_node["surface_water__discharge_loss"][:3], 0.5 * q[:3])
     True
 
     Note by definition no loss is occuring at the outlet node, as there are no
     nodes downstream.
 
     Final example of total transmission loss:
 
     >>> def lossfunc(Qw, dummyn, dummyl, dummygrid):
     ...     return Qw - 100.0  # huge loss
     ...
     >>> a, q = find_drainage_area_and_discharge_to_n_lossy(s, r, l, p, lossfunc, mg)
     >>> a
-    array([ 1. ,  2.7,  1.5,  4. ])
+    array([1. , 2.7, 1.5, 4. ])
     >>> q
-    array([ 1.,  1.,  1.,  1.])
+    array([1., 1., 1., 1.])
     """
     # Number of points
     np = r.shape[0]
     q = r.shape[1]
 
     # Initialize the drainage_area and discharge arrays. Drainage area starts
     # out as the area of the cell in question, then (unless the cell has no
```

### Comparing `landlab-2.7.0/landlab/components/flow_accum/flow_accumulator.py` & `landlab-2.8.0/landlab/components/flow_accum/flow_accumulator.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,33 +9,31 @@
 directing, depression finding, and flow routing can all be accomplished
 together.
 """
 
 
 import numpy as np
 
-from landlab import (  # for type tests
-    Component,
-    FieldError,
-    NetworkModelGrid,
-    RasterModelGrid,
-    VoronoiDelaunayGrid,
-)
-from landlab.components.flow_accum import flow_accum_bw, flow_accum_to_n
+from landlab import Component  # for type tests
+from landlab import FieldError
+from landlab import NetworkModelGrid
+from landlab import RasterModelGrid
+from landlab import VoronoiDelaunayGrid
+from landlab.components.flow_accum import flow_accum_bw
+from landlab.components.flow_accum import flow_accum_to_n
 from landlab.core.messages import warning_message
 from landlab.core.utils import as_id_array
 from landlab.utils.return_array import return_array_at_node
 
 from ..depression_finder.floodstatus import FloodStatus
 
 _UNFLOODED = FloodStatus._UNFLOODED
 
 
 class FlowAccumulator(Component):
-
     """Component to accumulate flow and calculate drainage area.
 
     This is accomplished by first finding flow directions by a user-specified
     method and then calculating the drainage area and discharge.
 
     Optionally, spatially variable runoff can be set either by the model grid
     field 'water__unit_flux_in' or the input variable *runoff_rate**.
@@ -173,15 +171,15 @@
     ... )
 
     Now let's look at what FlowAccumulator does. Even before we run
     FlowAccumulator it has the property `surface_values` that stores the values
     of the surface over which flow is directed and accumulated.
 
     >>> fa.surface_values
-    array([ 0.,  1.,  2.,  1.,  2.,  3.,  2.,  3.,  4.])
+    array([0., 1., 2., 1., 2., 3., 2., 3., 4.])
 
     Now let's make a more complicated elevation grid for the next examples.
 
     >>> mg = RasterModelGrid((5, 4))
     >>> topographic__elevation = [
     ...     [0.0, 0.0, 0.0, 0.0],
     ...     [0.0, 21.0, 10.0, 0.0],
@@ -198,19 +196,19 @@
     >>> mg.at_node["flow__receiver_node"].reshape(mg.shape)
     array([[ 0,  1,  2,  3],
            [ 4,  1,  2,  7],
            [ 8, 10,  6, 11],
            [12, 14, 10, 15],
            [16, 17, 18, 19]])
     >>> mg.at_node["drainage_area"].reshape(mg.shape)
-    array([[ 0.,  1.,  5.,  0.],
-           [ 0.,  1.,  5.,  0.],
-           [ 0.,  1.,  4.,  0.],
-           [ 0.,  1.,  2.,  0.],
-           [ 0.,  0.,  0.,  0.]])
+    array([[0., 1., 5., 0.],
+           [0., 1., 5., 0.],
+           [0., 1., 4., 0.],
+           [0., 1., 2., 0.],
+           [0., 0., 0., 0.]])
 
     Now let's change the cell area (100.) and the runoff rates:
 
     >>> mg = RasterModelGrid((5, 4), xy_spacing=(10.0, 10))
 
     Put the data back into the new grid.
 
@@ -219,48 +217,48 @@
     >>> fa = FlowAccumulator(
     ...     mg, "topographic__elevation", flow_director=FlowDirectorSteepest
     ... )
     >>> runoff_rate = np.arange(mg.number_of_nodes, dtype=float)
     >>> rnff = mg.add_field("water__unit_flux_in", runoff_rate, at="node", clobber=True)
     >>> fa.run_one_step()
     >>> mg.at_node["surface_water__discharge"].reshape(mg.shape)
-    array([[    0.,   500.,  5200.,     0.],
-           [    0.,   500.,  5200.,     0.],
-           [    0.,   900.,  4600.,     0.],
-           [    0.,  1300.,  2700.,     0.],
-           [    0.,     0.,     0.,     0.]])
+    array([[   0.,  500.,  5200.,    0.],
+           [   0.,  500.,  5200.,    0.],
+           [   0.,  900.,  4600.,    0.],
+           [   0., 1300.,  2700.,    0.],
+           [   0.,    0.,     0.,    0.]])
 
     The flow accumulator will happily work with a negative runoff rate, which
     could be used to allow, e.g., transmission losses:
 
     >>> runoff_rate.fill(1.0)
     >>> fa.run_one_step()
     >>> mg.at_node["surface_water__discharge"].reshape(mg.shape)
-    array([[   0.,  100.,  500.,    0.],
-           [   0.,  100.,  500.,    0.],
-           [   0.,  100.,  400.,    0.],
-           [   0.,  100.,  200.,    0.],
-           [   0.,    0.,    0.,    0.]])
+    array([[  0., 100., 500.,   0.],
+           [  0., 100., 500.,   0.],
+           [  0., 100., 400.,   0.],
+           [  0., 100., 200.,   0.],
+           [  0.,   0.,   0.,   0.]])
     >>> runoff_rate[:8] = -0.5
     >>> fa.run_one_step()
     >>> mg.at_node["surface_water__discharge"].reshape(mg.shape)
-    array([[   0.,    0.,  350.,    0.],
-           [   0.,    0.,  350.,    0.],
-           [   0.,  100.,  400.,    0.],
-           [   0.,  100.,  200.,    0.],
-           [   0.,    0.,    0.,    0.]])
+    array([[  0.,   0., 350.,   0.],
+           [  0.,   0., 350.,   0.],
+           [  0., 100., 400.,   0.],
+           [  0., 100., 200.,   0.],
+           [  0.,   0.,   0.,   0.]])
 
     The drainage area array is unaffected, as you would expect:
 
     >>> mg.at_node["drainage_area"].reshape(mg.shape)
-    array([[   0.,  100.,  500.,    0.],
-           [   0.,  100.,  500.,    0.],
-           [   0.,  100.,  400.,    0.],
-           [   0.,  100.,  200.,    0.],
-           [   0.,    0.,    0.,    0.]])
+    array([[  0., 100., 500.,   0.],
+           [  0., 100., 500.,   0.],
+           [  0., 100., 400.,   0.],
+           [  0., 100., 200.,   0.],
+           [  0.,   0.,   0.,   0.]])
 
     The FlowAccumulator component will work for both raster grids and irregular
     grids. For the example we will use a Hexagonal Model Grid, a special type
     of Voroni Grid that has regularly spaced hexagonal cells.
 
     >>> from landlab import HexModelGrid
     >>> hmg = HexModelGrid((5, 3), xy_of_lower_left=(-1.0, 0.0))
@@ -269,19 +267,19 @@
     ...     hmg.node_x + np.round(hmg.node_y),
     ...     at="node",
     ... )
     >>> fa = FlowAccumulator(
     ...     hmg, "topographic__elevation", flow_director=FlowDirectorSteepest
     ... )
     >>> fa.surface_values
-    array([ 0. ,  1. ,  2. ,
-            0.5,  1.5,  2.5,  3.5,
-            1. ,  2. ,  3. ,  4. ,  5. ,
-            2.5,  3.5,  4.5,  5.5,
-            3. ,  4. ,  5. ])
+    array([0. , 1. , 2. ,
+           0.5, 1.5, 2.5, 3.5,
+           1. , 2. , 3. , 4. , 5. ,
+           2.5, 3.5, 4.5, 5.5,
+           3. , 4. , 5. ])
 
     If the FlowDirector you want to use takes keyword arguments and you want
     to specify it using a string or uninstantiated FlowDirector class, include
     those keyword arguments when you create FlowAccumulator.
 
     For example, in the case of a raster grid, FlowDirectorMFD can use only
     orthogonal links, or it can use both orthogonal and diagonal links.
@@ -316,19 +314,19 @@
            [19, -1, -1, -1, -1, -1, -1, -1],
            [20, -1, -1, -1, -1, -1, -1, -1],
            [21, -1, -1, -1, -1, -1, -1, -1],
            [22, -1, -1, -1, -1, -1, -1, -1],
            [23, -1, -1, -1, -1, -1, -1, -1],
            [24, -1, -1, -1, -1, -1, -1, -1]])
     >>> mg.at_node["drainage_area"].round(4).reshape(mg.shape)
-    array([[ 1.4117,  2.065 ,  1.3254,  0.4038,  0.    ],
-           [ 2.065 ,  3.4081,  2.5754,  1.3787,  0.    ],
-           [ 1.3254,  2.5754,  2.1716,  1.2929,  0.    ],
-           [ 0.4038,  1.3787,  1.2929,  1.    ,  0.    ],
-           [ 0.    ,  0.    ,  0.    ,  0.    ,  0.    ]])
+    array([[1.4117, 2.065 , 1.3254, 0.4038, 0.    ],
+           [2.065 , 3.4081, 2.5754, 1.3787, 0.    ],
+           [1.3254, 2.5754, 2.1716, 1.2929, 0.    ],
+           [0.4038, 1.3787, 1.2929, 1.    , 0.    ],
+           [0.    , 0.    , 0.    , 0.    , 0.    ]])
 
     It may seem odd that there are no round numbers in the drainage area field.
     This is because flow is directed to all downhill boundary nodes and
     partitioned based on slope.
 
     To check that flow is conserved, sum along all boundary nodes.
 
@@ -357,19 +355,19 @@
     >>> hmg.at_node["flow__receiver_node"]
     array([ 0,  1,  2,
             3,  0,  1,  6,
             7,  3,  4,  5, 11,
            12,  8,  9, 15,
            16, 17, 18])
     >>> np.round(hmg.at_node["drainage_area"])
-    array([ 3.,  2.,  0.,
-            2.,  3.,  2.,  0.,
-            0.,  2.,  2.,  1.,  0.,
-            0., 1.,  1.,  0.,
-            0.,  0.,  0.])
+    array([3., 2., 0.,
+           2., 3., 2., 0.,
+           0., 2., 2., 1., 0.,
+           0., 1., 1., 0.,
+           0., 0., 0.])
 
     Now let's change the cell area (100.) and the runoff rates:
 
     >>> hmg = HexModelGrid((5, 3), spacing=dx * 10.0, xy_of_lower_left=(-10.745, 0.0))
 
     Put the data back into the new grid.
 
@@ -379,58 +377,58 @@
     ...     at="node",
     ... )
     >>> fa = FlowAccumulator(
     ...     hmg, "topographic__elevation", flow_director=FlowDirectorSteepest
     ... )
     >>> fa.run_one_step()
     >>> np.round(hmg.at_node["surface_water__discharge"])
-    array([ 500.,    0.,    0.,
-            200.,  500.,  200.,    0.,
-              0.,  200.,  200.,  100.,    0.,
-              0.,  100.,  100.,    0.,
-              0.,    0.,    0.])
+    array([500.,   0.,   0.,
+           200., 500., 200.,   0.,
+             0., 200., 200., 100.,   0.,
+             0., 100., 100.,   0.,
+             0.,   0.,   0.])
 
     Next, let's see what happens to a raster grid when there is a depression.
 
     >>> mg = RasterModelGrid((7, 7), xy_spacing=0.5)
     >>> z = mg.add_field("topographic__elevation", mg.node_x.copy(), at="node")
     >>> z += 0.01 * mg.node_y
     >>> mg.at_node["topographic__elevation"].reshape(mg.shape)[2:5, 2:5] *= 0.1
     >>> mg.set_closed_boundaries_at_grid_edges(True, True, False, True)
 
     This model grid has a depression in the center.
 
     >>> mg.at_node["topographic__elevation"].reshape(mg.shape)
-    array([[ 0.    ,  0.5   ,  1.    ,  1.5   ,  2.    ,  2.5   ,  3.    ],
-           [ 0.005 ,  0.505 ,  1.005 ,  1.505 ,  2.005 ,  2.505 ,  3.005 ],
-           [ 0.01  ,  0.51  ,  0.101 ,  0.151 ,  0.201 ,  2.51  ,  3.01  ],
-           [ 0.015 ,  0.515 ,  0.1015,  0.1515,  0.2015,  2.515 ,  3.015 ],
-           [ 0.02  ,  0.52  ,  0.102 ,  0.152 ,  0.202 ,  2.52  ,  3.02  ],
-           [ 0.025 ,  0.525 ,  1.025 ,  1.525 ,  2.025 ,  2.525 ,  3.025 ],
-           [ 0.03  ,  0.53  ,  1.03  ,  1.53  ,  2.03  ,  2.53  ,  3.03  ]])
+    array([[0.    , 0.5   , 1.    , 1.5   , 2.    , 2.5   , 3.    ],
+           [0.005 , 0.505 , 1.005 , 1.505 , 2.005 , 2.505 , 3.005 ],
+           [0.01  , 0.51  , 0.101 , 0.151 , 0.201 , 2.51  , 3.01  ],
+           [0.015 , 0.515 , 0.1015, 0.1515, 0.2015, 2.515 , 3.015 ],
+           [0.02  , 0.52  , 0.102 , 0.152 , 0.202 , 2.52  , 3.02  ],
+           [0.025 , 0.525 , 1.025 , 1.525 , 2.025 , 2.525 , 3.025 ],
+           [0.03  , 0.53  , 1.03  , 1.53  , 2.03  , 2.53  , 3.03  ]])
     >>> fa = FlowAccumulator(
     ...     mg, "topographic__elevation", flow_director=FlowDirectorSteepest
     ... )
     >>> fa.run_one_step()  # the flow "gets stuck" in the hole
     >>> mg.at_node["flow__receiver_node"].reshape(mg.shape)
     array([[ 0,  1,  2,  3,  4,  5,  6],
            [ 7,  7, 16, 17, 18, 11, 13],
            [14, 14, 16, 16, 17, 18, 20],
            [21, 21, 16, 23, 24, 25, 27],
            [28, 28, 23, 30, 31, 32, 34],
            [35, 35, 30, 31, 32, 39, 41],
            [42, 43, 44, 45, 46, 47, 48]])
     >>> mg.at_node["drainage_area"].reshape(mg.shape)
-    array([[ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ],
-           [ 0.25,  0.25,  0.25,  0.25,  0.5 ,  0.25,  0.  ],
-           [ 0.25,  0.25,  5.  ,  1.5 ,  1.  ,  0.25,  0.  ],
-           [ 0.25,  0.25,  3.  ,  0.75,  0.5 ,  0.25,  0.  ],
-           [ 0.25,  0.25,  2.  ,  1.5 ,  1.  ,  0.25,  0.  ],
-           [ 0.25,  0.25,  0.25,  0.25,  0.5 ,  0.25,  0.  ],
-           [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ]])
+    array([[0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
+           [0.25, 0.25, 0.25, 0.25, 0.5 , 0.25, 0.  ],
+           [0.25, 0.25, 5.  , 1.5 , 1.  , 0.25, 0.  ],
+           [0.25, 0.25, 3.  , 0.75, 0.5 , 0.25, 0.  ],
+           [0.25, 0.25, 2.  , 1.5 , 1.  , 0.25, 0.  ],
+           [0.25, 0.25, 0.25, 0.25, 0.5 , 0.25, 0.  ],
+           [0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ]])
 
     Because of the depression, the flow 'got stuck' in the hole in the center
     of the grid. We can fix this by using a depression finder, such as
     DepressionFinderAndRouter.
 
     >>> from landlab.components import DepressionFinderAndRouter
 
@@ -449,48 +447,48 @@
            [ 7,  7, 16, 17, 18, 11, 13],
            [14, 14,  8, 16, 17, 18, 20],
            [21, 21, 16, 16, 24, 25, 27],
            [28, 28, 23, 24, 24, 32, 34],
            [35, 35, 30, 31, 32, 39, 41],
            [42, 43, 44, 45, 46, 47, 48]])
     >>> mg.at_node["drainage_area"].reshape(mg.shape)
-    array([[ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ],
-           [ 5.25,  5.25,  0.25,  0.25,  0.5 ,  0.25,  0.  ],
-           [ 0.25,  0.25,  5.  ,  1.5 ,  1.  ,  0.25,  0.  ],
-           [ 0.25,  0.25,  0.75,  2.25,  0.5 ,  0.25,  0.  ],
-           [ 0.25,  0.25,  0.5 ,  0.5 ,  1.  ,  0.25,  0.  ],
-           [ 0.25,  0.25,  0.25,  0.25,  0.5 ,  0.25,  0.  ],
-           [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ]])
+    array([[0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
+           [5.25, 5.25, 0.25, 0.25, 0.5 , 0.25, 0.  ],
+           [0.25, 0.25, 5.  , 1.5 , 1.  , 0.25, 0.  ],
+           [0.25, 0.25, 0.75, 2.25, 0.5 , 0.25, 0.  ],
+           [0.25, 0.25, 0.5 , 0.5 , 1.  , 0.25, 0.  ],
+           [0.25, 0.25, 0.25, 0.25, 0.5 , 0.25, 0.  ],
+           [0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ]])
 
     Now the flow is routed correctly. The depression finder has properties that
     including whether there is a lake at the node, which lake is at each node,
     the outlet node of each lake, and the area of each lake.
 
     >>> df_4.lake_at_node.reshape(mg.shape)
     array([[False, False, False, False, False, False, False],
            [False, False, False, False, False, False, False],
            [False, False,  True,  True,  True, False, False],
            [False, False,  True,  True,  True, False, False],
            [False, False,  True,  True,  True, False, False],
            [False, False, False, False, False, False, False],
-           [False, False, False, False, False, False, False]], dtype=bool)
+           [False, False, False, False, False, False, False]])
     >>> df_4.lake_map.reshape(mg.shape)
     array([[-1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1],
            [-1, -1, 16, 16, 16, -1, -1],
            [-1, -1, 16, 16, 16, -1, -1],
            [-1, -1, 16, 16, 16, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1]])
     >>> df_4.lake_codes  # a unique code for each lake present on the grid
     array([16])
     >>> df_4.lake_outlets  # the outlet node of each lake in lake_codes
     array([8])
     >>> df_4.lake_areas  # the area of each lake in lake_codes
-    array([ 2.25])
+    array([2.25])
 
     Alternatively, we can initialize a flow accumulator with a depression
     finder specified. Calling run_one_step() will run both the accumulator
     and the depression finder with one call. For this example, we will pass the
     class DepressionFinderAndRouter to the parameter `depression_finder`.
 
     >>> mg = RasterModelGrid((7, 7), xy_spacing=0.5)
@@ -513,47 +511,47 @@
            [ 7,  7, 16, 17, 18, 18, 13],
            [14, 14,  8, 16, 17, 18, 20],
            [21, 21, 16, 16, 24, 25, 27],
            [28, 28, 23, 24, 24, 32, 34],
            [35, 35, 30, 31, 32, 32, 41],
            [42, 43, 44, 45, 46, 47, 48]])
     >>> mg.at_node["drainage_area"].reshape(mg.shape)
-    array([[ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ],
-           [ 5.25,  5.25,  0.25,  0.25,  0.25,  0.25,  0.  ],
-           [ 0.25,  0.25,  5.  ,  1.5 ,  1.  ,  0.25,  0.  ],
-           [ 0.25,  0.25,  0.75,  2.25,  0.5 ,  0.25,  0.  ],
-           [ 0.25,  0.25,  0.5 ,  0.5 ,  1.  ,  0.25,  0.  ],
-           [ 0.25,  0.25,  0.25,  0.25,  0.25,  0.25,  0.  ],
-           [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ]])
+    array([[0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
+           [5.25, 5.25, 0.25, 0.25, 0.25, 0.25, 0.  ],
+           [0.25, 0.25, 5.  , 1.5 , 1.  , 0.25, 0.  ],
+           [0.25, 0.25, 0.75, 2.25, 0.5 , 0.25, 0.  ],
+           [0.25, 0.25, 0.5 , 0.5 , 1.  , 0.25, 0.  ],
+           [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.  ],
+           [0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ]])
 
     The depression finder is stored as part of the flow accumulator, so its
     properties can be accessed through the depression finder.
 
     >>> fa.depression_finder.lake_at_node.reshape(mg.shape)
     array([[False, False, False, False, False, False, False],
            [False, False, False, False, False, False, False],
            [False, False,  True,  True,  True, False, False],
            [False, False,  True,  True,  True, False, False],
            [False, False,  True,  True,  True, False, False],
            [False, False, False, False, False, False, False],
-           [False, False, False, False, False, False, False]], dtype=bool)
+           [False, False, False, False, False, False, False]])
     >>> fa.depression_finder.lake_map.reshape(mg.shape)
     array([[-1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1],
            [-1, -1, 16, 16, 16, -1, -1],
            [-1, -1, 16, 16, 16, -1, -1],
            [-1, -1, 16, 16, 16, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1]])
     >>> fa.depression_finder.lake_codes  # a unique code for each lake present on the grid
     array([16])
     >>> fa.depression_finder.lake_outlets  # the outlet node of each lake in lake_codes
     array([8])
     >>> fa.depression_finder.lake_areas  # the area of each lake in lake_codes
-    array([ 2.25])
+    array([2.25])
 
     Finally, note that the DepressionFinderAndRouter takes a keyword argument
     *routing* ('D8', default; 'D4') that sets how connectivity is set between
     nodes. Similar to our ability to pass keyword arguments to the FlowDirector
     through FlowAccumulator, we can pass this keyword argument to the
     DepressionFinderAndRouter component.
 
@@ -803,19 +801,19 @@
         >>> np.flipud(
         ...     mg.add_field(
         ...         "topographic__elevation",
         ...         mg.node_x + mg.node_y,
         ...         at="node",
         ...     ).reshape(mg.shape)
         ... )
-        array([[ 4.,  5.,  6.,  7.,  8.],
-               [ 3.,  4.,  5.,  6.,  7.],
-               [ 2.,  3.,  4.,  5.,  6.],
-               [ 1.,  2.,  3.,  4.,  5.],
-               [ 0.,  1.,  2.,  3.,  4.]])
+        array([[4., 5., 6., 7., 8.],
+               [3., 4., 5., 6., 7.],
+               [2., 3., 4., 5., 6.],
+               [1., 2., 3., 4., 5.],
+               [0., 1., 2., 3., 4.]])
         >>> fa = FlowAccumulator(mg, "topographic__elevation", flow_director="MFD")
         >>> fa.run_one_step()
         >>> link_order = fa.link_order_upstream()
         >>> link_order  # doctest: +SKIP
         array([ 5, 14, 10,  6, 11,  7, 23, 19, 15, 20, 16, 28, 24, 29, 25])
         >>> link_order[0]
         5
@@ -901,20 +899,18 @@
                 kw[p_k] = self._kwargs.pop(p_k)
 
         # flow director is provided as a string.
         if isinstance(flow_director, str):
             if flow_director[:12] == "FlowDirector":
                 flow_director = flow_director[12:]
 
-            from landlab.components.flow_director import (
-                FlowDirectorD8,
-                FlowDirectorDINF,
-                FlowDirectorMFD,
-                FlowDirectorSteepest,
-            )
+            from landlab.components.flow_director import FlowDirectorD8
+            from landlab.components.flow_director import FlowDirectorDINF
+            from landlab.components.flow_director import FlowDirectorMFD
+            from landlab.components.flow_director import FlowDirectorSteepest
 
             DIRECTOR_METHODS = {
                 "D4": FlowDirectorSteepest,
                 "Steepest": FlowDirectorSteepest,
                 "D8": FlowDirectorD8,
                 "MFD": FlowDirectorMFD,
                 "DINF": FlowDirectorDINF,
```

### Comparing `landlab-2.7.0/landlab/components/flow_accum/lossy_flow_accumulator.py` & `landlab-2.8.0/landlab/components/flow_accum/lossy_flow_accumulator.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,26 +2,23 @@
 of discharge during flow.
 
 DEJH, late 2018
 """
 
 import sys
 
-from landlab.components.flow_accum import (
-    FlowAccumulator,
-    flow_accum_bw,
-    flow_accum_to_n,
-)
+from landlab.components.flow_accum import FlowAccumulator
+from landlab.components.flow_accum import flow_accum_bw
+from landlab.components.flow_accum import flow_accum_to_n
 
 if sys.version_info[0] >= 3:
     from inspect import signature
 
 
 class LossyFlowAccumulator(FlowAccumulator):
-
     """Component to calculate drainage area and accumulate flow, while
     permitting dynamic loss or gain of flow downstream.
 
     This component is closely related to the :class:`.FlowAccumulator`,
     in that this is accomplished by first finding flow directions by a user-specified
     method and then calculating the drainage area and discharge. However,
     this component additionally requires the passing of a function that
@@ -101,25 +98,25 @@
     ...     "topographic__elevation",
     ...     flow_director=FlowDirectorSteepest,
     ...     loss_function=mylossfunction,
     ... )
     >>> fa.run_one_step()
 
     >>> mg.at_node["drainage_area"].reshape(mg.shape)
-    array([[ 0.,  0.,  0.,  0.,  0.],
-           [ 6.,  6.,  4.,  2.,  0.],
-           [ 0.,  0.,  0.,  0.,  0.]])
+    array([[0., 0., 0., 0., 0.],
+           [6., 6., 4., 2., 0.],
+           [0., 0., 0., 0., 0.]])
     >>> mg.at_node["surface_water__discharge"].reshape(mg.shape)
-    array([[ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ],
-           [ 1.75,  3.5 ,  3.  ,  2.  ,  0.  ],
-           [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ]])
+    array([[0.  , 0.  , 0.  , 0.  , 0.  ],
+           [1.75, 3.5 , 3.  , 2.  , 0.  ],
+           [0.  , 0.  , 0.  , 0.  , 0.  ]])
     >>> mg.at_node["surface_water__discharge_loss"].reshape(mg.shape)
-    array([[ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ],
-           [ 0.  ,  1.75,  1.5 ,  1.  ,  0.  ],
-           [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ]])
+    array([[0.  , 0.  , 0.  , 0.  , 0.  ],
+           [0.  , 1.75, 1.5 , 1.  , 0.  ],
+           [0.  , 0.  , 0.  , 0.  , 0.  ]])
 
     Here we use a spatially distributed field to derive loss terms, and also
     use a filled, non-raster grid.
 
     >>> dx = (2.0 / (3.0**0.5)) ** 0.5  # area to be 100.0
     >>> hmg = HexModelGrid((5, 3), spacing=dx, xy_of_lower_left=(-1.0745, 0.0))
     >>> z = hmg.add_field(
@@ -143,25 +140,25 @@
     >>> hmg.at_node["flow__receiver_node"]
     array([ 0,  1,  2,
             3,  0,  9,  6,
             7,  9,  4,  9, 11,
            12,  9,  9, 15,
            16, 17, 18])
     >>> np.round(hmg.at_node["drainage_area"])
-    array([ 7.,  0.,  0.,
-            0.,  7.,  1.,  0.,
-            0.,  1.,  6.,  1.,  0.,
-            0., 1.,  1.,  0.,
-            0.,  0.,  0.])
+    array([7., 0., 0.,
+           0., 7., 1., 0.,
+           0., 1., 6., 1., 0.,
+           0., 1., 1., 0.,
+           0., 0., 0.])
     >>> np.round(hmg.at_node["surface_water__discharge"])
-    array([ 7.,  0.,  0.,
-            0.,  7.,  1.,  0.,
-            0.,  1.,  6.,  1.,  0.,
-            0., 1.,  1.,  0.,
-            0.,  0.,  0.])
+    array([7., 0., 0.,
+           0., 7., 1., 0.,
+           0., 1., 6., 1., 0.,
+           0., 1., 1., 0.,
+           0., 0., 0.])
 
     With loss looks like this:
 
     >>> def mylossfunction2(Qw, nodeID, linkID, grid):
     ...     return (1.0 - grid.at_node["mylossterm"][nodeID]) * Qw
     ...
     >>> fa = LossyFlowAccumulator(
@@ -169,25 +166,25 @@
     ...     "topographic__elevation",
     ...     flow_director=FlowDirectorSteepest,
     ...     depression_finder=DepressionFinderAndRouter,
     ...     loss_function=mylossfunction2,
     ... )
     >>> fa.run_one_step()
     >>> np.round(hmg.at_node["drainage_area"])
-    array([ 7.,  0.,  0.,
-            0.,  7.,  1.,  0.,
-            0.,  1.,  6.,  1.,  0.,
-            0., 1.,  1.,  0.,
-            0.,  0.,  0.])
+    array([7., 0., 0.,
+           0., 7., 1., 0.,
+           0., 1., 6., 1., 0.,
+           0., 1., 1., 0.,
+           0., 0., 0.])
     >>> np.round(hmg.at_node["surface_water__discharge"])
-    array([ 6.,  0.,  0.,
-            0.,  6.,  1.,  0.,
-            0.,  1.,  5.,  1.,  0.,
-            0., 1.,  1.,  0.,
-            0.,  0.,  0.])
+    array([6., 0., 0.,
+           0., 6., 1., 0.,
+           0., 1., 5., 1., 0.,
+           0., 1., 1., 0.,
+           0., 0., 0.])
     >>> np.allclose(
     ...     hmg.at_node["surface_water__discharge_loss"],
     ...     lossy * hmg.at_node["surface_water__discharge"],
     ... )
     True
 
     (Loss is only happening from the node, 14, that we set it to happen at.)
@@ -217,23 +214,23 @@
     ...     "topographic__elevation",
     ...     flow_director=FlowDirectorMFD,
     ...     loss_function=fancyloss,
     ... )
     >>> fa.run_one_step()
 
     >>> mg.at_node["drainage_area"].reshape(mg.shape)
-    array([[  0. ,   0. ,   0. ,   0. ,   0. ,   0. ],
-           [  5.6,   5.6,   3.6,   2. ,   2. ,   0. ],
-           [ 10.4,  10.4,   8.4,   6.4,   4. ,   0. ],
-           [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ]])
+    array([[ 0. ,  0. , 0. ,  0. ,  0. ,  0. ],
+           [ 5.6,  5.6, 3.6,  2. ,  2. ,  0. ],
+           [10.4, 10.4, 8.4,  6.4,  4. ,  0. ],
+           [ 0. ,  0. , 0. ,  0. ,  0. ,  0. ]])
     >>> mg.at_node["surface_water__discharge"].reshape(mg.shape)
-    array([[ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ],
-           [ 4. ,  4. ,  2. ,  2. ,  2. ,  0. ],
-           [ 0. ,  8.5,  6.5,  4.5,  2.5,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ]])
+    array([[0. , 0. , 0. , 0. , 0. , 0. ],
+           [4. , 4. , 2. , 2. , 2. , 0. ],
+           [0. , 8.5, 6.5, 4.5, 2.5, 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. ]])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     None Listed
```

### Comparing `landlab-2.7.0/landlab/components/flow_director/cfuncs.pyx` & `landlab-2.8.0/landlab/components/flow_director/cfuncs.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 cimport cython
 cimport numpy as np
 
 DTYPE_FLOAT = np.double
 ctypedef np.double_t DTYPE_FLOAT_t
 
 DTYPE_INT = int
-#ctypedef np.longlong_t DTYPE_INT_t
+# ctypedef np.longlong_t DTYPE_INT_t
 ctypedef np.int_t DTYPE_INT_t
 
 
 @cython.boundscheck(False)
 def adjust_flow_receivers(np.ndarray[DTYPE_INT_t, ndim=1] src_nodes,
                           np.ndarray[DTYPE_INT_t, ndim=1] dst_nodes,
                           np.ndarray[DTYPE_FLOAT_t, ndim=1] z,
```

### Comparing `landlab-2.7.0/landlab/components/flow_director/flow_direction_DN.py` & `landlab-2.8.0/landlab/components/flow_director/flow_direction_DN.py`

 * *Files 2% similar despite different names*

```diff
@@ -73,15 +73,15 @@
     >>> tn = np.array([4, 5, 7, 1, 2, 5, 6, 5, 7, 7, 8, 9, 9, 8, 8, 6, 3, 3])
     >>> s = z[fn] - z[tn]  # slope with unit link length, positive downhill
     >>> active_links = np.arange(len(fn))
     >>> r, ss, snk, rl = flow_directions(z, active_links, fn, tn, s)
     >>> r
     array([1, 4, 1, 6, 4, 4, 5, 4, 6, 7])
     >>> ss
-    array([ 1.4,  1. ,  1.2,  1. ,  0. ,  1.1,  0.9,  2.3,  1.1,  0.9])
+    array([1.4, 1. , 1.2, 1. , 0. , 1.1, 0.9, 2.3, 1.1, 0.9])
     >>> snk
     array([4])
     >>> rl[3:8]
     array([15, -1,  1,  6,  2])
     """
     # OK, the following are rough notes on design: we want to work with just
     # the active links. Ways to do this:
```

### Comparing `landlab-2.7.0/landlab/components/flow_director/flow_direction_dinf.py` & `landlab-2.8.0/landlab/components/flow_director/flow_direction_dinf.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/flow_director/flow_direction_mfd.py` & `landlab-2.8.0/landlab/components/flow_director/flow_direction_mfd.py`

 * *Files 6% similar despite different names*

```diff
@@ -130,25 +130,25 @@
            [ 3, -1, -1, -1],
            [-1, -1,  3,  1],
            [-1, -1,  4, -1],
            [ 6, -1, -1, -1],
            [-1, -1, -1,  4],
            [ 8, -1, -1, -1]])
     >>> proportions
-    array([[ 1. ,  0. ,  0. ,  0. ],
-           [ 1. ,  0. ,  0. ,  0. ],
-           [ 1. ,  0. ,  0. ,  0. ],
-           [ 1. ,  0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0.5,  0.5],
-           [ 0. ,  0. ,  1. ,  0. ],
-           [ 1. ,  0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  1. ],
-           [ 1. ,  0. ,  0. ,  0. ]])
+    array([[1. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. ],
+           [0. , 0. , 0.5, 0.5],
+           [0. , 0. , 1. , 0. ],
+           [1. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 1. ],
+           [1. , 0. , 0. , 0. ]])
     >>> proportions.sum(axis=-1)
-    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
+    array([1., 1., 1., 1., 1., 1., 1., 1., 1.])
 
     In the second example, we will pass diagonal elements to the flow direction
     algorithm.
 
     >>> dal = grid.active_d8
     >>> neighbors_at_node = np.hstack(
     ...     (grid.adjacent_nodes_at_node, grid.diagonal_adjacent_nodes_at_node)
@@ -191,53 +191,53 @@
            [ 3, -1, -1, -1, -1, -1, -1, -1],
            [-1, -1,  3,  1, -1, -1,  0, -1],
            [-1, -1,  4, -1, -1, -1, -1, -1],
            [ 6, -1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1,  4, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1,  4, -1]])
     >>> proportions
-    array([[ 1.        ,  0.        ,  0.        ,  0.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 1.        ,  0.        ,  0.        ,  0.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 1.        ,  0.        ,  0.        ,  0.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 1.        ,  0.        ,  0.        ,  0.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 0.        ,  0.        ,  0.31091174,  0.31091174,  0.        ,
-             0.        ,  0.37817653,  0.        ],
-           [ 0.        ,  0.        ,  1.        ,  0.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 1.        ,  0.        ,  0.        ,  0.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 0.        ,  0.        ,  0.        ,  1.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
-             0.        ,  1.        ,  0.        ]])
+    array([[1.        , 0.        , 0.        , 0.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [1.        , 0.        , 0.        , 0.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [1.        , 0.        , 0.        , 0.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [1.        , 0.        , 0.        , 0.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [0.        , 0.        , 0.31091174,  0.31091174, 0.        ,
+            0.        , 0.37817653, 0.        ],
+           [0.        , 0.        , 1.        , 0.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [1.        , 0.        , 0.        , 0.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [0.        , 0.        , 0.        , 1.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [0.        , 0.        , 0.        , 0.        , 0.        ,
+            0.        , 1.        , 0.        ]])
     >>> slopes
-    array([[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 0.        ,  0.        ,  0.78539816,  0.78539816,  0.        ,
-             0.        ,  0.95531662,  0.        ],
-           [ 0.        ,  0.        ,  0.78539816,  0.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 0.        ,  0.        ,  0.        ,  0.78539816,  0.        ,
-             0.        ,  0.        ,  0.        ],
-           [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
-             0.        ,  0.95531662,  0.        ]])
+    array([[0.        , 0.        , 0.        , 0.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [0.        , 0.        , 0.        , 0.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [0.        , 0.        , 0.        , 0.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [0.        , 0.        , 0.        , 0.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [0.        , 0.        , 0.78539816, 0.78539816, 0.        ,
+            0.        , 0.95531662, 0.        ],
+           [0.        , 0.        , 0.78539816, 0.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [0.        , 0.        , 0.        , 0.        , 0.        ,
+            0.        , 0.        , 0.        ],
+           [0.        , 0.        , 0.        , 0.78539816, 0.        ,
+            0.        , 0.        , 0.        ],
+           [0.        , 0.        , 0.        , 0.        , 0.        ,
+            0.        , 0.95531662, 0.        ]])
     >>> proportions.sum(axis=-1)
-    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
+    array([1., 1., 1., 1., 1., 1., 1., 1., 1.])
     """
     # Calculate the number of nodes.
     num_nodes = len(elev)
 
     # Create a node array
     node_id = np.arange(num_nodes)
```

### Comparing `landlab-2.7.0/landlab/components/flow_director/flow_director.py` & `landlab-2.8.0/landlab/components/flow_director/flow_director.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,21 +3,20 @@
 """flow_director.py provides a private class to help create FlowDirectors.
 
 Provides the _FlowDirector component which does grid type testing, adds
 the surface over which flow will be routed to the component, and sets up
 part of the boundary condition testing.
 """
 
-from landlab import RasterModelGrid  # for type tests
 from landlab import Component
+from landlab import RasterModelGrid  # for type tests
 from landlab.utils.return_array import return_array_at_node
 
 
 class _FlowDirector(Component):
-
     """Private class for creating components to calculate flow directions.
 
     This class is not meant to be used directly in modeling efforts.
     Instead it has the functionality that all flow direction calculators need
     to initialize and check boundary conditions.
 
     It also creates the following field used by all FlowDirectors.
@@ -43,28 +42,28 @@
     >>> _ = mg.add_field(
     ...     "topographic__elevation",
     ...     mg.node_x + mg.node_y,
     ...     at="node",
     ... )
     >>> fd = _FlowDirector(mg, "topographic__elevation")
     >>> fd.surface_values
-    array([ 0.,  1.,  2.,  1.,  2.,  3.,  2.,  3.,  4.])
+    array([0., 1., 2., 1., 2., 3., 2., 3., 4.])
     >>> "topographic__elevation" in mg.at_node.keys()
     True
     >>> "flow__sink_flag" in mg.at_node.keys()
     True
 
     _FlowDirector also works if you pass it an array instead of a field name.
 
     >>> import numpy as np
     >>> mg = RasterModelGrid((3, 3), xy_spacing=(1, 1))
     >>> z = np.array([0.0, 1.0, 2.0, 1.0, 2.0, 3.0, 2.0, 3.0, 4.0])
     >>> fd = _FlowDirector(mg, z)
     >>> fd.surface_values
-    array([ 0.,  1.,  2.,  1.,  2.,  3.,  2.,  3.,  4.])
+    array([0., 1., 2., 1., 2., 3., 2., 3., 4.])
     """
 
     _name = "_FlowDirector"
 
     _unit_agnostic = True
 
     _info = {
```

### Comparing `landlab-2.7.0/landlab/components/flow_director/flow_director_d8.py` & `landlab-2.8.0/landlab/components/flow_director/flow_director_d8.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from landlab import LinkStatus
 from landlab.components.flow_director import flow_direction_DN
 from landlab.components.flow_director.flow_director_to_one import _FlowDirectorToOne
 
 
 class FlowDirectorD8(_FlowDirectorToOne):
-
     """Single-path (steepest direction) flow direction with diagonals on
     rasters.
 
     Single-path (steepest direction) flow direction finding on raster grids
     by the D8 method. This method considers flow on all eight links such that
     flow is possible on orthogonal and on diagonal links.
 
@@ -55,21 +54,21 @@
     >>> _ = mg.add_field(
     ...     "topographic__elevation",
     ...     mg.node_x + mg.node_y,
     ...     at="node",
     ... )
     >>> fd = FlowDirectorD8(mg, "topographic__elevation")
     >>> fd.surface_values
-    array([ 0.,  1.,  2.,  1.,  2.,  3.,  2.,  3.,  4.])
+    array([0., 1., 2., 1., 2., 3., 2., 3., 4.])
     >>> fd.run_one_step()
     >>> mg.at_node["flow__receiver_node"]
     array([0, 1, 2, 3, 0, 5, 6, 7, 8])
     >>> mg.at_node["topographic__steepest_slope"]
-    array([ 0.        ,  0.        ,  0.        ,  0.        ,  1.41421356,
-            0.        ,  0.        ,  0.        ,  0.        ])
+    array([0.        , 0.        , 0.        , 0.        , 1.41421356,
+           0.        , 0.        , 0.        , 0.        ])
     >>> mg.at_node["flow__link_to_receiver_node"]
     array([-1, -1, -1, -1, 12, -1, -1, -1, -1])
     >>> mg.at_node["flow__sink_flag"].astype(int)
     array([1, 1, 1, 1, 0, 1, 1, 1, 1])
     >>> mg_2 = RasterModelGrid((5, 4), xy_spacing=(1, 1))
     >>> topographic__elevation = [
     ...     [0.0, 0.0, 0.0, 0.0],
```

### Comparing `landlab-2.7.0/landlab/components/flow_director/flow_director_dinf.py` & `landlab-2.8.0/landlab/components/flow_director/flow_director_dinf.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,15 +11,14 @@
 
 from landlab import NodeStatus
 from landlab.components.flow_director import flow_direction_dinf
 from landlab.components.flow_director.flow_director_to_many import _FlowDirectorToMany
 
 
 class FlowDirectorDINF(_FlowDirectorToMany):
-
     """Flow direction on a raster grid by the D infinity method.
 
     Directs flow by the D infinity method (Tarboton, 1997). Each node is
     assigned two flow directions, toward the two neighboring nodes that are on
     the steepest subtriangle. Partitioning of flow is done based on the aspect
     of the subtriangle.
 
@@ -61,18 +60,18 @@
     ...     at="node",
     ... )
 
     The DINF flow director can be uses for raster grids only.
 
     >>> fd = FlowDirectorDINF(mg, "topographic__elevation")
     >>> fd.surface_values.reshape(mg.shape)
-    array([[  0.,   1.,   4.,   9.],
-           [  1.,   2.,   5.,  10.],
-           [  4.,   5.,   8.,  13.],
-           [  9.,  10.,  13.,  18.]])
+    array([[ 0.,  1.,   4.,  9.],
+           [ 1.,  2.,   5., 10.],
+           [ 4.,  5.,   8., 13.],
+           [ 9., 10., 13., 18.]])
     >>> fd.run_one_step()
 
     Unlike flow directors that only direct flow to one node or to all
     downstream nodes, FlowDirectorDINF directs flow two nodes only. It stores
     the receiver information is a (number of nodes x 2) shape field at nodes.
 
     >>> mg.at_node["flow__receiver_node"]
@@ -93,30 +92,30 @@
            [14, -1],
            [15, -1]])
 
     It also stores the proportions of flow going to each receiver, the link on
     which the flow moves in at node arrays, and the slope of each link.
 
     >>> mg.at_node["flow__receiver_proportions"]
-    array([[ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 0.59033447,  0.40966553],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ]])
+    array([[1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [0.59033447, 0.40966553],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ]])
     >>> mg.at_node["flow__link_to_receiver_node"]
     array([[-1, -1],
            [-1, -1],
            [-1, -1],
            [-1, -1],
            [ 3, 25],
            [24,  4],
@@ -127,30 +126,30 @@
            [32, 12],
            [16, 34],
            [21, 37],
            [18, 39],
            [19, 38],
            [20, 40]])
     >>> mg.at_node["topographic__steepest_slope"]
-    array([[ -1.00000000e+00,  -1.41421356e+00],
-           [  1.00000000e+00,  -7.12763635e+02],
-           [  3.00000000e+00,   1.41421356e+00],
-           [  5.00000000e+00,   2.82842712e+00],
-           [  1.00900000e+03,   7.12763635e+02],
-           [  1.41421356e+00,   1.00000000e+00],
-           [  3.00000000e+00,   2.82842712e+00],
-           [  1.00400000e+03,   7.10642315e+02],
-           [  1.00400000e+03,   7.12056529e+02],
-           [  3.00000000e+00,   0.00000000e+00],
-           [  4.24264069e+00,   3.00000000e+00],
-           [  1.00100000e+03,   7.09935208e+02],
-           [ -0.00000000e+00,   7.09935208e+02],
-           [  1.00400000e+03,   7.07813888e+02],
-           [  1.00100000e+03,   7.09935208e+02],
-           [  0.00000000e+00,   7.07813888e+02]])
+    array([[-1.00000000e+00, -1.41421356e+00],
+           [ 1.00000000e+00, -7.12763635e+02],
+           [ 3.00000000e+00,  1.41421356e+00],
+           [ 5.00000000e+00,  2.82842712e+00],
+           [ 1.00900000e+03,  7.12763635e+02],
+           [ 1.41421356e+00,  1.00000000e+00],
+           [ 3.00000000e+00,  2.82842712e+00],
+           [ 1.00400000e+03,  7.10642315e+02],
+           [ 1.00400000e+03,  7.12056529e+02],
+           [ 3.00000000e+00,  0.00000000e+00],
+           [ 4.24264069e+00,  3.00000000e+00],
+           [ 1.00100000e+03,  7.09935208e+02],
+           [-0.00000000e+00,  7.09935208e+02],
+           [ 1.00400000e+03,  7.07813888e+02],
+           [ 1.00100000e+03,  7.09935208e+02],
+           [ 0.00000000e+00,  7.07813888e+02]])
 
     Finally, FlowDirectorDINF identifies sinks, or local lows.
 
     >>> mg.at_node["flow__sink_flag"].astype(int)
     array([1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1])
 
     The flow directors also have the ability to return the flow receiver nodes
@@ -173,37 +172,36 @@
            [ 5, -1],
            [11, -1],
            [12, -1],
            [13, -1],
            [14, -1],
            [15, -1]])
     >>> proportions
-    array([[ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 0.59033447,  0.40966553],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ],
-           [ 1.        ,  0.        ]])
+    array([[1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [0.59033447, 0.40966553],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ],
+           [1.        , 0.        ]])
 
     For each donor node (represented by each row) the proportions should sum to
     one.
 
     >>> proportions.sum(axis=1)
-    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,
-            1.,  1.,  1.])
+    array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     None Listed
```

### Comparing `landlab-2.7.0/landlab/components/flow_director/flow_director_mfd.py` & `landlab-2.8.0/landlab/components/flow_director/flow_director_mfd.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,21 +7,21 @@
 directions. It is equivalent to D4 method in the special case of a raster grid
 in that it does not consider diagonal links between nodes. For that capability,
 use FlowDirectorD8.
 """
 
 import numpy
 
-from landlab import NodeStatus, VoronoiDelaunayGrid
+from landlab import NodeStatus
+from landlab import VoronoiDelaunayGrid
 from landlab.components.flow_director import flow_direction_mfd
 from landlab.components.flow_director.flow_director_to_many import _FlowDirectorToMany
 
 
 class FlowDirectorMFD(_FlowDirectorToMany):
-
     """Multiple-path flow direction with or without out diagonals.
 
     Directs flow by the multiple flow direction method. Each node is assigned
     multiple flow directions, toward all of the N neighboring nodes that are
     lower than it. If none of the neighboring nodes are lower, the location is
     identified as a pit. Flow proportions can be calculated as proportional to
     slope or proportional to the square root of slope, which is the solution to
@@ -67,15 +67,15 @@
 
     The MFD flow director can be uses for raster and irregular grids. For
     raster grids, use of diagonal links is specified with the keyword
     *diagonals* (default is False).
 
     >>> fd = FlowDirectorMFD(mg, "topographic__elevation", diagonals=True)
     >>> fd.surface_values
-    array([ 0.,  1.,  2.,  1.,  2.,  3.,  2.,  3.,  4.])
+    array([0., 1., 2., 1., 2., 3., 2., 3., 4.])
     >>> fd.run_one_step()
 
     Unlike flow directors that only direct flow to one node, FlowDirectorMFD
     directs flow to all downstream nodes. It stores the receiver information
     is a (number of nodes x maximum number or receivers) shape field at nodes.
 
     >>> mg.at_node["flow__receiver_node"]
@@ -89,43 +89,43 @@
            [ 7, -1, -1, -1, -1, -1, -1, -1],
            [ 8, -1, -1, -1, -1, -1, -1, -1]])
 
     It also stores the proportions of flow going to each receiver, the link on
     which the flow moves in at node arrays, and the slope of each link.
 
     >>> mg.at_node["flow__receiver_proportions"]
-    array([[ 1. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0.41421356, 0. , 0. ,  0.58578644, 0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ]])
+    array([[1. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0.41421356, 0. , 0. ,  0.58578644, 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ]])
     >>> mg.at_node["flow__link_to_receiver_node"]
     array([[-1, -1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1,  3, -1, -1, 12, -1],
            [-1, -1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1, -1, -1]])
     >>> mg.at_node["topographic__steepest_slope"]
-    array([[ 0. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  1. ,  0. , 0. ,  1.41421356, 0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. , 0. ,  0. ,  0. ]])
+    array([[0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 1. , 0. , 0. , 1.41421356, 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ]])
 
     Finally, FlowDirectorMFD identifies sinks, or local lows.
 
     >>> mg.at_node["flow__sink_flag"].astype(int)
     array([1, 1, 1, 1, 0, 1, 1, 1, 1])
 
     The flow directors also have the ability to return the flow receiver nodes.
@@ -149,29 +149,29 @@
            [ 3, -1, -1, -1],
            [-1, -1, -1,  1],
            [ 5, -1, -1, -1],
            [ 6, -1, -1, -1],
            [ 7, -1, -1, -1],
            [ 8, -1, -1, -1]])
     >>> proportions
-    array([[ 1.,  0.,  0.,  0.],
-           [ 1.,  0.,  0.,  0.],
-           [ 1.,  0.,  0.,  0.],
-           [ 1.,  0.,  0.,  0.],
-           [ 0.,  0.,  0.,  1.],
-           [ 1.,  0.,  0.,  0.],
-           [ 1.,  0.,  0.,  0.],
-           [ 1.,  0.,  0.,  0.],
-           [ 1.,  0.,  0.,  0.]])
+    array([[1., 0., 0., 0.],
+           [1., 0., 0., 0.],
+           [1., 0., 0., 0.],
+           [1., 0., 0., 0.],
+           [0., 0., 0., 1.],
+           [1., 0., 0., 0.],
+           [1., 0., 0., 0.],
+           [1., 0., 0., 0.],
+           [1., 0., 0., 0.]])
 
     For each donor node (represented by each row) the proportions should sum to
     one.
 
     >>> proportions.sum(axis=1)
-    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
+    array([1., 1., 1., 1., 1., 1., 1., 1., 1.])
 
     For the second example we will use a Hexagonal Model Grid, a special type
     of Voroni Grid that has regularly spaced hexagonal cells. FlowDirectorMFD
     has multiple ways to partition flow based on slope. The default method is
     based on the slope angle. A secondary methods is to partion based on the
     square root of slope. This represents the solution to a steady kinematic
     wave.
@@ -183,19 +183,19 @@
     ...     mg.node_x + numpy.round(mg.node_y),
     ...     at="node",
     ... )
     >>> fd = FlowDirectorMFD(
     ...     mg, "topographic__elevation", partition_method="square_root_of_slope"
     ... )
     >>> fd.surface_values
-    array([ 1. ,  2. ,  3. ,
-            1.5,  2.5,  3.5,  4.5,
-            2. ,  3. ,  4. ,  5. ,  6. ,
-            3.5,  4.5,  5.5,  6.5,
-            4. ,  5. ,  6. ])
+    array([1. , 2. , 3. ,
+           1.5, 2.5, 3.5, 4.5,
+           2. , 3. , 4. , 5. , 6. ,
+           3.5, 4.5, 5.5, 6.5,
+           4. , 5. , 6. ])
     >>> fd.run_one_step()
     >>> mg.at_node["flow__receiver_node"]
     array([[ 0, -1, -1, -1, -1, -1],
            [ 1, -1, -1, -1, -1, -1],
            [ 2, -1, -1, -1, -1, -1],
            [ 3, -1, -1, -1, -1, -1],
            [-1, -1, -1,  3,  0,  1],
@@ -210,33 +210,33 @@
            [-1, -1, 16, 12,  8,  9],
            [-1, -1, 17, 13,  9, 10],
            [15, -1, -1, -1, -1, -1],
            [16, -1, -1, -1, -1, -1],
            [17, -1, -1, -1, -1, -1],
            [18, -1, -1, -1, -1, -1]])
     >>> mg.at_node["flow__receiver_proportions"]
-    array([[ 1. ,  0. ,  0. ,  0. ,  0. , 0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ],
-           [ 0. ,  0. ,  0. ,  0.34108138,  0.41773767, 0.24118095],
-           [ 0. ,  0. ,  0. ,  0.34108138,  0.41773767, 0.24118095],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ],
-           [ 0. ,  0. ,  0. ,  0.34108138,  0.41773767, 0.24118095],
-           [ 0. ,  0. ,  0. ,  0.34108138,  0.41773767, 0.24118095],
-           [ 0. ,  0. ,  0. ,  0.34108138,  0.41773767, 0.24118095],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ],
-           [ 0. ,  0. ,  0.19431571,  0.27480391,  0.33656468, 0.19431571],
-           [ 0. ,  0. ,  0.19431571,  0.27480391,  0.33656468, 0.19431571],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ],
-           [ 1. ,  0. ,  0. ,  0. ,  0. , 0. ]])
+    array([[1. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0.34108138,  0.41773767, 0.24118095],
+           [0. , 0. , 0. , 0.34108138,  0.41773767, 0.24118095],
+           [1. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0.34108138,  0.41773767, 0.24118095],
+           [0. , 0. , 0. , 0.34108138,  0.41773767, 0.24118095],
+           [0. , 0. , 0. , 0.34108138,  0.41773767, 0.24118095],
+           [1. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0.19431571,  0.27480391,  0.33656468, 0.19431571],
+           [0. , 0. , 0.19431571,  0.27480391,  0.33656468, 0.19431571],
+           [1. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. ],
+           [1. , 0. , 0. , 0. , 0. , 0. ]])
     >>> mg.at_node["flow__link_to_receiver_node"]
     array([[-1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1],
            [-1, -1, -1,  8,  3,  4],
            [-1, -1, -1,  9,  5,  6],
@@ -250,33 +250,33 @@
            [-1, -1, 35, 31, 25, 26],
            [-1, -1, 37, 32, 27, 28],
            [-1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1],
            [-1, -1, -1, -1, -1, -1]])
     >>> mg.at_node["topographic__steepest_slope"]
-    array([[ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  1. ,  1.5,  0.5],
-           [ 0. ,  0. ,  0. ,  1. ,  1.5,  0.5],
-           [ 0. ,  0. ,  1. ,  0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  1. ,  1.5,  0.5],
-           [ 0. ,  0. ,  0. ,  1. ,  1.5,  0.5],
-           [ 0. ,  0. ,  0. ,  1. ,  1.5,  0.5],
-           [ 0. ,  1. ,  0. ,  0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0.5,  0. ,  0. ],
-           [ 0. ,  0. ,  0.5,  1. ,  1.5,  0.5],
-           [ 0. ,  0. ,  0.5,  1. ,  1.5,  0.5],
-           [ 0. ,  1. ,  1.5,  0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ],
-           [ 0. ,  0. ,  0.5,  0. ,  0. ,  0. ],
-           [ 0. ,  0.5,  0. ,  0. ,  0. ,  0. ]])
+    array([[0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 1. , 1.5, 0.5],
+           [0. , 0. , 0. , 1. , 1.5, 0.5],
+           [0. , 0. , 1. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 1. , 1.5, 0.5],
+           [0. , 0. , 0. , 1. , 1.5, 0.5],
+           [0. , 0. , 0. , 1. , 1.5, 0.5],
+           [0. , 1. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0.5, 0. , 0. ],
+           [0. , 0. , 0.5, 1. , 1.5, 0.5],
+           [0. , 0. , 0.5, 1. , 1.5, 0.5],
+           [0. , 1. , 1.5, 0. , 0. , 0. ],
+           [0. , 0. , 0. , 0. , 0. , 0. ],
+           [0. , 0. , 0.5, 0. , 0. , 0. ],
+           [0. , 0.5, 0. , 0. , 0. , 0. ]])
     >>> mg.at_node["flow__sink_flag"].astype(int)
     array([1, 1, 1,
            1, 0, 0, 1,
            1, 0, 0, 0, 1,
            1, 0, 0, 1,
            1, 1, 1])
```

### Comparing `landlab-2.7.0/landlab/components/flow_director/flow_director_steepest.py` & `landlab-2.8.0/landlab/components/flow_director/flow_director_steepest.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,21 +7,21 @@
 directions. It is equivalent to D4 method in the special case of a raster grid
 in that it does not consider diagonal links between nodes. For that capability,
 use FlowDirectorD8.
 """
 
 import numpy as np
 
-from landlab import NodeStatus, VoronoiDelaunayGrid
+from landlab import NodeStatus
+from landlab import VoronoiDelaunayGrid
 from landlab.components.flow_director import flow_direction_DN
 from landlab.components.flow_director.flow_director_to_one import _FlowDirectorToOne
 
 
 class FlowDirectorSteepest(_FlowDirectorToOne):
-
     """Single-path (steepest direction) flow direction without diagonals.
 
     This components finds the steepest single-path steepest descent flow
     directions. It is equivalent to D4 method in the special case of a raster
     grid in that it does not consider diagonal links between nodes. For that
     capability, use FlowDirectorD8.
 
@@ -54,20 +54,20 @@
     >>> _ = mg.add_field(
     ...     "topographic__elevation",
     ...     mg.node_x + mg.node_y,
     ...     at="node",
     ... )
     >>> fd = FlowDirectorSteepest(mg, "topographic__elevation")
     >>> fd.surface_values
-    array([ 0.,  1.,  2.,  1.,  2.,  3.,  2.,  3.,  4.])
+    array([0., 1., 2., 1., 2., 3., 2., 3., 4.])
     >>> fd.run_one_step()
     >>> mg.at_node["flow__receiver_node"]
     array([0, 1, 2, 3, 1, 5, 6, 7, 8])
     >>> mg.at_node["topographic__steepest_slope"]
-    array([ 0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.])
+    array([0., 0., 0., 0., 1., 0., 0., 0., 0.])
     >>> mg.at_node["flow__link_to_receiver_node"]
     array([-1, -1, -1, -1,  3, -1, -1, -1, -1])
     >>> mg.at_node["flow__sink_flag"].astype(int)
     array([1, 1, 1, 1, 0, 1, 1, 1, 1])
     >>> mg_2 = RasterModelGrid((5, 4), xy_spacing=(1, 1))
     >>> topographic__elevation = [
     ...     [0.0, 0.0, 0.0, 0.0],
@@ -93,15 +93,15 @@
 
     And the at-link field ``'flow__link_direction'`` indicates if the flow along
     the link is with or against the direction indicated by ``'link_dirs_at_node'``
     (from tail node to head node).
 
     >>> mg_2.at_link["flow__link_direction"]
     array([ 0,  0,  0,  0, -1, -1,  0,  0,  0,  0,  0,  0, -1,  0,  0,  1,  0,
-        0,  0, -1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0], dtype=int8)
+            0,  0, -1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0], dtype=int8)
 
     This indicates that flow on links 4, 5, 12, and 19 goes against the
     topologic ordering -- that is that flow goes from head node to tail node --
     and that flow goes with the topologic ordering on links 15 and 22. All other
     links have no flow on them.
 
     The FlowDirectorSteepest attribute ``flow_link_direction_at_node`` indicates
@@ -207,32 +207,32 @@
     >>> _ = mg.add_field(
     ...     "topographic__elevation",
     ...     mg.node_x + np.round(mg.node_y),
     ...     at="node",
     ... )
     >>> fd = FlowDirectorSteepest(mg, "topographic__elevation")
     >>> fd.surface_values
-    array([ 1. ,  2. ,  3. ,
-        1.5,  2.5,  3.5,  4.5,
-      2. ,  3. ,  4. ,  5. ,  6. ,
-        3.5,  4.5,  5.5,  6.5,
-            4. ,  5. ,  6. ])
+    array([1. ,  2. ,  3. ,
+       1.5,  2.5,  3.5,  4.5,
+     2. ,  3. ,  4. ,  5. ,  6. ,
+       3.5,  4.5,  5.5,  6.5,
+           4. ,  5. ,  6. ])
     >>> fd.run_one_step()
     >>> mg.at_node["flow__receiver_node"]
     array([ 0,  1,  2,
           3,  0,  1,  6,
         7,  3,  4,  5,  11,
           12,  8,  9, 15,
             16, 17, 18])
     >>> mg.at_node["topographic__steepest_slope"]
-    array([ 0. ,  0. ,  0. ,
-        0. ,  1.5,  1.5,   0. ,
-      0. ,  1.5,  1.5,  1.5,  0. ,
-        0. ,  1.5,  1.5,  0. ,
-            0. ,  0. ,  0. ])
+    array([0. ,  0. ,  0. ,
+       0. ,  1.5,  1.5,   0. ,
+     0. ,  1.5,  1.5,  1.5,  0. ,
+       0. ,  1.5,  1.5,  0. ,
+           0. ,  0. ,  0. ])
     >>> mg.at_node["flow__link_to_receiver_node"]
     array([-1, -1, -1,
          -1,  3,  5, -1,
        -1, 12, 14, 16, -1,
          -1, 25, 27, -1,
            -1, -1, -1])
     >>> mg.at_node["flow__sink_flag"].astype(int)
```

### Comparing `landlab-2.7.0/landlab/components/flow_director/flow_director_to_many.py` & `landlab-2.8.0/landlab/components/flow_director/flow_director_to_many.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,15 +8,14 @@
 """
 import numpy as np
 
 from landlab.components.flow_director.flow_director import _FlowDirector
 
 
 class _FlowDirectorToMany(_FlowDirector):
-
     """Private class for creating components to calculate flow directions.
 
     This class is not meant to be used directly in modeling efforts. It
     inherits from the _FlowDirector class and builds on it to provide the
     functionality that all flow direction calculators need if they direct flow
     only to multiple nodes, as in  D infinity or MFD direction finding. It
     exists in contrast to the other intermediate flow director class
@@ -46,15 +45,15 @@
     >>> _ = mg.add_field(
     ...     "topographic__elevation",
     ...     mg.node_x + mg.node_y,
     ...     at="node",
     ... )
     >>> fd = _FlowDirectorToMany(mg, "topographic__elevation")
     >>> fd.surface_values
-    array([ 0.,  1.,  2.,  1.,  2.,  3.,  2.,  3.,  4.])
+    array([0., 1., 2., 1., 2., 3., 2., 3., 4.])
     >>> sorted(list(mg.at_node.keys()))
     ['flow__link_to_receiver_node', 'flow__receiver_node',
      'flow__receiver_proportions', 'flow__sink_flag', 'topographic__elevation',
      'topographic__steepest_slope']
     """
 
     _name = "FlowDirectorToMany"
```

### Comparing `landlab-2.7.0/landlab/components/flow_director/flow_director_to_one.py` & `landlab-2.8.0/landlab/components/flow_director/flow_director_to_one.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,14 @@
 """
 import numpy as np
 
 from landlab.components.flow_director.flow_director import _FlowDirector
 
 
 class _FlowDirectorToOne(_FlowDirector):
-
     """Private class for creating components to calculate flow directions.
 
     This class is not meant to be used directly in modeling efforts. It
     inherits from the _FlowDirector class and builds on it to provide the
     functionality that all flow direction calculators need if they direct flow
     only to one nodes, as in steepest descent or D8 direction finding. It
     exists in contrast to the other intermediate flow director class
@@ -57,15 +56,15 @@
     >>> _ = mg.add_field(
     ...     "topographic__elevation",
     ...     mg.node_x + mg.node_y,
     ...     at="node",
     ... )
     >>> fd = _FlowDirectorToOne(mg, "topographic__elevation")
     >>> fd.surface_values
-    array([ 0.,  1.,  2.,  1.,  2.,  3.,  2.,  3.,  4.])
+    array([0., 1., 2., 1., 2., 3., 2., 3., 4.])
     >>> sorted(list(mg.at_node.keys()))
     ['flow__link_to_receiver_node',
      'flow__receiver_node',
      'flow__sink_flag',
      'topographic__elevation',
      'topographic__steepest_slope']
     """
```

### Comparing `landlab-2.7.0/landlab/components/flow_router/ext/single_flow/priority_routing/breach.pxd` & `landlab-2.8.0/landlab/components/flow_router/ext/single_flow/priority_routing/breach.pxd`

 * *Files 17% similar despite different names*

```diff
@@ -12,42 +12,81 @@
         _priority_queue(...) except +
         void push(pair[cnp.int_t, cnp.float_t])
         pair[cnp.int_t, cnp.float_t] top() except +
         void pop()
         bool empty()
         cnp.int_t size()
 
-cdef bool _compare_second(pair[int, double] a, pair[int, double] b) nogil
 
-cdef void _init_flow_direction_queues(
-    const cnp.int_t [:] base_level_nodes, const cnp.int_t [:] closed_nodes,
-    cnp.float_t [:] z, _priority_queue& to_do, cnp.int_t [:] receivers,
-    cnp.int_t [:] outlet_nodes, cnp.int_t [:] done, cnp.int_t* done_n_ptr) nogil
-
-cdef void _set_flooded_and_outlet(cnp.int_t donor_id, cnp.float_t [:] z,
-    cnp.int_t [:] receivers, cnp.int_t [:] outlet_nodes,
-    cnp.int_t [:] depression_outlet_nodes, cnp.int_t [:] flooded_nodes,
-    cnp.float_t [:] depression_depths, cnp.float_t [:] depression_free_elevations,
-    cnp.int_t flooded_status, cnp.int_t bad_index,
-    cnp.float_t min_elevation_relative_diff) nogil
+cdef bool _compare_second(pair[int, double] a, pair[int, double] b) nogil
 
-cdef void _set_receiver(cnp.int_t donor_id, cnp.int_t receiver_id,
-    cnp.int_t [:] receivers, cnp.int_t [:] done, cnp.int_t* done_n_ptr) nogil
 
-cdef void _set_donor_properties(cnp.int_t donor_id, cnp.int_t receiver_id,
-    cnp.int_t [:] sorted_pseudo_tails, const cnp.int_t [:,:] head_start_end_indexes,
+cdef void _init_flow_direction_queues(
+    const cnp.int_t [:] base_level_nodes,
+    const cnp.int_t [:] closed_nodes,
+    cnp.float_t [:] z,
+    _priority_queue& to_do,
+    cnp.int_t [:] receivers,
+    cnp.int_t [:] outlet_nodes,
+    cnp.int_t [:] done, cnp.int_t* done_n_ptr
+) nogil
+
+
+cdef void _set_flooded_and_outlet(
+    cnp.int_t donor_id,
+    cnp.float_t [:] z,
+    cnp.int_t [:] receivers,
+    cnp.int_t [:] outlet_nodes,
+    cnp.int_t [:] depression_outlet_nodes,
+    cnp.int_t [:] flooded_nodes,
+    cnp.float_t [:] depression_depths,
+    cnp.float_t [:] depression_free_elevations,
+    cnp.int_t flooded_status,
+    cnp.int_t bad_index,
+    cnp.float_t min_elevation_relative_diff
+) nogil
+
+
+cdef void _set_receiver(
+    cnp.int_t donor_id,
+    cnp.int_t receiver_id,
+    cnp.int_t [:] receivers,
+    cnp.int_t [:] done,
+    cnp.int_t* done_n_ptr,
+) nogil
+
+
+cdef void _set_donor_properties(
+    cnp.int_t donor_id,
+    cnp.int_t receiver_id,
+    cnp.int_t [:] sorted_pseudo_tails,
+    const cnp.int_t [:, :] head_start_end_indexes,
     const cnp.int_t [:] sorted_dupli_links,
-    cnp.float_t [:] sorted_dupli_gradients, cnp.float_t [:] z,
-    cnp.float_t [:] steepest_slopes, cnp.int_t [:] links_to_receivers) nogil
-
-#######################################################################################
-
-cdef void _direct_flow_c(cnp.int_t nodes_n, const cnp.int_t[:] base_level_nodes,
-    const cnp.int_t[:] closed_nodes, cnp.int_t[:] sorted_pseudo_tails,
-    cnp.float_t[:] sorted_dupli_gradients, const cnp.int_t[:] sorted_dupli_links,
-    const cnp.int_t[:, :] head_start_end_indexes, cnp.int_t [:] outlet_nodes,
-    cnp.int_t [:] depression_outlet_nodes, cnp.int_t[:] flooded_nodes,
-    cnp.float_t[:] depression_depths, cnp.float_t [:] depression_free_elevations,
-    cnp.int_t[:] links_to_receivers, cnp.int_t[:] receivers,
-    cnp.float_t[:] steepest_slopes, cnp.float_t[:] z, cnp.int_t flooded_status,
-    cnp.int_t bad_index, cnp.int_t neighbors_max_number,
-    cnp.float_t min_elevation_relative_diff)
+    cnp.float_t [:] sorted_dupli_gradients,
+    cnp.float_t [:] z,
+    cnp.float_t [:] steepest_slopes,
+    cnp.int_t [:] links_to_receivers,
+) nogil
+
+
+cdef void _direct_flow_c(
+    cnp.int_t nodes_n,
+    const cnp.int_t[:] base_level_nodes,
+    const cnp.int_t[:] closed_nodes,
+    cnp.int_t[:] sorted_pseudo_tails,
+    cnp.float_t[:] sorted_dupli_gradients,
+    const cnp.int_t[:] sorted_dupli_links,
+    const cnp.int_t[:, :] head_start_end_indexes,
+    cnp.int_t [:] outlet_nodes,
+    cnp.int_t [:] depression_outlet_nodes,
+    cnp.int_t[:] flooded_nodes,
+    cnp.float_t[:] depression_depths,
+    cnp.float_t [:] depression_free_elevations,
+    cnp.int_t[:] links_to_receivers,
+    cnp.int_t[:] receivers,
+    cnp.float_t[:] steepest_slopes,
+    cnp.float_t[:] z,
+    cnp.int_t flooded_status,
+    cnp.int_t bad_index,
+    cnp.int_t neighbors_max_number,
+    cnp.float_t min_elevation_relative_diff,
+)
```

### Comparing `landlab-2.7.0/landlab/components/flow_router/ext/single_flow/priority_routing/breach.pyx` & `landlab-2.8.0/landlab/components/flow_router/ext/single_flow/priority_routing/breach.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
-#distutils: define_macros=NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION
-#distutils: extra_compile_args = -std=c++11
-#distutils: extra_link_args = -std=c++11
+# distutils: define_macros=NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION
+# distutils: extra_compile_args = -std=c++11
+# distutils: extra_link_args = -std=c++11
 """ Contains the cython functions for the component method
 Flow_router.run_directions(). Flow directions and depression handling are done
 adapting Barnes et al., 2014 algorithm #4."""
 
 import numpy as np
 
 cimport cython
@@ -20,23 +20,30 @@
         _priority_queue(...) except +
         void push(pair[cnp.int_t, cnp.float_t])
         pair[cnp.int_t, cnp.float_t] top() except +
         void pop()
         bool empty()
         cnp.int_t size()
 
+
 cdef bool _compare_second(pair[int, double] a, pair[int, double] b) nogil:
     return a.second > b.second
 
 
-@cython.boundscheck(False) # turn off bounds-checking for entire function
+@cython.boundscheck(False)  # turn off bounds-checking for entire function
 cdef void _init_flow_direction_queues(
-    const cnp.int_t [:] base_level_nodes, const cnp.int_t [:] closed_nodes,
-    cnp.float_t [:] z, _priority_queue& to_do, cnp.int_t [:] receivers,
-    cnp.int_t [:] outlet_nodes, cnp.int_t [:] done, cnp.int_t* done_n_ptr) nogil:
+    const cnp.int_t [:] base_level_nodes,
+    const cnp.int_t [:] closed_nodes,
+    cnp.float_t [:] z,
+    _priority_queue& to_do,
+    cnp.int_t [:] receivers,
+    cnp.int_t [:] outlet_nodes,
+    cnp.int_t [:] done,
+    cnp.int_t* done_n_ptr,
+) nogil:
     """
     Add the base-level nodes to the queue and update receivers for base-level and
     closed nodes. Updates to_do, receivers, outlet_nodes, done and the value pointed
     by done_n_ptr.
 
     Implementation remarks: It's important to pass the priority_queue to_do as a
     reference, otherwise it won't be modified. I didn't manage to use the bint type
@@ -71,35 +78,45 @@
     for i in range(n):
         # NB: for node_i in open_boundary raises a compiling error with nogil.
         node_id = base_level_nodes[i]
         node_pair = pair[cnp.int_t, cnp.float_t](node_id, z[node_id])
         to_do.push(node_pair)
         receivers[node_id] = node_id
         outlet_nodes[node_id] = node_id
-        done[node_id] = 1; done_n_ptr[0] +=1
+        done[node_id] = 1
+        done_n_ptr[0] += 1
 
     for i in range(m):
         node_id = closed_nodes[i]
         receivers[node_id] = node_id
         outlet_nodes[node_id] = node_id
-        done[node_id] = 1; done_n_ptr[0] +=1
+        done[node_id] = 1
+        done_n_ptr[0] += 1
         # NB: done_n_ptr[0]: method to dereference the pointer. The
         # cython.operator.dereference doesn't seem to work on this pointer to a
         # long-type variable.
 
 # 4. Functions necessary for the flow direction processing (Steps #11 - 20)
 ###########################################################################
 
+
 @cython.boundscheck(False)
-cdef void _set_flooded_and_outlet(cnp.int_t donor_id, cnp.float_t [:] z,
-    cnp.int_t [:] receivers, cnp.int_t [:] outlet_nodes,
-    cnp.int_t [:] depression_outlet_nodes, cnp.int_t [:] flooded_nodes,
-    cnp.float_t [:] depression_depths, cnp.float_t [:] depression_free_elevations,
-    cnp.int_t flooded_status, cnp.int_t bad_index,
-    cnp.float_t min_elevation_relative_diff) nogil:
+cdef void _set_flooded_and_outlet(
+    cnp.int_t donor_id,
+    cnp.float_t [:] z,
+    cnp.int_t [:] receivers,
+    cnp.int_t [:] outlet_nodes,
+    cnp.int_t [:] depression_outlet_nodes,
+    cnp.int_t [:] flooded_nodes,
+    cnp.float_t [:] depression_depths,
+    cnp.float_t [:] depression_free_elevations,
+    cnp.int_t flooded_status,
+    cnp.int_t bad_index,
+    cnp.float_t min_elevation_relative_diff,
+) nogil:
     """ Updates the base-level outlet nodes (outlet_nodes), the depression outlet
     nodes (depression_outlet_nodes), the flooded status (flooded_nodes), and the
     depths of the depressions (depression_depths) for the node donor_id depending
     on its surface z value and the one of its receiver outlet and neighbors.
 
     Parameters
     ----------
@@ -147,43 +164,54 @@
         depression_outlet_nodes[donor_id] = receiver_depression_outlet
         flooded_nodes[donor_id] = flooded_status
         depression_depths[donor_id] = z[receiver_depression_outlet] - z[donor_id]
         depression_free_elevations[donor_id] = (
             (1 + min_elevation_relative_diff) * depression_free_elevations[receiver_id]
         )
 
+
 @cython.boundscheck(False)
-cdef void _set_receiver(cnp.int_t donor_id, cnp.int_t receiver_id,
-    cnp.int_t [:] receivers, cnp.int_t [:] done, cnp.int_t* done_n_ptr) nogil:
+cdef void _set_receiver(
+    cnp.int_t donor_id,
+    cnp.int_t receiver_id,
+    cnp.int_t [:] receivers,
+    cnp.int_t [:] done,
+    cnp.int_t* done_n_ptr,
+) nogil:
     """ Updates the receiver (receivers) and the process statuses (done) of the donor
     node donor_id.
 
     Parameters
     ----------
     donor_id: long
         Id of the donor node.
     receiver_id: long
         Id of the receiver node.
     receivers: memoryview(long)
         Ids of the receivers for all donor nodes, ordered by the id of the donor nodes.
     done: memoryview(bool)
         Process statuses for all nodes. 1 for done. 0 otherwise.
     """
-    cdef cnp.int_t done_n
-
     receivers[donor_id] = receiver_id
-    done[donor_id] = 1 # 1 For True
+    done[donor_id] = 1  # 1 For True
     done_n_ptr[0] += 1
 
+
 @cython.boundscheck(False)
-cdef void _set_donor_properties(cnp.int_t donor_id, cnp.int_t receiver_id,
-    cnp.int_t [:] sorted_pseudo_tails, const cnp.int_t [:,:] head_start_end_indexes,
+cdef void _set_donor_properties(
+    cnp.int_t donor_id,
+    cnp.int_t receiver_id,
+    cnp.int_t [:] sorted_pseudo_tails,
+    const cnp.int_t [:, :] head_start_end_indexes,
     const cnp.int_t [:] sorted_dupli_links,
-    cnp.float_t [:] sorted_dupli_gradients, cnp.float_t [:] z,
-    cnp.float_t [:] steepest_slopes, cnp.int_t [:] links_to_receivers) nogil:
+    cnp.float_t [:] sorted_dupli_gradients,
+    cnp.float_t [:] z,
+    cnp.float_t [:] steepest_slopes,
+    cnp.int_t [:] links_to_receivers,
+) nogil:
     """ Updates the steepest_slopes and the links_to_receivers of a donor in function
     of the slopes with its neighbors and the head-tail links of the grid. Steepest
     slope is set to 0. if the donor is in a depression.
 
     Parameters
     ----------
     donor_id: long
@@ -213,15 +241,14 @@
     """
 
     # range of indexes where donor_id is founded in sorted_pseudo_heads
     cdef:
         cnp.int_t idx1 = head_start_end_indexes[0, donor_id]
         cnp.int_t idx2 = head_start_end_indexes[1, donor_id] + 1
 
-
         cnp.int_t [:] s = sorted_pseudo_tails[idx1:idx2]
         cnp.int_t n = len(s), c = -1, i
 
     # loop to bypass the impossibility to use
     # sorted_pseudo_tails[idx1:idx2] == receiver_id with memoryviews
     for i in range(n):
         if s[i] == receiver_id:
@@ -230,30 +257,41 @@
     steepest_slopes[donor_id] = (
         sorted_dupli_gradients[c] if (
             z[receiver_id] <= z[donor_id]
         ) else 0
     )
     links_to_receivers[donor_id] = sorted_dupli_links[c]
 
-#######################################################################################
-
+# ######################################################################################
 # Main functions to direct flow
-###############################
+
 
 @cython.boundscheck(False)
-cdef void _direct_flow_c(cnp.int_t nodes_n, const cnp.int_t[:] base_level_nodes,
-    const cnp.int_t[:] closed_nodes, cnp.int_t[:] sorted_pseudo_tails,
-    cnp.float_t[:] sorted_dupli_gradients, const cnp.int_t[:] sorted_dupli_links,
-    const cnp.int_t[:, :] head_start_end_indexes, cnp.int_t [:] outlet_nodes,
-    cnp.int_t [:] depression_outlet_nodes, cnp.int_t[:] flooded_nodes,
-    cnp.float_t[:] depression_depths, cnp.float_t[:] depression_free_elevations,
-    cnp.int_t[:] links_to_receivers, cnp.int_t[:] receivers,
-    cnp.float_t[:] steepest_slopes, cnp.float_t[:] z, cnp.int_t flooded_status,
-    cnp.int_t bad_index, cnp.int_t neighbors_max_number,
-    cnp.float_t min_elevation_relative_diff):
+cdef void _direct_flow_c(
+    cnp.int_t nodes_n,
+    const cnp.int_t[:] base_level_nodes,
+    const cnp.int_t[:] closed_nodes,
+    cnp.int_t[:] sorted_pseudo_tails,
+    cnp.float_t[:] sorted_dupli_gradients,
+    const cnp.int_t[:] sorted_dupli_links,
+    const cnp.int_t[:, :] head_start_end_indexes,
+    cnp.int_t [:] outlet_nodes,
+    cnp.int_t [:] depression_outlet_nodes,
+    cnp.int_t[:] flooded_nodes,
+    cnp.float_t[:] depression_depths,
+    cnp.float_t[:] depression_free_elevations,
+    cnp.int_t[:] links_to_receivers,
+    cnp.int_t[:] receivers,
+    cnp.float_t[:] steepest_slopes,
+    cnp.float_t[:] z,
+    cnp.int_t flooded_status,
+    cnp.int_t bad_index,
+    cnp.int_t neighbors_max_number,
+    cnp.float_t min_elevation_relative_diff,
+):
     """
     Main function implementing the flow directing through breaching depressions.
     Updates outlet_nodes, depression_outlet_nodes, flooded_nodes, links_to_receivers,
     receivers, steepest_slopes.
 
     Params
     ------
@@ -306,66 +344,102 @@
         Maximum number of neighbors in the grid.
     min_elevation_relative_diff: double
         Minimum relative difference in elevation for the depression_free_elevations
         surface.
     """
     cdef:
         cnp.int_t [:] done
-        cnp.int_t [:] tmp_neighbors
-        cnp.int_t [:] neighbors_to_do
+        # cnp.int_t [:] tmp_neighbors
+        # cnp.int_t [:] neighbors_to_do
         _priority_queue to_do = _priority_queue(_compare_second)
-        cnp.int_t receiver_id, donor_id, n, i, j, done_n
-        cnp.int_t [:] neighbors
+        cnp.int_t receiver_id, donor_id, i, j, done_n
+        # cnp.int_t [:] neighbors
         pair[cnp.int_t, cnp.float_t] node_pair
 
     done = np.full(nodes_n, 0, dtype=int)
-    tmp_neighbors = np.full(neighbors_max_number, 0, dtype=int)
-    neighbors_to_do = np.array([], dtype=int)
-    done_n = 0 # done_n is input only for MULTITHREADING, a future evolution, and
-               # is not checked in this function.
+    # tmp_neighbors = np.full(neighbors_max_number, 0, dtype=int)
+    # neighbors_to_do = np.array([], dtype=int)
+
+    # done_n is input only for MULTITHREADING, a future evolution, and
+    # is not checked in this function.
+    done_n = 0
 
-    _init_flow_direction_queues(base_level_nodes, closed_nodes, z, to_do,
-        receivers, outlet_nodes, done, &done_n)
+    _init_flow_direction_queues(
+        base_level_nodes, closed_nodes, z, to_do, receivers, outlet_nodes, done, &done_n
+    )
 
     for j in range(nodes_n):
         # a while loop is possible here, but prefer for loop, with future
         # multithreading evolution.
-        if to_do.empty() == True:
+        if to_do.empty():
             break
-        receiver_id = to_do.top().first; to_do.pop(); done[0] = 1
+        receiver_id = to_do.top().first
+        to_do.pop()
+        done[0] = 1
 
         # Get the neighbors to handle.
         idx1 = head_start_end_indexes[0, receiver_id]
         idx2 = head_start_end_indexes[1, receiver_id] + 1
 
         # Handle each neighbor.
         for i in range(idx1, idx2):
-            donor_id = sorted_pseudo_tails[i];
-            if done[donor_id] == 1: continue # 0 for False.
+            donor_id = sorted_pseudo_tails[i]
+            if done[donor_id] == 1:
+                continue  # 0 for False.
             _set_receiver(donor_id, receiver_id, receivers, done, &done_n)
-            _set_flooded_and_outlet(donor_id, z, receivers, outlet_nodes,
-                depression_outlet_nodes, flooded_nodes, depression_depths,
-                depression_free_elevations, flooded_status, bad_index,
-                min_elevation_relative_diff)
-            _set_donor_properties(donor_id, receiver_id, sorted_pseudo_tails,
-                head_start_end_indexes, sorted_dupli_links, sorted_dupli_gradients,
-                z, steepest_slopes, links_to_receivers)
+            _set_flooded_and_outlet(
+                donor_id,
+                z,
+                receivers,
+                outlet_nodes,
+                depression_outlet_nodes,
+                flooded_nodes,
+                depression_depths,
+                depression_free_elevations,
+                flooded_status,
+                bad_index,
+                min_elevation_relative_diff,
+            )
+            _set_donor_properties(
+                donor_id,
+                receiver_id,
+                sorted_pseudo_tails,
+                head_start_end_indexes,
+                sorted_dupli_links,
+                sorted_dupli_gradients,
+                z,
+                steepest_slopes,
+                links_to_receivers,
+            )
             node_pair = pair[cnp.int_t, cnp.float_t](donor_id, z[donor_id])
             to_do.push(node_pair)
 
-def _direct_flow(cnp.int_t nodes_n, const cnp.int_t[:] base_level_nodes,
-    const cnp.int_t[:] closed_nodes, cnp.int_t[:] sorted_pseudo_tails,
-    cnp.float_t[:] sorted_dupli_gradients, const cnp.int_t[:] sorted_dupli_links,
-    const cnp.int_t[:, :] head_start_end_indexes, cnp.int_t [:] outlet_nodes,
-    cnp.int_t [:] depression_outlet_nodes, cnp.int_t[:] flooded_nodes,
-    cnp.float_t[:] depression_depths, cnp.float_t[:] depression_free_elevations,
-    cnp.int_t[:] links_to_receivers, cnp.int_t[:] receivers,
-    cnp.float_t[:] steepest_slopes, cnp.float_t[:] z, cnp.int_t flooded_status,
-    cnp.int_t bad_index, cnp.int_t neighbors_max_number,
-    cnp.float_t min_elevation_relative_diff):
+
+def _direct_flow(
+    cnp.int_t nodes_n,
+    const cnp.int_t[:] base_level_nodes,
+    const cnp.int_t[:] closed_nodes,
+    cnp.int_t[:] sorted_pseudo_tails,
+    cnp.float_t[:] sorted_dupli_gradients,
+    const cnp.int_t[:] sorted_dupli_links,
+    const cnp.int_t[:, :] head_start_end_indexes,
+    cnp.int_t [:] outlet_nodes,
+    cnp.int_t [:] depression_outlet_nodes,
+    cnp.int_t[:] flooded_nodes,
+    cnp.float_t[:] depression_depths,
+    cnp.float_t[:] depression_free_elevations,
+    cnp.int_t[:] links_to_receivers,
+    cnp.int_t[:] receivers,
+    cnp.float_t[:] steepest_slopes,
+    cnp.float_t[:] z,
+    cnp.int_t flooded_status,
+    cnp.int_t bad_index,
+    cnp.int_t neighbors_max_number,
+    cnp.float_t min_elevation_relative_diff,
+):
     """
     Main function calling the function that implements flow directing through
     breaching depressions. Updates outlet_nodes, depression_outlet_nodes,
     flooded_nodes, links_to_receivers, receivers, steepest_slopes.
 
     Params
     ------
@@ -416,15 +490,29 @@
         Constant for bad index.
     neighbors_max_number: long
         Maximum number of neighbors in the grid.
     min_elevation_relative_diff: double
         Minimum relative difference in elevation for the depression_free_elevations
         surface.
     """
-    _direct_flow_c(nodes_n, base_level_nodes, closed_nodes,
-                    sorted_pseudo_tails, sorted_dupli_gradients,
-                    sorted_dupli_links, head_start_end_indexes,
-                    outlet_nodes, depression_outlet_nodes,
-                    flooded_nodes, depression_depths, depression_free_elevations,
-                    links_to_receivers, receivers, steepest_slopes, z,
-                    flooded_status, bad_index, neighbors_max_number,
-                    min_elevation_relative_diff)
+    _direct_flow_c(
+        nodes_n,
+        base_level_nodes,
+        closed_nodes,
+        sorted_pseudo_tails,
+        sorted_dupli_gradients,
+        sorted_dupli_links,
+        head_start_end_indexes,
+        outlet_nodes,
+        depression_outlet_nodes,
+        flooded_nodes,
+        depression_depths,
+        depression_free_elevations,
+        links_to_receivers,
+        receivers,
+        steepest_slopes,
+        z,
+        flooded_status,
+        bad_index,
+        neighbors_max_number,
+        min_elevation_relative_diff,
+    )
```

### Comparing `landlab-2.7.0/landlab/components/fracture_grid/fracture_grid.py` & `landlab-2.8.0/landlab/components/fracture_grid/fracture_grid.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,15 +4,17 @@
 
 Created: September 2013 by Greg Tucker
 Last significant modification: conversion to proper component 7/2019 GT
 """
 
 import numpy as np
 
-from landlab import Component, HexModelGrid, RasterModelGrid
+from landlab import Component
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 
 
 def _calc_fracture_starting_position_raster(shape):
     """Choose a random starting position along one of the sides of the grid.
 
     Parameters
     ----------
@@ -135,27 +137,27 @@
     (dy, dx) : tuple of float
         Step sizes in y and x directions. One will always be unity, and the
         other will always be <1.
 
     Examples
     --------
     >>> np.round(_calc_fracture_step_sizes(0 * np.pi / 6), 3)
-    array([ 1.,  0.])
+    array([1., 0.])
     >>> np.round(_calc_fracture_step_sizes(1 * np.pi / 6), 3)
-    array([ 1.   , 0.577])
+    array([1.   , 0.577])
     >>> np.round(_calc_fracture_step_sizes(2 * np.pi / 6), 3)
-    array([ 0.577,  1.   ])
+    array([0.577, 1.   ])
     >>> np.round(_calc_fracture_step_sizes(3 * np.pi / 6), 3)
-    array([ 0., 1.])
+    array([0., 1.])
     >>> np.round(_calc_fracture_step_sizes(4 * np.pi / 6), 3)
-    array([-0.577, 1.   ])
+    array([-0.577,  1.   ])
     >>> np.round(_calc_fracture_step_sizes(5 * np.pi / 6), 3)
-    array([-1.   , 0.577])
+    array([-1.   ,  0.577])
     >>> np.round(_calc_fracture_step_sizes(6 * np.pi / 6), 3)
-    array([-1., 0.])
+    array([-1.,  0.])
     >>> np.round(_calc_fracture_step_sizes(7 * np.pi / 6), 3)
     array([-1.   , -0.577])
     >>> np.round(_calc_fracture_step_sizes(8 * np.pi / 6), 3)
     array([-0.577, -1.   ])
     >>> np.round(_calc_fracture_step_sizes(9 * np.pi / 6), 3)
     array([-0., -1.])
     >>> np.round(_calc_fracture_step_sizes(10 * np.pi / 6), 3)
@@ -208,15 +210,14 @@
     ):
         m[int(y + 0.5)][int(x + 0.5)] = 1
         x += dx
         y += dy
 
 
 class FractureGridGenerator(Component):
-
     """Create a 2D grid with randomly generated fractures.
 
     The grid contains the value 1 where fractures (one cell wide) exist, and
     0 elsewhere. The idea is to use this for simulations based on weathering
     and erosion of, and/or flow within, fracture networks.
 
     Examples
```

### Comparing `landlab-2.7.0/landlab/components/gflex/flexure.py` & `landlab-2.8.0/landlab/components/gflex/flexure.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,19 +14,20 @@
 Created on Thu Feb 19 18:47:11 2015
 
 @author: daniel.hobley (SiccarPoint @Github)
 
 ...following AW's run_in_script_2D.py.
 """
 
-
 import numpy as np
 import scipy.constants
 
-from landlab import Component, FieldError, RasterModelGrid
+from landlab import Component
+from landlab import FieldError
+from landlab import RasterModelGrid
 
 try:
     import gflex
 except ImportError:
     NO_GFLEX = True
 else:
     NO_GFLEX = False
```

### Comparing `landlab-2.7.0/landlab/components/gravel_bedrock_eroder/gravel_bedrock_eroder.py` & `landlab-2.8.0/landlab/components/gravel_bedrock_eroder/gravel_bedrock_eroder.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,16 @@
 Model bedrock incision and gravel transport and abrasion in a network of rivers.
 
 @author: gtucker
 """
 
 import numpy as np
 
-from landlab import Component, HexModelGrid
+from landlab import Component
+from landlab import HexModelGrid
 from landlab.grid.diagonals import DiagonalsMixIn
 
 _DT_MAX = 1.0e-2
 _ONE_SIXTH = 1.0 / 6.0
 _SEVEN_SIXTHS = 7.0 / 6.0
 
 
@@ -434,20 +435,20 @@
         >>> sed[4] = 1000.0
         >>> sed[5] = 0.0
         >>> fa = FlowAccumulator(grid)
         >>> fa.run_one_step()
         >>> eroder = GravelBedrockEroder(grid)
         >>> eroder.calc_rock_exposure_fraction()
         >>> eroder._rock_exposure_fraction[4:6]
-        array([ 0.,  1.])
+        array([0., 1.])
         >>> sed[4] = 1.0  # exposure frac should be 1/e ~ 0.3679
         >>> sed[5] = 2.0  # exposure frac should be 1/e^2 ~ 0.1353
         >>> eroder.calc_rock_exposure_fraction()
         >>> np.round(eroder._rock_exposure_fraction[4:6], 4)
-        array([ 0.3679,  0.1353])
+        array([0.3679, 0.1353])
         """
         self._rock_exposure_fraction[:] = np.exp(-self._sed / self._depth_decay_scale)
 
     def calc_transport_rate(self):
         """Calculate and return bed-load transport rate.
 
         Calculation uses Wickert-Schildgen approach, and provides
@@ -538,21 +539,21 @@
         >>> fa.run_one_step()
         >>> eroder = GravelBedrockEroder(grid, abrasion_coefficient=1.0e-4)
         >>> eroder.calc_rock_exposure_fraction()
         >>> round(eroder._rock_exposure_fraction[6], 4)
         0.3679
         >>> eroder.calc_transport_rate()
         >>> np.round(eroder._sediment_outflux[5:7], 3)
-        array([ 0.024,  0.012])
+        array([0.024, 0.012])
         >>> eroder.calc_abrasion_rate()
         >>> np.round(eroder._abrasion[5:7], 9)
-        array([  1.20000000e-08,   6.00000000e-09])
+        array([1.2e-08, 6.0e-09])
         >>> eroder.calc_bedrock_abrasion_rate()
         >>> np.round(eroder._rock_abrasion_rate[5:7], 10)
-        array([  4.40000000e-09,   2.20000000e-09])
+        array([4.4e-09, 2.2e-09])
         """
         self._rock_abrasion_rate = self._abrasion * self._rock_exposure_fraction
 
     def calc_bedrock_plucking_rate(self):
         """Update the rate of bedrock erosion by plucking.
 
         The rate is a volume per area per time [L/T], equivalent to the
@@ -620,19 +621,19 @@
         >>> fa = FlowAccumulator(grid)
         >>> fa.run_one_step()
         >>> eroder = GravelBedrockEroder(grid)
         >>> eroder.calc_transport_rate()
         >>> eroder.calc_sediment_influx()
         >>> eroder.calc_sediment_rate_of_change()
         >>> np.round(eroder._sediment_outflux[4:7], 3)
-        array([ 0.   ,  0.038,  0.019])
+        array([0.   , 0.038, 0.019])
         >>> np.round(eroder._sediment_influx[4:7], 3)
-        array([ 0.038,  0.019,  0.   ])
+        array([0.038, 0.019, 0.   ])
         >>> np.round(eroder._dHdt[5:7], 8)
-        array([ -2.93000000e-06,  -2.93000000e-06])
+        array([-2.93e-06, -2.93e-06])
         """
         cores = self.grid.core_nodes
         self._dHdt[cores] = self._porosity_factor * (
             (self._sediment_influx[cores] - self._sediment_outflux[cores])
             / self.grid.area_of_cell[self.grid.cell_at_node[cores]]
             + (self._pluck_rate[cores] * self._pluck_coarse_frac)
             - self._abrasion[cores]
@@ -677,15 +678,15 @@
         >>> grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
         >>> grid.status_at_node[4] = grid.BC_NODE_IS_FIXED_VALUE
         >>> fa = FlowAccumulator(grid)
         >>> fa.run_one_step()
         >>> eroder = GravelBedrockEroder(grid)
         >>> eroder.run_one_step(1000.0)
         >>> np.round(elev[4:7], 4)
-        array([ 0.    ,  0.9971,  1.9971])
+        array([0.    , 0.9971, 1.9971])
         """
         self._update_slopes()
         self.calc_rock_exposure_fraction()
         self.calc_transport_rate()
         self.calc_sediment_influx()
 
         if self._flow_length_is_variable:
```

### Comparing `landlab-2.7.0/landlab/components/gravel_river_transporter/gravel_river_transporter.py` & `landlab-2.8.0/landlab/components/gravel_river_transporter/gravel_river_transporter.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import numpy as np
 from scipy.sparse.linalg import spsolve
 
-from landlab import Component, HexModelGrid
+from landlab import Component
+from landlab import HexModelGrid
 from landlab.grid.diagonals import DiagonalsMixIn
 
 
 def make_empty_matrix_and_rhs(grid):
     from scipy.sparse import csc_matrix
 
     mat = csc_matrix((grid.number_of_core_nodes, grid.number_of_core_nodes))
@@ -427,19 +428,19 @@
         >>> grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
         >>> grid.status_at_node[4] = grid.BC_NODE_IS_FIXED_VALUE
         >>> fa = FlowAccumulator(grid)
         >>> fa.run_one_step()
         >>> transporter = GravelRiverTransporter(grid)
         >>> transporter.calc_sediment_rate_of_change()
         >>> np.round(transporter._sediment_outflux[4:7], 3)
-        array([ 0.   ,  0.038,  0.019])
+        array([0.   , 0.038, 0.019])
         >>> np.round(transporter._sediment_influx[4:7], 3)
-        array([ 0.038,  0.019,  0.   ])
+        array([0.038, 0.019, 0.   ])
         >>> np.round(transporter._dzdt[5:7], 8)
-        array([ -2.93000000e-06,  -2.93000000e-06])
+        array([-2.93e-06, -2.93e-06])
         """
         self.calc_transport_capacity()
         if self._abrasion_coef > 0.0:
             self.calc_abrasion_rate()
         cores = self.grid.core_nodes
         self._sediment_influx[:] = 0.0
         for c in cores:  # send sediment downstream
@@ -465,15 +466,15 @@
         >>> grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
         >>> grid.status_at_node[4] = grid.BC_NODE_IS_FIXED_VALUE
         >>> fa = FlowAccumulator(grid)
         >>> fa.run_one_step()
         >>> transporter = GravelRiverTransporter(grid, solver="explicit")
         >>> transporter.run_one_step(1000.0)
         >>> np.round(elev[4:7], 4)
-        array([ 0.    ,  0.9971,  1.9971])
+        array([0.    , 0.9971, 1.9971])
         """
         self.calc_sediment_rate_of_change()
         self._elev += self._dzdt * dt
 
     def _fill_matrix_and_rhs(self, dt):
         """Fill out entries in a sparse matrix and corresponding right-hand side
         vector.
@@ -486,22 +487,22 @@
         >>> elev = grid.add_zeros("topographic__elevation", at="node")
         >>> elev[:] = 0.01 * grid.x_of_node
         >>> grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
         >>> grid.status_at_node[4] = grid.BC_NODE_IS_FIXED_VALUE
         >>> fa = FlowAccumulator(grid)
         >>> transporter = GravelRiverTransporter(grid, solver="matrix")
         >>> transporter._mat.toarray()
-        array([[ 0.,  0.],
-               [ 0.,  0.]])
+        array([[0., 0.],
+               [0., 0.]])
         >>> fa.run_one_step()
         >>> transporter._receiver_node[5:7]
         array([4, 5])
         >>> transporter._fill_matrix_and_rhs(1000.0)
         >>> transporter._rhs
-        array([ 1.,  2.])
+        array([1., 2.])
         """
         prefac = (
             self._trans_coef * self._intermittency_factor * self._porosity_factor * dt
         ) / self.grid.dx**2
         a = prefac * (1.0 / self.grid.dx + self._abrasion_coef / 2)
         b = prefac * (1.0 / self.grid.dx - self._abrasion_coef / 2)
         f = self._discharge * (self._slope ** (self._ONE_SIXTH))
```

### Comparing `landlab-2.7.0/landlab/components/groundwater/README.md` & `landlab-2.8.0/landlab/components/groundwater/README.md`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/groundwater/dupuit_percolator.py` & `landlab-2.8.0/landlab/components/groundwater/dupuit_percolator.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 """GroundwaterDupuitPercolator Component.
 
 @author: G Tucker, D Litwin, K Barnhart
 """
+
 from warnings import warn
 
 import numpy as np
 
 from landlab import Component
-from landlab.grid.mappers import (
-    map_mean_of_link_nodes_to_link,
-    map_value_at_max_node_to_link,
-)
-from landlab.utils import return_array_at_link, return_array_at_node
+from landlab.grid.mappers import map_mean_of_link_nodes_to_link
+from landlab.grid.mappers import map_value_at_max_node_to_link
+from landlab.utils import return_array_at_link
+from landlab.utils import return_array_at_node
 
 
 # regularization functions used to deal with numerical demons of seepage
 def _regularize_G(u, reg_factor):
     """Smooths transition of step function with an exponential.
 
     0<=u<=1.
```

### Comparing `landlab-2.7.0/landlab/components/hack_calculator/hack_calculator.py` & `landlab-2.8.0/landlab/components/hack_calculator/hack_calculator.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 """Calculate Hack parameters."""
+
 import collections
 from itertools import chain
 
 import numpy as np
 import pandas as pd
 from scipy.optimize import curve_fit
```

### Comparing `landlab-2.7.0/landlab/components/hand_calculator/hand_calculator.py` & `landlab-2.8.0/landlab/components/hand_calculator/hand_calculator.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 """Landlab component to calculate height above nearest drainage.
 
 @author: D Litwin
 """
+
 from warnings import warn
 
 import numpy as np
 
 from landlab import Component
 from landlab.utils import return_array_at_node
 
@@ -41,37 +42,37 @@
     ... )
     >>> elev = np.array(
     ...     [[2, 1, 0, 1, 2], [3, 2, 1, 2, 3], [4, 3, 2, 3, 4], [5, 4, 4, 4, 5]]
     ... )
     >>> z[:] = elev.reshape(len(z))
     >>> elev
     array([[2, 1, 0, 1, 2],
-       [3, 2, 1, 2, 3],
-       [4, 3, 2, 3, 4],
-       [5, 4, 4, 4, 5]])
+           [3, 2, 1, 2, 3],
+           [4, 3, 2, 3, 4],
+           [5, 4, 4, 4, 5]])
 
     >>> fa = FlowAccumulator(mg, flow_director="D8")
     >>> fa.run_one_step()
 
     >>> channel__mask = mg.zeros(at="node")
     >>> channel__mask[[2, 7]] = 1
     >>> channel__mask.reshape(elev.shape)
-    array([[ 0.,  0.,  1.,  0.,  0.],
-       [ 0.,  0.,  1.,  0.,  0.],
-       [ 0.,  0.,  0.,  0.,  0.],
-       [ 0.,  0.,  0.,  0.,  0.]])
+    array([[0., 0., 1., 0., 0.],
+           [0., 0., 1., 0., 0.],
+           [0., 0., 0., 0., 0.],
+           [0., 0., 0., 0., 0.]])
 
     >>> hd = HeightAboveDrainageCalculator(mg, channel_mask=channel__mask)
     >>> hd.run_one_step()
 
     >>> mg.at_node["height_above_drainage__elevation"].reshape(elev.shape)
-    array([[ 2.,  0.,  0.,  0.,  0.],
-           [ 3.,  2.,  0.,  2.,  3.],
-           [ 4.,  2.,  1.,  2.,  4.],
-           [ 5.,  4.,  4.,  4.,  5.]])
+    array([[2., 0., 0., 0., 0.],
+           [3., 2., 0., 2., 3.],
+           [4., 2., 1., 2., 4.],
+           [5., 4., 4., 4., 5.]])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     None Listed
```

### Comparing `landlab-2.7.0/landlab/components/lake_fill/lake_fill_barnes.py` & `landlab-2.8.0/landlab/components/lake_fill/lake_fill_barnes.py`

 * *Files 0% similar despite different names*

```diff
@@ -9,15 +9,17 @@
 
 import heapq
 import itertools
 from collections import deque
 
 import numpy as np
 
-from landlab import Component, NodeStatus, RasterModelGrid
+from landlab import Component
+from landlab import NodeStatus
+from landlab import RasterModelGrid
 from landlab.components import FlowAccumulator
 from landlab.utils import StablePriorityQueue
 from landlab.utils.return_array import return_array_at_node
 
 LARGE_ELEV = 9999999999.0
 
 # TODO: Needs to have rerouting functionality...
@@ -1743,15 +1745,15 @@
         >>> fd.run_one_step()
         >>> fa.run_one_step()
         >>> lmb.run_one_step()
 
         Lake node depths are now updated in lmb:
 
         >>> np.round([lmb.lake_depths[lake] for lake in lmb.lake_dict.values()], 2)
-        array([[ 0.45,  1.45]])
+        array([[0.45, 1.45]])
 
         ...and the "topography" (i.e., water surface) at the flooded nodes
         has lowered itself as the lip of the outlet was eroded in the last
         step:
 
         >>> np.all(
         ...     np.equal(
```

### Comparing `landlab-2.7.0/landlab/components/landslides/landslide_probability.py` & `landlab-2.8.0/landlab/components/landslides/landslide_probability.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/lateral_erosion/lateral_erosion.py` & `landlab-2.8.0/landlab/components/lateral_erosion/lateral_erosion.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 """Grid-based simulation of lateral erosion by channels in a drainage network.
 
 ALangston
 """
 
 import numpy as np
 
-from landlab import Component, RasterModelGrid
+from landlab import Component
+from landlab import RasterModelGrid
 from landlab.components.flow_accum import FlowAccumulator
 
 from .node_finder import node_finder
 
 # Hard coded constants
 cfl_cond = 0.3  # CFL timestep condition
 wid_coeff = 0.4  # coefficient for calculating channel width
@@ -95,48 +96,48 @@
     ...     mg.at_node["topographic__elevation"][mg.core_nodes] += U * dt
     ...
 
     Before lateral erosion occurs, *volume__lateral_erosion* has values at
     nodes 6 and 10.
 
     >>> np.around(oldlatvol, decimals=0)
-    array([  0.,   0.,   0.,   0.,
-             0.,   0.,  79.,   0.,
-             0.,   0.,  24.,   0.,
-             0.,   0.,   0.,   0.,
-             0.,   0.,   0.,   0.])
+    array([ 0.,  0., 0., 0.,
+            0.,  0., 79., 0.,
+            0.,  0., 24., 0.,
+            0.,  0., 0., 0.,
+            0.,  0., 0., 0.])
 
 
     After lateral erosion occurs at node 6, *volume__lateral_erosion* is reset to 0
 
     >>> np.around(newlatvol, decimals=0)
-    array([  0.,   0.,   0.,   0.,
-             0.,   0.,   0.,   0.,
-             0.,   0.,  24.,   0.,
-             0.,   0.,   0.,   0.,
-             0.,   0.,   0.,   0.])
+    array([ 0.,  0.,  0.,  0.,
+            0.,  0.,  0.,  0.,
+            0.,  0., 24.,  0.,
+            0.,  0.,  0.,  0.,
+            0.,  0.,  0.,  0.])
 
 
     After lateral erosion at node 6, elevation at node 6 is reduced by -1.41
     (the elevation change stored in dzlat[6]). It is also provided as the
     at-node grid field *lateral_erosion__depth_increment*.
 
     >>> np.around(oldelev, decimals=2)
-    array([ 0.  ,  1.03,  2.03,  3.  ,
-            1.04,  1.77,  2.45,  4.08,
-            2.09,  2.65,  3.18,  5.09,
-            3.04,  3.65,  4.07,  6.03,
-            4.03,  5.09,  6.02,  7.1 ])
+    array([0.  , 1.03, 2.03, 3.  ,
+           1.04, 1.77, 2.45, 4.08,
+           2.09, 2.65, 3.18, 5.09,
+           3.04, 3.65, 4.07, 6.03,
+           4.03, 5.09, 6.02, 7.1 ])
 
     >>> np.around(newelev, decimals=2)
-    array([ 0.  ,  1.03,  2.03,  3.  ,
-            1.04,  1.77,  1.03,  4.08,
-            2.09,  2.65,  3.18,  5.09,
-            3.04,  3.65,  4.07,  6.03,
-            4.03,  5.09,  6.02,  7.1 ])
+    array([0.  , 1.03, 2.03, 3.  ,
+           1.04, 1.77, 1.03, 4.08,
+           2.09, 2.65, 3.18, 5.09,
+           3.04, 3.65, 4.07, 6.03,
+           4.03, 5.09, 6.02, 7.1 ])
 
     >>> np.around(dzlat, decimals=2)
     array([ 0.  ,  0.  ,  0.  ,  0.  ,
             0.  ,  0.  , -1.41,  0.  ,
             0.  ,  0.  ,  0.  ,  0.  ,
             0.  ,  0.  ,  0.  ,  0.  ,
             0.  ,  0.  ,  0.  ,  0. ])
```

### Comparing `landlab-2.7.0/landlab/components/lateral_erosion/node_finder.py` & `landlab-2.8.0/landlab/components/lateral_erosion/node_finder.py`

 * *Files 0% similar despite different names*

```diff
@@ -26,15 +26,15 @@
     >>> from landlab import RasterModelGrid
     >>> from landlab.components.lateral_erosion.node_finder import angle_finder
 
     >>> grid = RasterModelGrid((3, 4))
     >>> np.rad2deg(angle_finder(grid, 8, 5, 0))
     90.0
     >>> np.rad2deg(angle_finder(grid, (8, 9, 10, 6), 5, 6))
-    array([ 135.,   90.,   45.,    0.])
+    array([135.,  90.,  45.,   0.])
     """
     vertex = np.take(grid.x_of_node, cn), np.take(grid.y_of_node, cn)
     vec_1 = [
         np.take(grid.x_of_node, dn) - vertex[0],
         np.take(grid.y_of_node, dn) - vertex[1],
     ]
     vec_2 = [
```

### Comparing `landlab-2.7.0/landlab/components/lithology/README.md` & `landlab-2.8.0/landlab/components/lithology/README.md`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/lithology/litholayers.py` & `landlab-2.8.0/landlab/components/lithology/litholayers.py`

 * *Files 26% similar despite different names*

```diff
@@ -3,15 +3,14 @@
 
 import numpy as np
 
 from landlab.components.lithology.lithology import Lithology
 
 
 class LithoLayers(Lithology):
-
     """Create LithoLayers component.
 
     A LithoLayers is a three dimentional representation of material operated on
     by landlab components. Material can be removed through erosion or added to
     through deposition. Rock types can have multiple attributes (e.g. age,
     erodability or other parameter values, etc).
 
@@ -125,45 +124,44 @@
         layers of type 1 and type 2 rock.
 
         >>> z0s = [-4, -3, -2, -1, 0, 1, 2, 3, 4]
         >>> ids = [1, 2, 1, 2, 1, 2, 1, 2, 1]
         >>> attrs = {"K_sp": {1: 0.001, 2: 0.0001}}
         >>> lith = LithoLayers(mg, z0s, ids, attrs)
         >>> lith.dz
-        array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
-               [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
-               [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
-               [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
-               [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])
+        array([[1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [0., 0., 0., 0., 0., 0., 0., 0., 0.],
+               [0., 0., 0., 0., 0., 0., 0., 0., 0.],
+               [0., 0., 0., 0., 0., 0., 0., 0., 0.],
+               [0., 0., 0., 0., 0., 0., 0., 0., 0.],
+               [0., 0., 0., 0., 0., 0., 0., 0., 0.]])
 
         Now create a set of layers that dip. Our anchor point will be the
         default value of (x0, y0) = (0, 0)
 
         >>> lith = LithoLayers(mg, z0s, ids, attrs, function=lambda x, y: x + y)
         >>> lith.dz
-        array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 0.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 0.,  0.,  1.,  0.,  1.,  1.,  1.,  1.,  1.],
-               [ 0.,  0.,  0.,  0.,  0.,  1.,  0.,  1.,  1.],
-               [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.],
-               [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])
+        array([[1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [0., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [0., 0., 1., 0., 1., 1., 1., 1., 1.],
+               [0., 0., 0., 0., 0., 1., 0., 1., 1.],
+               [0., 0., 0., 0., 0., 0., 0., 0., 1.],
+               [0., 0., 0., 0., 0., 0., 0., 0., 0.]])
 
         We can get the surface values, and as we'd expect, they alternate as
         the dipping layers are exposed at the surface.
 
         >>> lith["K_sp"]
-        array([ 0.0001,  0.001 ,  0.0001,  0.001 ,  0.0001,  0.001 ,  0.0001,
-                0.001 ,  0.0001])
+        array([0.0001, 0.001 , 0.0001, 0.001 , 0.0001, 0.001 , 0.0001, 0.001 , 0.0001])
         """
 
         function_args = function.__code__.co_varnames
         if len(function_args) != 2:
             raise ValueError(
                 "LithoLayers: function must take exactly two arguments, x and y."
             )
```

### Comparing `landlab-2.7.0/landlab/components/lithology/lithology.py` & `landlab-2.8.0/landlab/components/lithology/lithology.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 """Create a Lithology object with different properties."""
 
 import numpy as np
 import xarray as xr
 from scipy.interpolate import interp1d
 
 from landlab import Component
-from landlab.layers import EventLayers, MaterialLayers
+from landlab.layers import EventLayers
+from landlab.layers import MaterialLayers
 from landlab.utils.return_array import return_array_at_node
 
 
 class Lithology(Component):
-
     """Create a Lithology object.
 
     A Lithology is a three dimentional representation of material operated on
     by landlab components. Material can be removed through erosion or added to
     through deposition. Rock types can have multiple attributes (e.g. age,
     erodability or other parameter values, etc).
 
@@ -135,33 +135,31 @@
         >>> attrs = {"K_sp": {1: 0.001, 2: 0.0001}}
         >>> lith = Lithology(mg, thicknesses, ids, attrs)
 
         After creating a Lithology, the model grid will have an at-node grid
         field set to the surface values of 'K_sp'.
 
         >>> mg.at_node["K_sp"]
-        array([ 0.001,  0.001,  0.001,  0.001,  0.001,  0.001,  0.001,  0.001,
-                0.001])
+        array([0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001])
 
         The surface values are also properties of the Lithology.
 
         >>> lith["K_sp"]
-        array([ 0.001,  0.001,  0.001,  0.001,  0.001,  0.001,  0.001,  0.001,
-                0.001])
+        array([0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001])
 
         We can access information about the Lithology like the total thickness
         or layer thicknesses.
 
         >>> lith.thickness
-        array([ 8.,  8.,  8.,  8.,  8.,  8.,  8.,  8.,  8.])
+        array([8., 8., 8., 8., 8., 8., 8., 8., 8.])
         >>> lith.dz
-        array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 4.,  4.,  4.,  4.,  4.,  4.,  4.,  4.,  4.],
-               [ 2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.],
-               [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.]])
+        array([[1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [4., 4., 4., 4., 4., 4., 4., 4., 4.],
+               [2., 2., 2., 2., 2., 2., 2., 2., 2.],
+               [1., 1., 1., 1., 1., 1., 1., 1., 1.]])
 
         This might look confusing -- that the layers are in reverse order, but
         it is OK. The last layers in the Lithology are those that are closest
         to the surface.
 
         The layers don't all have to have the same thickness as in the prior
         example. If the layers have non-uniform thickness, then they must be
@@ -173,19 +171,19 @@
         the model grid.
 
         >>> layer_pattern = (0.5 * mg.x_of_node) + 1.0
         >>> thicknesses = [1 * layer_pattern, 2 * layer_pattern, 4 * layer_pattern]
         >>> ids = [1, 2, 1]
         >>> lith = Lithology(mg, thicknesses, ids, attrs)
         >>> lith.thickness
-        array([  7. ,  10.5,  14. ,   7. ,  10.5,  14. ,   7. ,  10.5,  14. ])
+        array([ 7. , 10.5, 14. ,  7. , 10.5, 14. ,  7. , 10.5, 14. ])
         >>> lith.dz
-        array([[ 4. ,  6. ,  8. ,  4. ,  6. ,  8. ,  4. ,  6. ,  8. ],
-               [ 2. ,  3. ,  4. ,  2. ,  3. ,  4. ,  2. ,  3. ,  4. ],
-               [ 1. ,  1.5,  2. ,  1. ,  1.5,  2. ,  1. ,  1.5,  2. ]])
+        array([[4. , 6. , 8. , 4. , 6. , 8. , 4. , 6. , 8. ],
+               [2. , 3. , 4. , 2. , 3. , 4. , 2. , 3. , 4. ],
+               [1. , 1.5, 2. , 1. , 1.5, 2. , 1. , 1.5, 2. ]])
         """
         super().__init__(grid)
 
         try:
             self._last_elevation = self._grid["node"]["topographic__elevation"][
                 :
             ].copy()
@@ -393,15 +391,15 @@
         >>> mg = RasterModelGrid((3, 3))
         >>> z = mg.add_zeros("topographic__elevation", at="node")
         >>> thicknesses = [1, 2, 4, 1]
         >>> ids = [1, 2, 1, 2]
         >>> attrs = {"K_sp": {1: 0.001, 2: 0.0001}}
         >>> lith = Lithology(mg, thicknesses, ids, attrs)
         >>> lith.thickness
-        array([ 8.,  8.,  8.,  8.,  8.,  8.,  8.,  8.,  8.])
+        array([8., 8., 8., 8., 8., 8., 8., 8., 8.])
         """
         return self._layers.thickness
 
     @property
     def dz(self):
         """Thickness of each layer in the Lithology at each node.
 
@@ -415,18 +413,18 @@
         >>> mg = RasterModelGrid((3, 3))
         >>> z = mg.add_zeros("topographic__elevation", at="node")
         >>> thicknesses = [1, 2, 4, 1]
         >>> ids = [1, 2, 1, 2]
         >>> attrs = {"K_sp": {1: 0.001, 2: 0.0001}}
         >>> lith = Lithology(mg, thicknesses, ids, attrs)
         >>> lith.dz
-        array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 4.,  4.,  4.,  4.,  4.,  4.,  4.,  4.,  4.],
-               [ 2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.],
-               [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.]])
+        array([[1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [4., 4., 4., 4., 4., 4., 4., 4., 4.],
+               [2., 2., 2., 2., 2., 2., 2., 2., 2.],
+               [1., 1., 1., 1., 1., 1., 1., 1., 1.]])
         """
         return self._layers.dz
 
     @property
     def z_bottom(self):
         """Thickness from the surface to the bottom of each layer in Lithology.
 
@@ -440,18 +438,18 @@
         >>> mg = RasterModelGrid((3, 3))
         >>> z = mg.add_zeros("topographic__elevation", at="node")
         >>> thicknesses = [1, 2, 4, 1]
         >>> ids = [1, 2, 1, 2]
         >>> attrs = {"K_sp": {1: 0.001, 2: 0.0001}}
         >>> lith = Lithology(mg, thicknesses, ids, attrs)
         >>> lith.z_bottom
-        array([[ 8.,  8.,  8.,  8.,  8.,  8.,  8.,  8.,  8.],
-               [ 7.,  7.,  7.,  7.,  7.,  7.,  7.,  7.,  7.],
-               [ 3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.],
-               [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.]])
+        array([[8., 8., 8., 8., 8., 8., 8., 8., 8.],
+               [7., 7., 7., 7., 7., 7., 7., 7., 7.],
+               [3., 3., 3., 3., 3., 3., 3., 3., 3.],
+               [1., 1., 1., 1., 1., 1., 1., 1., 1.]])
         """
         thick = np.broadcast_to(self._layers.thickness, self._layers.z.shape)
         return thick - self._layers.z + self._layers.dz
 
     @property
     def z_top(self):
         """Thickness from the surface to the top of each layer in Lithology.
@@ -466,18 +464,18 @@
         >>> mg = RasterModelGrid((3, 3))
         >>> z = mg.add_zeros("topographic__elevation", at="node")
         >>> thicknesses = [1, 2, 4, 1]
         >>> ids = [1, 2, 1, 2]
         >>> attrs = {"K_sp": {1: 0.001, 2: 0.0001}}
         >>> lith = Lithology(mg, thicknesses, ids, attrs)
         >>> lith.z_top
-        array([[ 7.,  7.,  7.,  7.,  7.,  7.,  7.,  7.,  7.],
-               [ 3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.],
-               [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])
+        array([[7., 7., 7., 7., 7., 7., 7., 7., 7.],
+               [3., 3., 3., 3., 3., 3., 3., 3., 3.],
+               [1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [0., 0., 0., 0., 0., 0., 0., 0., 0.]])
         """
         thick = np.broadcast_to(self._layers.thickness, self._layers.z.shape)
         return thick - self._layers.z
 
     def _check_property_dictionary(self):
         """Check compatibility of Lithology and property dictionary."""
         ids = []
@@ -530,25 +528,25 @@
         Add a layer of thickness 3 and rock type 3.
 
         >>> lith.add_layer(3, rock_id=3)
 
         The value of `K_sp` at node is now updated to the value of rock type 3
 
         >>> mg.at_node["K_sp"]
-        array([ 0.01,  0.01,  0.01,  0.01,  0.01,  0.01,  0.01,  0.01,  0.01])
+        array([0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01])
 
         A negative value will erode. We can also pass a `(n_nodes,) long array
         to erode unevenly. If all parts of the layer erode, then no `rock_id`
         needs to be passed.
 
         >>> erosion_amount = [-2.0, -2.0, -2.0, -4.0, -4.0, -4.0, -6.0, -6.0, -6.0]
         >>> lith.add_layer(erosion_amount)
         >>> mg.at_node["K_sp"]
-        array([ 0.01  ,  0.01  ,  0.01  ,  0.0001,  0.0001,  0.0001,  0.001 ,
-                0.001 ,  0.001 ])
+        array([0.01  , 0.01  , 0.01  , 0.0001, 0.0001, 0.0001, 0.001 ,
+               0.001 , 0.001 ])
 
         Now different layers are exposed at the surface and the value of `K_sp`
         is spatially variable.
         """
         thickness = np.array(thickness)
 
         # verify that Lithology will still have thickness after change
@@ -608,15 +606,15 @@
         >>> ids = [1, 2, 1, 2]
         >>> attrs = {"K_sp": {1: 0.001, 2: 0.0001}}
         >>> lith = Lithology(mg, thicknesses, ids, attrs)
         >>> lith.add_property({"D": {1: 0.03, 2: 0.004}})
         >>> lith.tracked_properties
         ['D', 'K_sp']
         >>> mg.at_node["D"]
-        array([ 0.03,  0.03,  0.03,  0.03,  0.03,  0.03,  0.03,  0.03,  0.03])
+        array([0.03, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03])
         """
         for at in attrs:
             if at in self._properties:
                 raise ValueError(
                     "add_property is trying to add an existing "
                     f"attribute, this is not permitted. {at}"
                 )
@@ -718,21 +716,20 @@
         >>> z = mg.add_zeros("topographic__elevation", at="node")
         >>> thicknesses = [1, 2, 4, 1]
         >>> ids = [1, 2, 1, 2]
         >>> attrs = {"K_sp": {1: 0.001, 2: 0.0001}}
         >>> lith = Lithology(mg, thicknesses, ids, attrs)
 
         >>> mg.at_node["K_sp"]
-        array([ 0.001,  0.001,  0.001,  0.001,  0.001,  0.001,  0.001,  0.001,
-                0.001])
+        array([0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001])
 
         >>> lith.update_rock_properties("K_sp", 1, 0.03)
 
         >>> mg.at_node["K_sp"]
-        array([ 0.03,  0.03,  0.03,  0.03,  0.03,  0.03,  0.03,  0.03,  0.03])
+        array([0.03, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03])
         """
         if at not in self._properties:
             raise ValueError(
                 f"Lithology cannot update the value of {at!s} as "
                 "this attribute does not exist."
             )
 
@@ -832,120 +829,120 @@
         >>> mg = RasterModelGrid((3, 3))
         >>> z = mg.add_ones("topographic__elevation", at="node")
         >>> thicknesses = [1, 2, 4, 1]
         >>> ids = [1, 2, 1, 2]
         >>> attrs = {"K_sp": {1: 0.001, 2: 0.0001}}
         >>> lith = Lithology(mg, thicknesses, ids, attrs)
         >>> lith.dz
-        array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 4.,  4.,  4.,  4.,  4.,  4.,  4.,  4.,  4.],
-               [ 2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.],
-               [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.]])
+        array([[1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [4., 4., 4., 4., 4., 4., 4., 4., 4.],
+               [2., 2., 2., 2., 2., 2., 2., 2., 2.],
+               [1., 1., 1., 1., 1., 1., 1., 1., 1.]])
         >>> lith.thickness
-        array([ 8.,  8.,  8.,  8.,  8.,  8.,  8.,  8.,  8.])
+        array([8., 8., 8., 8., 8., 8., 8., 8., 8.])
 
         If we erode the surface, and then update Lithology, the thickness will
         change.
 
         >>> z -= 0.5
         >>> lith.run_one_step()
         >>> lith.thickness
-        array([ 7.5,  7.5,  7.5,  7.5,  7.5,  7.5,  7.5,  7.5,  7.5])
+        array([7.5, 7.5, 7.5, 7.5, 7.5, 7.5, 7.5, 7.5, 7.5])
 
         The default of Lithology is to use MaterialLayers from the Landlab
         layers submodule. This means that when we erode, we will remove a layer
         from the layers datastructure if it has no material anywhere.
 
         >>> lith.dz
-        array([[ 1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ],
-               [ 4. ,  4. ,  4. ,  4. ,  4. ,  4. ,  4. ,  4. ,  4. ],
-               [ 2. ,  2. ,  2. ,  2. ,  2. ,  2. ,  2. ,  2. ,  2. ],
-               [ 0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5]])
+        array([[1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. ],
+               [4. , 4. , 4. , 4. , 4. , 4. , 4. , 4. , 4. ],
+               [2. , 2. , 2. , 2. , 2. , 2. , 2. , 2. , 2. ],
+               [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]])
 
         We can see the value of the rock type at the surface.
 
         >>> mg.at_node["rock_type__id"]
-        array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
+        array([1., 1., 1., 1., 1., 1., 1., 1., 1.])
 
         If you deposit, a valid rock_id must be provided. If the rock type
         is the same as the current surface value everywhere, then the layers
         will be combined. This rock_id can be provided as part of the init of
         Lithology or by setting a property (as shown below).
 
         >>> z += 1.5
         >>> lith.rock_id = 1
         >>> lith.run_one_step()
         >>> lith.thickness
-        array([ 9.,  9.,  9.,  9.,  9.,  9.,  9.,  9.,  9.])
+        array([9., 9., 9., 9., 9., 9., 9., 9., 9.])
 
         >>> lith.dz
-        array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 4.,  4.,  4.,  4.,  4.,  4.,  4.,  4.,  4.],
-               [ 2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.],
-               [ 2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.]])
+        array([[1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [4., 4., 4., 4., 4., 4., 4., 4., 4.],
+               [2., 2., 2., 2., 2., 2., 2., 2., 2.],
+               [2., 2., 2., 2., 2., 2., 2., 2., 2.]])
 
         This contrasts with the behavior of Lithology if we use EventLayers.
         Next we repeat this example with EventLayers. Note that no matter which
         method you use, the values of the model grid fields will be the same.
         These two methods differ only in the details of the data structure they
         use to store the layer information.
 
         >>> mg = RasterModelGrid((3, 3))
         >>> z = mg.add_ones("topographic__elevation", at="node")
         >>> thicknesses = [1, 2, 4, 1]
         >>> ids = [1, 2, 1, 2]
         >>> attrs = {"K_sp": {1: 0.001, 2: 0.0001}}
         >>> lith = Lithology(mg, thicknesses, ids, attrs, layer_type="EventLayers")
         >>> lith.dz
-        array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.],
-               [ 4.,  4.,  4.,  4.,  4.,  4.,  4.,  4.,  4.],
-               [ 2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.],
-               [ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.]])
+        array([[1., 1., 1., 1., 1., 1., 1., 1., 1.],
+               [4., 4., 4., 4., 4., 4., 4., 4., 4.],
+               [2., 2., 2., 2., 2., 2., 2., 2., 2.],
+               [1., 1., 1., 1., 1., 1., 1., 1., 1.]])
         >>> lith.thickness
-        array([ 8.,  8.,  8.,  8.,  8.,  8.,  8.,  8.,  8.])
+        array([8., 8., 8., 8., 8., 8., 8., 8., 8.])
 
         If we erode the surface, and then update Lithology, the thickness
         will change. However, with EventLayers, the ``lith.dz`` structure
         will be different. It will have a layer with thickness zero that
         represents the event of erosion.
 
         >>> z -= 0.5
         >>> lith.run_one_step()
         >>> lith.thickness
-        array([ 7.5,  7.5,  7.5,  7.5,  7.5,  7.5,  7.5,  7.5,  7.5])
+        array([7.5, 7.5, 7.5, 7.5, 7.5, 7.5, 7.5, 7.5, 7.5])
         >>> lith.dz
-        array([[ 1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ],
-               [ 4. ,  4. ,  4. ,  4. ,  4. ,  4. ,  4. ,  4. ,  4. ],
-               [ 2. ,  2. ,  2. ,  2. ,  2. ,  2. ,  2. ,  2. ,  2. ],
-               [ 0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5],
-               [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ]])
+        array([[1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. ],
+               [4. , 4. , 4. , 4. , 4. , 4. , 4. , 4. , 4. ],
+               [2. , 2. , 2. , 2. , 2. , 2. , 2. , 2. , 2. ],
+               [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
+               [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ]])
 
         We can see the value of the rock type at the surface. As expected,
         it is just the same as if we used MaterialLayers.
 
         >>> mg.at_node["rock_type__id"]
-        array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
+        array([1., 1., 1., 1., 1., 1., 1., 1., 1.])
 
         If you deposit, a valid rock_id must be provided. Unlike
         MaterialLayers, these two layers will not be combined, even if they
         have the same properties.
 
         >>> z += 1.5
         >>> lith.rock_id = 1
         >>> lith.run_one_step()
         >>> lith.thickness
-        array([ 9.,  9.,  9.,  9.,  9.,  9.,  9.,  9.,  9.])
+        array([9., 9., 9., 9., 9., 9., 9., 9., 9.])
 
         >>> lith.dz
-        array([[ 1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ],
-               [ 4. ,  4. ,  4. ,  4. ,  4. ,  4. ,  4. ,  4. ,  4. ],
-               [ 2. ,  2. ,  2. ,  2. ,  2. ,  2. ,  2. ,  2. ,  2. ],
-               [ 0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5],
-               [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],
-               [ 1.5,  1.5,  1.5,  1.5,  1.5,  1.5,  1.5,  1.5,  1.5]])
+        array([[1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. ],
+               [4. , 4. , 4. , 4. , 4. , 4. , 4. , 4. , 4. ],
+               [2. , 2. , 2. , 2. , 2. , 2. , 2. , 2. , 2. ],
+               [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
+               [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],
+               [1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5]])
         """
         # calculate amount of erosion
         elevation_change = self._grid["node"]["topographic__elevation"] - (
             self._last_elevation + self.dz_advection
         )
 
         # add layer
```

### Comparing `landlab-2.7.0/landlab/components/marine_sediment_transport/simple_submarine_diffuser.py` & `landlab-2.8.0/landlab/components/marine_sediment_transport/simple_submarine_diffuser.py`

 * *Files 1% similar despite different names*

```diff
@@ -50,15 +50,15 @@
     >>> grid.set_closed_boundaries_at_grid_edges(False, True, False, True)
     >>> topo = grid.add_zeros("topographic__elevation", at="node")
     >>> topo[:] = -10.0
     >>> topo[9:14] = [0.0, 10.0, 10.0, 5.0, 5.0]
     >>> ssd = SimpleSubmarineDiffuser(grid, tidal_range=0.0)
     >>> ssd.run_one_step(dt=5.0)
     >>> topo[8:13]
-    array([ -9.5,   0. ,   9.5,  10. ,   5. ])
+    array([-9.5,  0. ,  9.5, 10. ,  5. ])
     >>> grid.at_node["sediment_deposit__thickness"][8:13]
     array([ 0.5,  0. , -0.5,  0. ,  0. ])
     """
 
     _name = "SimpleSubmarineDiffuser"
 
     _time_units = "y"
```

### Comparing `landlab-2.7.0/landlab/components/network_sediment_transporter/README.md` & `landlab-2.8.0/landlab/components/network_sediment_transporter/README.md`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/network_sediment_transporter/__init__.py` & `landlab-2.8.0/landlab/components/network_sediment_transporter/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,13 +1,11 @@
-from .bed_parcel_initializers import (
-    BedParcelInitializerArea,
-    BedParcelInitializerDepth,
-    BedParcelInitializerDischarge,
-    BedParcelInitializerUserD50,
-)
+from .bed_parcel_initializers import BedParcelInitializerArea
+from .bed_parcel_initializers import BedParcelInitializerDepth
+from .bed_parcel_initializers import BedParcelInitializerDischarge
+from .bed_parcel_initializers import BedParcelInitializerUserD50
 from .network_sediment_transporter import NetworkSedimentTransporter
 from .sediment_pulser_at_links import SedimentPulserAtLinks
 from .sediment_pulser_each_parcel import SedimentPulserEachParcel
 
 __all__ = [
     "NetworkSedimentTransporter",
     "BedParcelInitializerDischarge",
```

### Comparing `landlab-2.7.0/landlab/components/network_sediment_transporter/bed_parcel_initializers.py` & `landlab-2.8.0/landlab/components/network_sediment_transporter/bed_parcel_initializers.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/network_sediment_transporter/network_sediment_transporter.py` & `landlab-2.8.0/landlab/components/network_sediment_transporter/network_sediment_transporter.py`

 * *Files 2% similar despite different names*

```diff
@@ -160,16 +160,16 @@
 
     >>> for t in range(0, (timesteps * dt), dt):
     ...     nst.run_one_step(dt)
     ...
 
     We can the link location of the parcel at each timestep
 
-    >>> print(one_parcel.dataset.element_id.values)
-    [[ 0.  0.  0.  0.  0.  1.  1.  1.  1.  1.  2.]]
+    >>> one_parcel.dataset.element_id.values
+    array([[0., 0., 0., 0., 0., 1., 1., 1., 1., 1., 2.]])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     Pfeiffer, A., Barnhart, K., Czuba, J., & Hutton, E. (2020).
     NetworkSedimentTransporter: A Landlab component for bed material transport
@@ -412,17 +412,17 @@
         if self._time_idx != 0:
             self._parcels.add_record(time=[self._time])
 
             self._parcels.ffill_grid_element_and_id()
 
             # copy parcel attributes forward in time.
             for at in self._time_variable_parcel_attributes:
-                self._parcels.dataset[at].values[
-                    :, self._time_idx
-                ] = self._parcels.dataset[at].values[:, self._time_idx - 1]
+                self._parcels.dataset[at].values[:, self._time_idx] = (
+                    self._parcels.dataset[at].values[:, self._time_idx - 1]
+                )
 
         self._this_timesteps_parcels = np.zeros_like(
             self._parcels.dataset.element_id, dtype=bool
         )
         self._this_timesteps_parcels[:, -1] = True
 
         parcels_off_grid = (
@@ -939,21 +939,21 @@
 
         # arrival time in link
         self._parcels.dataset.time_arrival_in_link[
             active_parcel_ids, self._time_idx
         ] = self._time_idx
 
         # location in link
-        self._parcels.dataset.location_in_link[
-            active_parcel_ids, self._time_idx
-        ] = location_in_link[active_parcel_ids]
+        self._parcels.dataset.location_in_link[active_parcel_ids, self._time_idx] = (
+            location_in_link[active_parcel_ids]
+        )
 
-        self._parcels.dataset.element_id[
-            active_parcel_ids, self._time_idx
-        ] = current_link[active_parcel_ids]
+        self._parcels.dataset.element_id[active_parcel_ids, self._time_idx] = (
+            current_link[active_parcel_ids]
+        )
         #                self._parcels.dataset.active_layer[p, self._time_idx] = 1
         # ^ reset to 1 (active) to be recomputed/determined at next timestep
         self._parcels.dataset.D[active_parcel_ids, self._time_idx] = D
         self._parcels.dataset.volume[active_parcel_ids, self._time_idx] = vol
 
     def run_one_step(self, dt):
         """Run :class:`~.NetworkSedimentTransporter` forward in time.
@@ -1163,15 +1163,15 @@
 
     Examples
     --------
     >>> import pytest
     >>> _calculate_parcel_volume_post_abrasion(10, 100, 0.003)
     7.4081822068171785
     >>> _calculate_parcel_volume_post_abrasion(10, 300, 0.1)
-    9.3576229688401746e-13
+    9.357622968840175e-13
     >>> with pytest.raises(ValueError):
     ...     _calculate_parcel_volume_post_abrasion(10, 300, -3)
     ...
 
     """
 
     volume = starting_volume * np.exp(travel_distance * (-abrasion_rate))
```

### Comparing `landlab-2.7.0/landlab/components/network_sediment_transporter/sediment_pulser_at_links.py` & `landlab-2.8.0/landlab/components/network_sediment_transporter/sediment_pulser_at_links.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/network_sediment_transporter/sediment_pulser_base.py` & `landlab-2.8.0/landlab/components/network_sediment_transporter/sediment_pulser_base.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,12 @@
 from landlab import Component
 from landlab.grid.network import NetworkModelGrid
 
 
 class SedimentPulserBase(Component):
-
     """Base class of :class:`~.SedimentPulserAtLinks` and :class:`~.SedimentPulserEachParcel`.
 
     :class:`~.SedimentPulserAtLinks` and :class:`~.SedimentPulserEachParcel` run the
     landlab :class:`~.DataRecord` :meth:`~.DataRecord.add_item` method on a
     :class:`~.DataRecord` configured for :class:`~.NetworkSedimentTransporter`.
```

### Comparing `landlab-2.7.0/landlab/components/network_sediment_transporter/sediment_pulser_each_parcel.py` & `landlab-2.8.0/landlab/components/network_sediment_transporter/sediment_pulser_each_parcel.py`

 * *Files 0% similar despite different names*

```diff
@@ -7,15 +7,14 @@
 )
 from landlab.data_record import DataRecord
 
 _OUT_OF_NETWORK = -2
 
 
 class SedimentPulserEachParcel(SedimentPulserBase):
-
     """Send pulses of sediment to specific point locations within the channel
     network and divide the pulses into parcels. Pulses may be any volume.
     Parcels must be less than or equal to a user specified maximum volume.
 
     SedimentPulserEachParcel is instantiated by specifying the network model grid
     it will pulse the parcels into
```

### Comparing `landlab-2.7.0/landlab/components/nonlinear_diffusion/Perron_nl_diffuse.py` & `landlab-2.8.0/landlab/components/nonlinear_diffusion/Perron_nl_diffuse.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,15 +6,14 @@
 
 # Things to add: 1. Explicit stability check.
 # 2. Implicit handling of scenarios where kappa*dt exceeds critical step -
 #    subdivide dt automatically.
 
 
 class PerronNLDiffuse(Component):
-
     """Nonlinear diffusion, following Perron (2011).
 
     This module uses Taylor Perron's implicit (2011) method to solve the
     nonlinear hillslope diffusion equation across a rectangular, regular grid
     for a single timestep. Note it works with the mass flux implicitly, and
     thus does not actually calculate it. Grid must be at least 5x5.
 
@@ -774,21 +773,21 @@
             bottom_op_mat_data_add = np.empty(bottom_interior_IDs.size * 3 + 6)
             # Equivalent to fixed gradient, but the gradient is zero, so
             # material only goes in the linked cell(i.e., each cell in the
             # op_mat edges points back to itself).
             bottom_op_mat_row_add[: (bottom_interior_IDs.size * 3)] = np.repeat(
                 bottom_interior_IDs, 3
             )
-            bottom_op_mat_col_add[
-                : (bottom_interior_IDs.size * 3)
-            ] = self._realIDtointerior(
-                self._operating_matrix_ID_map[self._bottom_interior_IDs, :][
-                    :, self._bottom_mask[0:3]
-                ]
-            ).flatten()
+            bottom_op_mat_col_add[: (bottom_interior_IDs.size * 3)] = (
+                self._realIDtointerior(
+                    self._operating_matrix_ID_map[self._bottom_interior_IDs, :][
+                        :, self._bottom_mask[0:3]
+                    ]
+                ).flatten()
+            )
             bottom_op_mat_data_add[: (bottom_interior_IDs.size * 3)] = (
                 _delta_t
                 * (nine_node_map[_bottom_list, :][:, bottom_antimask]).flatten()
             )
             # ...& the corners
             this_corner_coords = np.array([0, 1])
             # order is bottom 2 lower left, bottom 2 lower right, lower left
@@ -854,21 +853,21 @@
             bottom_op_mat_row_add = np.empty(bottom_interior_IDs.size * 3 + 6)
             bottom_op_mat_col_add = np.empty(bottom_interior_IDs.size * 3 + 6)
             bottom_op_mat_data_add = np.empty(bottom_interior_IDs.size * 3 + 6)
             bottom_op_mat_row_add[: (bottom_interior_IDs.size * 3)] = np.repeat(
                 bottom_interior_IDs, 3
             )
             # ^...put the values in the same places in the operating matrix...
-            bottom_op_mat_col_add[
-                : (bottom_interior_IDs.size * 3)
-            ] = self._realIDtointerior(
-                self._operating_matrix_ID_map[self._top_interior_IDs, :][
-                    :, self._top_mask[3:6]
-                ]
-            ).flatten()
+            bottom_op_mat_col_add[: (bottom_interior_IDs.size * 3)] = (
+                self._realIDtointerior(
+                    self._operating_matrix_ID_map[self._top_interior_IDs, :][
+                        :, self._top_mask[3:6]
+                    ]
+                ).flatten()
+            )
             bottom_op_mat_data_add[: (bottom_interior_IDs.size * 3)] = (
                 _delta_t
                 * (nine_node_map[_bottom_list, :][:, bottom_antimask]).flatten()
             )
             # ^...but the values refer to the TOP of the grid
             top_op_mat_row_add = np.empty(top_interior_IDs.size * 3 + 6)
             top_op_mat_col_add = np.empty(top_interior_IDs.size * 3 + 6)
@@ -1094,21 +1093,21 @@
             left_op_mat_data_add = np.empty(left_interior_IDs.size * 3 + 4)
             # Equivalent to fixed gradient, but the gradient is zero, so
             # material only goes in the linked cell(i.e., each cell in the
             # op_mat edges points back to itself).
             left_op_mat_row_add[: (left_interior_IDs.size * 3)] = np.repeat(
                 left_interior_IDs, 3
             )
-            left_op_mat_col_add[
-                : (left_interior_IDs.size * 3)
-            ] = self._realIDtointerior(
-                self._operating_matrix_ID_map[self._left_interior_IDs, :][
-                    :, self._left_mask[::2]
-                ]
-            ).flatten()
+            left_op_mat_col_add[: (left_interior_IDs.size * 3)] = (
+                self._realIDtointerior(
+                    self._operating_matrix_ID_map[self._left_interior_IDs, :][
+                        :, self._left_mask[::2]
+                    ]
+                ).flatten()
+            )
             left_op_mat_data_add[: (left_interior_IDs.size * 3)] = (
                 _delta_t * (nine_node_map[_left_list, :][:, left_antimask]).flatten()
             )
             # ...& the corners
             this_corner_coords = np.array([0, 2])
             left_op_mat_row_add[-4:] = np.repeat(
                 corner_interior_IDs[this_corner_coords], 2
@@ -1153,37 +1152,37 @@
         elif self._left_flag == 3:
             left_op_mat_row_add = np.empty(left_interior_IDs.size * 3 + 4)
             left_op_mat_col_add = np.empty(left_interior_IDs.size * 3 + 4)
             left_op_mat_data_add = np.empty(left_interior_IDs.size * 3 + 4)
             left_op_mat_row_add[: (left_interior_IDs.size * 3)] = np.repeat(
                 left_interior_IDs, 3
             )
-            left_op_mat_col_add[
-                : (left_interior_IDs.size * 3)
-            ] = self._realIDtointerior(
-                self._operating_matrix_ID_map[self._right_interior_IDs, :][
-                    :, self._right_mask[1::2]
-                ]
-            ).flatten()
+            left_op_mat_col_add[: (left_interior_IDs.size * 3)] = (
+                self._realIDtointerior(
+                    self._operating_matrix_ID_map[self._right_interior_IDs, :][
+                        :, self._right_mask[1::2]
+                    ]
+                ).flatten()
+            )
             left_op_mat_data_add[: (left_interior_IDs.size * 3)] = (
                 _delta_t * (nine_node_map[_left_list, :][:, left_antimask]).flatten()
             )
             right_op_mat_row_add = np.empty(right_interior_IDs.size * 3 + 4)
             right_op_mat_col_add = np.empty(right_interior_IDs.size * 3 + 4)
             right_op_mat_data_add = np.empty(right_interior_IDs.size * 3 + 4)
             right_op_mat_row_add[: (right_interior_IDs.size * 3)] = np.repeat(
                 right_interior_IDs, 3
             )
-            right_op_mat_col_add[
-                : (right_interior_IDs.size * 3)
-            ] = self._realIDtointerior(
-                self._operating_matrix_ID_map[self._left_interior_IDs, :][
-                    :, self._left_mask[::2]
-                ]
-            ).flatten()
+            right_op_mat_col_add[: (right_interior_IDs.size * 3)] = (
+                self._realIDtointerior(
+                    self._operating_matrix_ID_map[self._left_interior_IDs, :][
+                        :, self._left_mask[::2]
+                    ]
+                ).flatten()
+            )
             right_op_mat_data_add[: (right_interior_IDs.size * 3)] = (
                 _delta_t * (nine_node_map[_right_list, :][:, right_antimask]).flatten()
             )
             # & the corners
             left_corner_coords = np.array([0, 2])
             right_corner_coords = np.array([1, 3])
             left_op_mat_row_add[-4:] = np.repeat(
@@ -1260,21 +1259,21 @@
             right_op_mat_data_add = np.empty(right_interior_IDs.size * 3 + 4)
             # Equivalent to fixed gradient, but the gradient is zero, so
             # material only goes in the linked cell(i.e., each cell in the
             # op_mat edges points back to itself).
             right_op_mat_row_add[: (right_interior_IDs.size * 3)] = np.repeat(
                 right_interior_IDs, 3
             )
-            right_op_mat_col_add[
-                : (right_interior_IDs.size * 3)
-            ] = self._realIDtointerior(
-                self._operating_matrix_ID_map[self._right_interior_IDs, :][
-                    :, self._right_mask[1::2]
-                ]
-            ).flatten()
+            right_op_mat_col_add[: (right_interior_IDs.size * 3)] = (
+                self._realIDtointerior(
+                    self._operating_matrix_ID_map[self._right_interior_IDs, :][
+                        :, self._right_mask[1::2]
+                    ]
+                ).flatten()
+            )
             right_op_mat_data_add[: (right_interior_IDs.size * 3)] = (
                 _delta_t * (nine_node_map[_right_list, :][:, right_antimask]).flatten()
             )
             # ...& the corners
             this_corner_coords = np.array([1, 3])
             right_op_mat_row_add[-4:] = np.repeat(
                 corner_interior_IDs[this_corner_coords], 2
```

### Comparing `landlab-2.7.0/landlab/components/normal_fault/normal_fault.py` & `landlab-2.8.0/landlab/components/normal_fault/normal_fault.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,15 +4,16 @@
 Landlab component that implements rock uplift by a normal fault. Note
 that this component does not make any attempt to advect topography
 laterally.
 """
 
 import numpy as np
 
-from landlab import Component, FieldError
+from landlab import Component
+from landlab import FieldError
 
 TWO_PI = 2.0 * np.pi
 
 
 class NormalFault(Component):
     """NormalFault implements relative rock motion due to a normal fault.
 
@@ -152,48 +153,48 @@
         >>> nf = NormalFault(grid, **param_dict)
         >>> nf.faulted_nodes.reshape(grid.shape)
         array([[False, False, False, False, False, False],
                [False,  True, False, False, False, False],
                [False,  True,  True,  True, False, False],
                [False,  True,  True,  True,  True, False],
                [False,  True,  True,  True,  True, False],
-               [False, False, False, False, False, False]], dtype=bool)
+               [False, False, False, False, False, False]])
 
         As we can see, only a subset of the nodes have been identified as
         *faulted nodes*. Because we have set include_boundaries' to False none
         of the boundary nodes are faulted nodes.
 
         Next we will run the NormalFault for 30 1-year timesteps.
 
         >>> dt = 1.0
         >>> for i in range(30):
         ...     nf.run_one_step(dt)
         ...
         >>> z.reshape(grid.shape)
-        array([[ 0.,  0.,  0.,  0.,  0.,  0.],
-               [ 0.,  1.,  0.,  0.,  0.,  0.],
-               [ 0.,  1.,  1.,  1.,  0.,  0.],
-               [ 0.,  1.,  1.,  1.,  1.,  0.],
-               [ 0.,  1.,  1.,  1.,  1.,  0.],
-               [ 0.,  0.,  0.,  0.,  0.,  0.]])
+        array([[0., 0., 0., 0., 0., 0.],
+               [0., 1., 0., 0., 0., 0.],
+               [0., 1., 1., 1., 0., 0.],
+               [0., 1., 1., 1., 1., 0.],
+               [0., 1., 1., 1., 1., 0.],
+               [0., 0., 0., 0., 0., 0.]])
 
         This results in uplift of the faulted nodes, as we would expect.
 
         If the user knows how much uplift (dz) they want to occur in an event,
         they can use the **run_one_earthquake** function with a specified dz.
         In this case fault_throw_rate_through_time will be ignored.
 
         >>> nf.run_one_earthquake(dz=100)
         >>> z.reshape(grid.shape)
-        array([[   0.,    0.,    0.,    0.,    0.,    0.],
-               [   0.,  101.,    0.,    0.,    0.,    0.],
-               [   0.,  101.,  101.,  101.,    0.,    0.],
-               [   0.,  101.,  101.,  101.,  101.,    0.],
-               [   0.,  101.,  101.,  101.,  101.,    0.],
-               [   0.,    0.,    0.,    0.,    0.,    0.]])
+        array([[  0.,   0.,   0.,   0.,   0.,   0.],
+               [  0., 101.,   0.,   0.,   0.,   0.],
+               [  0., 101., 101., 101.,   0.,   0.],
+               [  0., 101., 101., 101., 101.,   0.],
+               [  0., 101., 101., 101., 101.,   0.],
+               [  0.,   0.,   0.,   0.,   0.,   0.]])
 
         Next, we make a very simple landscape model. We need a few components
         and we will set include_boundaries to True.
 
         >>> from landlab.components import FastscapeEroder, FlowAccumulator
         >>> grid = RasterModelGrid((6, 6), xy_spacing=10)
         >>> z = grid.add_zeros("topographic__elevation", at="node")
@@ -217,20 +218,20 @@
         >>> dt = 100.0
         >>> for i in range(300):
         ...     nf.run_one_step(dt)
         ...     fr.run_one_step()
         ...     fs.run_one_step(dt)
         ...
         >>> z.reshape(grid.shape).round(decimals=2)
-        array([[  0.  ,   0.  ,   0.  ,   0.  ,   0.  ,   0.  ],
-               [  5.  ,   5.  ,   0.  ,   0.  ,   0.  ,   0.  ],
-               [  7.39,   7.38,   2.38,   2.89,   0.  ,   0.  ],
-               [  9.36,  11.43,   5.51,   6.42,   3.54,   3.54],
-               [ 15.06,  15.75,  10.6 ,  11.42,   8.54,   8.54],
-               [ 15.06,  15.06,  10.7 ,  11.42,   8.54,   8.54]])
+        array([[ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ],
+               [ 5.  ,  5.  ,  0.  ,  0.  ,  0.  ,  0.  ],
+               [ 7.39,  7.38,  2.38,  2.89,  0.  ,  0.  ],
+               [ 9.36, 11.43,  5.51,  6.42,  3.54,  3.54],
+               [15.06, 15.75, 10.6 , 11.42,  8.54,  8.54],
+               [15.06, 15.06, 10.7 , 11.42,  8.54,  8.54]])
 
         The faulted nodes have been uplifted and eroded! Note that here the
         boundary nodes are also uplifted.
 
         NormalFault keeps track of internal time.
 
         For example, if a user wanted to only run NormalFault every tenth
@@ -401,17 +402,17 @@
             averaged = neighbor_for_averaging[faulted_boundaries].sum(axis=1) == 1
             if any(averaged):
                 averaged_nodes = np.where(faulted_boundaries)[0][np.where(averaged)[0]]
                 for surf_name in self._surfaces:
                     elevations_to_average = surfs_before_uplift[surf_name][
                         self._grid.adjacent_nodes_at_node
                     ]
-                    elevations_to_average[
-                        self._grid.adjacent_nodes_at_node == -1
-                    ] = np.nan
+                    elevations_to_average[self._grid.adjacent_nodes_at_node == -1] = (
+                        np.nan
+                    )
                     elevations_to_average[~neighbor_for_averaging] = np.nan
                     self._surfaces[surf_name][averaged_nodes] = np.nanmean(
                         elevations_to_average[averaged_nodes], axis=1
                     )
 
             # identify any boundary nodes that are not being averaged. This will
             # happen at the corners on RasterModelGrids. Average over adjacent
@@ -422,17 +423,17 @@
                 un_averaged_nodes = np.where(faulted_boundaries)[0][
                     np.where(~averaged)[0]
                 ]
                 for surf_name in self._surfaces:
                     elevations_to_average = self._surfaces[surf_name][
                         self._grid.adjacent_nodes_at_node
                     ]
-                    elevations_to_average[
-                        self._grid.adjacent_nodes_at_node == -1
-                    ] = np.nan
+                    elevations_to_average[self._grid.adjacent_nodes_at_node == -1] = (
+                        np.nan
+                    )
                     elevations_to_average[~neighbor_is_faulted] = np.nan
                     self._surfaces[surf_name][un_averaged_nodes] = np.nanmean(
                         elevations_to_average[un_averaged_nodes], axis=1
                     )
 
     def run_one_step(self, dt):
         """Run_one_step method for NormalFault.
```

### Comparing `landlab-2.7.0/landlab/components/overland_flow/__init__.py` & `landlab-2.8.0/landlab/components/overland_flow/__init__.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/overland_flow/_links.py` & `landlab-2.8.0/landlab/components/overland_flow/_links.py`

 * *Files 0% similar despite different names*

```diff
@@ -399,15 +399,15 @@
     >>> is_active_link((4, 3), status)
     array([False, False,
            False, False, False,
            False, False,
            False, True, False,
            False, False,
            False, False, False,
-           False, False], dtype=bool)
+           False, False])
     """
     from ...grid.linkstatus import is_active_link
 
     node_status = np.asarray(node_status).reshape(-1)
 
     if np.prod(shape) != node_status.size:
         raise ValueError(
@@ -598,15 +598,15 @@
     ... )
     >>> import numpy as np
     >>> shape = (3, 4)
     >>> links = np.arange(_number_of_links(shape))
     >>> is_vertical_link(shape, links)
     array([False, False, False,  True,  True,  True,  True,
            False, False, False,  True,  True,  True,  True,
-           False, False, False], dtype=bool)
+           False, False, False])
     """
     return ((links % (2 * shape[1] - 1)) >= shape[1] - 1) & (
         links < _number_of_links(shape)
     )
 
 
 def nth_vertical_link(shape, links):
@@ -775,15 +775,15 @@
     ... )
     >>> import numpy as np
     >>> shape = (3, 4)
     >>> links = np.arange(_number_of_links(shape))
     >>> is_horizontal_link(shape, links)
     array([ True,  True,  True, False, False, False, False,
             True,  True,  True, False, False, False, False,
-            True,  True,  True], dtype=bool)
+            True,  True,  True])
     """
     return (~is_vertical_link(shape, links)) & (links < _number_of_links(shape))
 
 
 def horizontal_west_link_neighbor(shape, horizontal_ids, bad_index_value=-1):
     """ID of west, horizontal link neighbor.
```

### Comparing `landlab-2.7.0/landlab/components/overland_flow/_neighbors_at_link.pyx` & `landlab-2.8.0/landlab/components/overland_flow/_neighbors_at_link.pyx`

 * *Files 12% similar despite different names*

```diff
@@ -7,37 +7,37 @@
 ctypedef np.int_t DTYPE_t
 
 
 @cython.boundscheck(False)
 def neighbors_at_link(
     np.ndarray[DTYPE_t, ndim=1] links,
     shape,
-    np.ndarray[DTYPE_t, ndim=2] out
+    np.ndarray[DTYPE_t, ndim=2] out,
 ):
-  cdef int stride
-  cdef int n_links
-  cdef int link
-  cdef int i
-  cdef is_top, is_bottom, is_left, is_right
-
-  stride = 2 * shape[1] - 1
-  n_links = (shape[0] - 1) * shape[1] + shape[0] * (shape[1] - 1)
-
-  for i in range(links.shape[0]):
-    link = links[i]
-
-    is_top = link > (n_links - stride)
-    is_bottom = link < stride
-    is_left = link % stride == 0 or (link + shape[1]) % stride == 0
-    is_right = (link - (shape[1] - 2)) % stride == 0 or (link + 1) % stride == 0
-
-    if not is_right:
-      out[i, 0] = link + 1
+    cdef int stride
+    cdef int n_links
+    cdef int link
+    cdef int i
+    cdef bint is_top, is_bottom, is_left, is_right
+
+    stride = 2 * shape[1] - 1
+    n_links = (shape[0] - 1) * shape[1] + shape[0] * (shape[1] - 1)
+
+    for i in range(links.shape[0]):
+        link = links[i]
+
+        is_top = link > (n_links - stride)
+        is_bottom = link < stride
+        is_left = link % stride == 0 or (link + shape[1]) % stride == 0
+        is_right = (link - (shape[1] - 2)) % stride == 0 or (link + 1) % stride == 0
+
+        if not is_right:
+            out[i, 0] = link + 1
 
-    if not is_top:
-      out[i, 1] = link + stride
+        if not is_top:
+            out[i, 1] = link + stride
 
-    if not is_left:
-      out[i, 2] = link - 1
+        if not is_left:
+            out[i, 2] = link - 1
 
-    if not is_bottom:
-      out[i, 3] = link - stride
+        if not is_bottom:
+            out[i, 3] = link - stride
```

### Comparing `landlab-2.7.0/landlab/components/overland_flow/generate_overland_flow_Bates.py` & `landlab-2.8.0/landlab/components/overland_flow/generate_overland_flow_Bates.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 over topography using the Bates et al. (2010)
 algorithm for storage-cell inundation modeling.
 
 Written by Jordan Adams, based on code written by Greg Tucker.
 
 Last updated: April 21, 2016
 """
+
 import numpy as np
 import scipy.constants
 
 from landlab import Component
 
 
 class OverlandFlowBates(Component):
```

### Comparing `landlab-2.7.0/landlab/components/overland_flow/generate_overland_flow_deAlmeida.py` & `landlab-2.8.0/landlab/components/overland_flow/generate_overland_flow_deAlmeida.py`

 * *Files 2% similar despite different names*

```diff
@@ -51,21 +51,18 @@
 ('surface_water__depth', 'surface_water__discharge', 'water_surface__gradient')
 
 The `surface_water__depth` field is defined at nodes.
 
 >>> of.var_loc("surface_water__depth")
 'node'
 >>> grid.at_node["surface_water__depth"]
-array([  1.00000000e-05,   1.00000000e-05,   1.00000000e-05,
-         1.00000000e-05,   1.00000000e-05,   1.00000000e-05,
-         1.00000000e-05,   1.00000000e-05,   1.00000000e-05,
-         1.00000000e-05,   1.00000000e-05,   2.00100000e-02,
-         2.00100000e-02,   2.00100000e-02,   1.00000000e-05,
-         1.00010000e-01,   1.00010000e-01,   1.00010000e-01,
-         1.00010000e-01,   1.00010000e-01])
+array([1.0000e-05, 1.0000e-05, 1.0000e-05, 1.0000e-05, 1.0000e-05,
+       1.0000e-05, 1.0000e-05, 1.0000e-05, 1.0000e-05, 1.0000e-05,
+       1.0000e-05, 2.0010e-02, 2.0010e-02, 2.0010e-02, 1.0000e-05,
+       1.0001e-01, 1.0001e-01, 1.0001e-01, 1.0001e-01, 1.0001e-01])
 
 The `surface_water__discharge` field is defined at links. Because our initial
 topography was a dipping plane, there is no water discharge in the horizontal
 direction, only toward the bottom of the grid.
 
 >>> of.var_loc("surface_water__discharge")
 'link'
@@ -76,26 +73,28 @@
 True
 
 The *water_surface__gradient* is also defined at links.
 
 >>> of.var_loc("water_surface__gradient")
 'link'
 >>> grid.at_link["water_surface__gradient"]
-array([ 0. ,  0. ,  0. ,  0. ,
-        0. ,  1. ,  1. ,  1. ,  0. ,
-        0. ,  0. ,  0. ,  0. ,
-        0. ,  1. ,  1. ,  1. ,  0. ,
-        0. ,  0. ,  0. ,  0. ,
-        0. ,  1.1,  1.1,  1.1,  0. ,
-        0. ,  0. ,  0. ,  0. ])
+array([0. , 0. , 0. , 0. ,
+       0. , 1. , 1. , 1. , 0. ,
+       0. , 0. , 0. , 0. ,
+       0. , 1. , 1. , 1. , 0. ,
+       0. , 0. , 0. , 0. ,
+       0. , 1.1, 1.1, 1.1, 0. ,
+       0. , 0. , 0. , 0. ])
 """
+
 import numpy as np
 import scipy.constants
 
-from landlab import Component, FieldError
+from landlab import Component
+from landlab import FieldError
 
 from . import _links as links
 
 _SEVEN_OVER_THREE = 7.0 / 3.0
 
 
 def _active_links_at_node(grid, *args):
@@ -152,15 +151,14 @@
         node_ids = np.broadcast_arrays(args[0])[0]
         return active_links_at_node[node_ids, :].T
     else:
         raise ValueError("only zero or one arguments accepted")
 
 
 class OverlandFlow(Component):
-
     """Simulate overland flow using de Almeida approximations.
 
     Landlab component that simulates overland flow using the de Almeida
     et al., 2012 approximations of the 1D shallow water equations to be used
     for 2D flood inundation modeling.
 
     This component calculates discharge, depth and shear stress after some
@@ -579,17 +577,17 @@
             # Now we calculate the slope of the water surface elevation at
             # active links
             self._water_surface__gradient = self._grid.calc_grad_at_link(w)[
                 self._grid.active_links
             ]
 
             # And insert these values into an array of all links
-            self._water_surface_slope[
-                self._active_links
-            ] = self._water_surface__gradient
+            self._water_surface_slope[self._active_links] = (
+                self._water_surface__gradient
+            )
             # If the user chooses to set boundary links to the neighbor value,
             # we set the discharge array to have the boundary links set to
             # their neighbor value
             if self._default_fixed_links is True:
                 self._q[self._grid.fixed_links] = self._q[self._active_neighbors]
 
             # Now we can calculate discharge. To handle links with neighbors
```

### Comparing `landlab-2.7.0/landlab/components/overland_flow/generate_overland_flow_implicit_kinwave.py` & `landlab-2.8.0/landlab/components/overland_flow/generate_overland_flow_implicit_kinwave.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 kinematic-wave approximation.
 
 Created on Fri May 27 14:26:13 2016
 
 @author: gtucker
 """
 
-
 import numpy as np
 from scipy.optimize import newton
 
 from landlab import Component
 from landlab.components import FlowAccumulator
 
 
@@ -140,15 +139,15 @@
     >>> z = rg.add_zeros("topographic__elevation", at="node")
     >>> kw = KinwaveImplicitOverlandFlow(rg)
     >>> round(kw.runoff_rate * 1.0e7, 2)
     2.78
     >>> kw.vel_coef  # default value
     100.0
     >>> rg.at_node["surface_water__depth"][6:9]
-    array([ 0.,  0.,  0.])
+    array([0., 0., 0.])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     None Listed
```

### Comparing `landlab-2.7.0/landlab/components/overland_flow/generate_overland_flow_kinwave.py` & `landlab-2.8.0/landlab/components/overland_flow/generate_overland_flow_kinwave.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 """Landlab component for overland flow using the kinematic-wave approximation.
 
 Created on Fri May 27 14:26:13 2016
 
 @author: gtucker
 """
 
-
 import numpy as np
 
 from landlab import Component
 
 
 class KinwaveOverlandFlowModel(Component):
     """Calculate water flow over topography.
@@ -30,16 +29,16 @@
     >>> rg = RasterModelGrid((4, 5), xy_spacing=10.0)
     >>> z = rg.add_zeros("topographic__elevation", at="node")
     >>> s = rg.add_zeros("topographic__gradient", at="link")
     >>> kw = KinwaveOverlandFlowModel(rg)
     >>> kw.vel_coef
     100.0
     >>> rg.at_node["surface_water__depth"]
-    array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,
-            0.,  0.,  0.,  0.,  0.,  0.,  0.])
+    array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+           0., 0., 0., 0., 0., 0., 0.])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     None Listed
```

### Comparing `landlab-2.7.0/landlab/components/overland_flow/kinematic_wave_rengers.py` & `landlab-2.8.0/landlab/components/overland_flow/kinematic_wave_rengers.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 #!/usr/bin/env python
 
 import numpy as np
 
-from landlab import Component, RasterModelGrid
+from landlab import Component
+from landlab import RasterModelGrid
 
 
 class KinematicWaveRengers(Component):
     """
     This code is based on an overland flow model by Francis Rengers and
     colleagues, after Julien et al., 1995. It uses an explicit face-centered
     solution to a depth-varying Manning's equation, broadly following, e.g.,
@@ -79,31 +80,31 @@
     >>> dt = 60.0  # 1 min intervals
     >>> rain_intensities = (1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5)
     >>> kw = KinematicWaveRengers(mg)
     >>> for i in rain_intensities:
     ...     kw.run_one_step(dt, rainfall_intensity=i)
     ...
     >>> mg.at_node["surface_water__depth"]
-    array([  1.00000000e-08,   1.00000000e-08,   1.00000000e-08,
-             1.00000000e-08,   1.00000000e-08,   1.00000000e-08,
-             1.00000000e-08,   1.00000000e-08,   1.00000000e-08,
-             1.00000000e-08,   2.95578314e-03,   2.95578314e-03,
-             2.90945761e-03,   2.82912876e-03,   2.70127141e-03,
-             2.51202011e-03,   2.24617193e-03,   1.88032853e-03,
-             1.35451064e-03,   1.00000000e-08,   2.95578314e-03,
-             2.95578314e-03,   2.90945761e-03,   2.82912876e-03,
-             2.70127141e-03,   2.51202011e-03,   2.24617193e-03,
-             1.88032853e-03,   1.35451064e-03,   1.00000000e-08,
-             2.95578314e-03,   2.95578314e-03,   2.90945761e-03,
-             2.82912876e-03,   2.70127141e-03,   2.51202011e-03,
-             2.24617193e-03,   1.88032853e-03,   1.35451064e-03,
-             1.00000000e-08,   1.00000000e-08,   1.00000000e-08,
-             1.00000000e-08,   1.00000000e-08,   1.00000000e-08,
-             1.00000000e-08,   1.00000000e-08,   1.00000000e-08,
-             1.00000000e-08,   1.00000000e-08])
+    array([1.00000000e-08, 1.00000000e-08, 1.00000000e-08,
+           1.00000000e-08, 1.00000000e-08, 1.00000000e-08,
+           1.00000000e-08, 1.00000000e-08, 1.00000000e-08,
+           1.00000000e-08, 2.95578314e-03, 2.95578314e-03,
+           2.90945761e-03, 2.82912876e-03, 2.70127141e-03,
+           2.51202011e-03, 2.24617193e-03, 1.88032853e-03,
+           1.35451064e-03, 1.00000000e-08, 2.95578314e-03,
+           2.95578314e-03, 2.90945761e-03, 2.82912876e-03,
+           2.70127141e-03, 2.51202011e-03, 2.24617193e-03,
+           1.88032853e-03, 1.35451064e-03, 1.00000000e-08,
+           2.95578314e-03, 2.95578314e-03, 2.90945761e-03,
+           2.82912876e-03, 2.70127141e-03, 2.51202011e-03,
+           2.24617193e-03, 1.88032853e-03, 1.35451064e-03,
+           1.00000000e-08, 1.00000000e-08, 1.00000000e-08,
+           1.00000000e-08, 1.00000000e-08, 1.00000000e-08,
+           1.00000000e-08, 1.00000000e-08, 1.00000000e-08,
+           1.00000000e-08, 1.00000000e-08])
     """
 
     _name = "KinematicWaveRengers"
 
     _unit_agnostic = False
 
     _info = {
```

### Comparing `landlab-2.7.0/landlab/components/overland_flow/linear_diffusion_overland_flow_router.py` & `landlab-2.8.0/landlab/components/overland_flow/linear_diffusion_overland_flow_router.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 """Landlab component for overland flow using the linearized diffusion-wave approximation.
 
 Created on Fri May 27 14:26:13 2016
 
 @author: gtucker
 """
 
-
 import numpy as np
 
 from landlab import Component
 
 _FOUR_THIRDS = 4.0 / 3.0
 _SEVEN_THIRDS = 7.0 / 3.0
 _MICRO_DEPTH = 1.0e-6  # tiny water depth to avoid blowup in time-step estimator
```

### Comparing `landlab-2.7.0/landlab/components/pet/potential_evapotranspiration_field.py` & `landlab-2.8.0/landlab/components/pet/potential_evapotranspiration_field.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,15 +7,14 @@
 
 def _assert_method_is_valid(method):
     if method not in _VALID_METHODS:
         raise ValueError("%s: Invalid method name" % method)
 
 
 class PotentialEvapotranspiration(Component):
-
     """
     Potential Evapotranspiration Component calculates spatially distributed
     potential evapotranspiration based on input radiation factor (spatial
     distribution of incoming radiation) using chosen method such as constant
     or Priestley Taylor. Ref: Xiaochi et. al. 2013 for 'Cosine' method and
     ASCE-EWRI Task Committee Report Jan 2005 for 'PriestleyTaylor' method.
     Note: Calling 'PriestleyTaylor' method would generate/overwrite shortwave &
@@ -94,48 +93,48 @@
     _info = {
         "radiation__incoming_shortwave_flux": {
             "dtype": float,
             "intent": "out",
             "optional": False,
             "units": "W/m^2",
             "mapping": "cell",
-            "doc": "total incident shortwave radiation over the time step",
+            "doc": "incident shortwave radiation",
         },
         "radiation__net_flux": {
             "dtype": float,
             "intent": "out",
             "optional": False,
             "units": "W/m^2",
             "mapping": "cell",
-            "doc": "net total radiation over the time step",
+            "doc": "net radiation",
         },
         "radiation__net_longwave_flux": {
             "dtype": float,
             "intent": "out",
             "optional": False,
             "units": "W/m^2",
             "mapping": "cell",
-            "doc": "net incident longwave radiation over the time step",
+            "doc": "net incident longwave radiation",
         },
         "radiation__net_shortwave_flux": {
             "dtype": float,
             "intent": "out",
             "optional": False,
             "units": "W/m^2",
             "mapping": "cell",
-            "doc": "net incident shortwave radiation over the time step",
+            "doc": "net incident shortwave radiation",
         },
         "radiation__ratio_to_flat_surface": {
             "dtype": float,
             "intent": "in",
             "optional": False,
             "units": "None",
             "mapping": "cell",
             "doc": (
-                "ratio of total incident shortwave radiation on sloped "
+                "ratio of incident shortwave radiation on sloped "
                 "surface to flat surface"
             ),
         },
         "surface__potential_evapotranspiration_rate": {
             "dtype": float,
             "intent": "out",
             "optional": False,
```

### Comparing `landlab-2.7.0/landlab/components/plant_competition_ca/plant_competition_ca.py` & `landlab-2.8.0/landlab/components/plant_competition_ca/plant_competition_ca.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/potentiality_flowrouting/route_flow_by_boundary.py` & `landlab-2.8.0/landlab/components/potentiality_flowrouting/route_flow_by_boundary.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,15 +7,17 @@
 """
 
 # ##in the diagonal case, even closed edges can produce "drag". Is this right?
 # Could suppress by mirroring the diagonals
 
 import numpy as np
 
-from landlab import Component, LinkStatus, RasterModelGrid
+from landlab import Component
+from landlab import LinkStatus
+from landlab import RasterModelGrid
 
 
 class PotentialityFlowRouter(Component):
     """Multidirectional flow routing using a novel method.
 
     This class implements Voller, Hobley, and Paola's experimental matrix
     solutions for flow routing. The method works by solving for a potential
@@ -62,16 +64,16 @@
     ... )
     >>> z = mg.add_zeros("topographic__elevation", at="node")
     >>> Q_in = mg.add_ones("water__unit_flux_in", at="node")
     >>> z += mg.node_y.copy()
     >>> potfr = PotentialityFlowRouter(mg)
     >>> potfr.run_one_step()
     >>> mg.at_node["surface_water__discharge"][mg.core_nodes]
-    array([ 11.70706863,  11.5709712 ,  10.41329927,   9.24959728,
-             6.65448576,   6.39262702,   5.71410162,   5.04743495])
+    array([11.70706863, 11.5709712 , 10.41329927,  9.24959728,
+            6.65448576,  6.39262702,  5.71410162,  5.04743495])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     None Listed
```

### Comparing `landlab-2.7.0/landlab/components/priority_flood_flow_router/README.md` & `landlab-2.8.0/landlab/components/priority_flood_flow_router/README.md`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/priority_flood_flow_router/cfuncs.pyx` & `landlab-2.8.0/landlab/components/priority_flood_flow_router/cfuncs.pyx`

 * *Files 24% similar despite different names*

```diff
@@ -1,83 +1,104 @@
 import numpy as np
 
-cimport cython
 cimport numpy as np
 
 DTYPE_INT = int
 ctypedef np.int_t DTYPE_INT_t
 
 DTYPE_FLOAT = np.double
 ctypedef np.double_t DTYPE_FLOAT_t
 
 
-cpdef _D8_flowDir(np.ndarray[DTYPE_INT_t, ndim=1] receivers,
-             np.ndarray[DTYPE_FLOAT_t, ndim=1] distance_receiver,
-             np.ndarray[DTYPE_FLOAT_t, ndim=1] steepest_slope,
-             np.ndarray[DTYPE_FLOAT_t, ndim=1] el_dep_free,
-             np.ndarray[DTYPE_FLOAT_t, ndim=1] el_ori,
-             np.ndarray[DTYPE_FLOAT_t, ndim=1] dist,
-             np.ndarray[DTYPE_INT_t, ndim=1] ngb,
-             np.ndarray[DTYPE_INT_t, ndim=1] activeCores,
-             np.ndarray[DTYPE_INT_t, ndim=1] activeCells,
-             np.ndarray[DTYPE_FLOAT_t, ndim=1] el_d,
-             DTYPE_INT_t c,
-             DTYPE_FLOAT_t dx,
-             np.ndarray[DTYPE_INT_t, ndim=2] adj_link ,
-             np.ndarray[DTYPE_INT_t, ndim=1] rec_link):
-
+cpdef _D8_flowDir(
+    np.ndarray[DTYPE_INT_t, ndim=1] receivers,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] distance_receiver,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] steepest_slope,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] el_dep_free,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] el_ori,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] dist,
+    np.ndarray[DTYPE_INT_t, ndim=1] ngb,
+    np.ndarray[DTYPE_INT_t, ndim=1] activeCores,
+    np.ndarray[DTYPE_INT_t, ndim=1] activeCells,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] el_d,
+    DTYPE_INT_t c,
+    DTYPE_FLOAT_t dx,
+    np.ndarray[DTYPE_INT_t, ndim=2] adj_link ,
+    np.ndarray[DTYPE_INT_t, ndim=1] rec_link,
+):
     """
     Calcualte D8 flow dirs
     """
     cdef int idx, i
 
     # for i in range(0,r*c):
     for i in activeCores:
         ngb[0] = i + 1
         ngb[1] = i + c
         ngb[2] = i - 1
-        ngb[3] = i -c
+        ngb[3] = i - c
         ngb[4] = i + c + 1
         ngb[5] = i + c - 1
         ngb[6] = i -c - 1
         ngb[7] = i -c + 1
 
         # Differences after filling can be very small, *1e3 to exaggerate those
         # Set to -1 at boundaries (active cell ==0)
-        # If cells have equal slopes, the flow will be directed following Landlab rotational ordening going first to cardial, then to diagonal cells
-        el_d[0] = (el_dep_free[i] - el_dep_free[i + 1])*1e3*activeCells[i + 1]-1+activeCells[i + 1]
-        el_d[1] = (el_dep_free[i] - el_dep_free[i + c])*1e3 *activeCells[i + c]-1+activeCells[i + c]
-        el_d[2] = (el_dep_free[i] - el_dep_free[i -1])*1e3  *activeCells[i -1]-1+activeCells[i -1]
-        el_d[3] = (el_dep_free[i] - el_dep_free[i - c])*1e3 *activeCells[i - c]-1+activeCells[i - c]
-        el_d[4] = (el_dep_free[i] - el_dep_free[i + c + 1])*1e3/(np.sqrt(2)) *activeCells[i + c + 1]-1+activeCells[i + c + 1]
-        el_d[5] = (el_dep_free[i] - el_dep_free[i + c - 1])*1e3/(np.sqrt(2)) *activeCells[i + c - 1]-1+activeCells[i + c - 1]
-        el_d[6] = (el_dep_free[i] - el_dep_free[i -c - 1])*1e3/(np.sqrt(2)) *activeCells[i -c - 1]-1+activeCells[i -c - 1]
-        el_d[7] = (el_dep_free[i] - el_dep_free[i -c + 1])*1e3/(np.sqrt(2)) *activeCells[i -c + 1]-1+activeCells[i -c + 1]
-
+        # If cells have equal slopes, the flow will be directed following
+        # Landlab rotational ordening going first to cardial, then to diagonal cells
+        el_d[0] = (
+            el_dep_free[i] - el_dep_free[i + 1]
+        ) * 1e3 * activeCells[i + 1]- 1 + activeCells[i + 1]
+        el_d[1] = (
+            el_dep_free[i] - el_dep_free[i + c]
+        ) * 1e3 * activeCells[i + c] - 1 + activeCells[i + c]
+        el_d[2] = (
+            el_dep_free[i] - el_dep_free[i -1]
+        ) * 1e3 * activeCells[i - 1] - 1 + activeCells[i - 1]
+        el_d[3] = (
+            el_dep_free[i] - el_dep_free[i - c]
+        ) * 1e3 * activeCells[i - c] - 1 + activeCells[i - c]
+        el_d[4] = (
+            el_dep_free[i] - el_dep_free[i + c + 1]
+        ) * 1e3 / np.sqrt(2) * activeCells[i + c + 1] - 1 + activeCells[i + c + 1]
+        el_d[5] = (
+            el_dep_free[i] - el_dep_free[i + c - 1]
+        ) * 1e3 / np.sqrt(2) * activeCells[i + c - 1] - 1 + activeCells[i + c - 1]
+        el_d[6] = (
+            el_dep_free[i] - el_dep_free[i - c - 1]
+        ) * 1e3 / np.sqrt(2) * activeCells[i - c - 1] - 1 + activeCells[i - c - 1]
+        el_d[7] = (
+            el_dep_free[i] - el_dep_free[i - c + 1]
+        ) * 1e3 / np.sqrt(2) * activeCells[i - c + 1] - 1 + activeCells[i - c + 1]
 
         # check to see if pixel is not a lake, if a lake, drain to itself
-        if np.max(el_d)>=0:
+        if np.max(el_d) >= 0:
             idx = np.argmax(el_d)
             receivers[i] = ngb[idx]
-            distance_receiver[i]=dist[idx]
-            rec_link[i]= adj_link[i][idx]
-            # Slope over original dem can have negative values, but we set it to zero here in analogy to the other Landlab LakeFiller
-            steepest_slope[i]  = np.maximum(0,(el_ori[i]-el_ori[receivers[i]])/distance_receiver[i])
+            distance_receiver[i] = dist[idx]
+            rec_link[i] = adj_link[i][idx]
+            # Slope over original dem can have negative values, but we set
+            # it to zero here in analogy to the other Landlab LakeFiller
+            steepest_slope[i] = np.maximum(
+                0, (el_ori[i] - el_ori[receivers[i]]) / distance_receiver[i]
+            )
         else:
             receivers[i] = i
-            rec_link[i]= -1
+            rec_link[i] = -1
             steepest_slope[i] = 0
 
-cpdef _D8_FlowAcc(np.ndarray[DTYPE_FLOAT_t, ndim=1] a,
-             np.ndarray[DTYPE_FLOAT_t, ndim=1] q,
-             np.ndarray[DTYPE_INT_t, ndim=1] stack_flip,
-             np.ndarray[DTYPE_INT_t, ndim=1] receivers):
+cpdef _D8_FlowAcc(
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] a,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] q,
+    np.ndarray[DTYPE_INT_t, ndim=1] stack_flip,
+    np.ndarray[DTYPE_INT_t, ndim=1] receivers,
+):
     """
     Accumulates drainage area and discharge, permitting transmission losses.
     """
-    cdef int donor, recvr, i
+    cdef int donor
 
     # Work from upstream to downstream.
     for donor in stack_flip:
         rcvr = receivers[donor]
         a[rcvr] += a[donor]
         q[rcvr] += q[donor]
```

### Comparing `landlab-2.7.0/landlab/components/priority_flood_flow_router/priority_flood_flow_router.py` & `landlab-2.8.0/landlab/components/priority_flood_flow_router/priority_flood_flow_router.py`

 * *Files 0% similar despite different names*

```diff
@@ -15,34 +15,36 @@
 
 import copy as cp
 from functools import partial
 
 import numpy as np
 import numpy.matlib as npm
 
-from landlab import Component, FieldError, RasterModelGrid
+from landlab import Component
+from landlab import FieldError
+from landlab import RasterModelGrid
 from landlab.grid.nodestatus import NodeStatus
 from landlab.utils.return_array import return_array_at_node
 
 from ...utils.suppress_output import suppress_output
-from .cfuncs import _D8_FlowAcc, _D8_flowDir
+from .cfuncs import _D8_FlowAcc
+from .cfuncs import _D8_flowDir
 
 # Codes for depression status
 _UNFLOODED = 0
 _PIT = 1
 _CURRENT_LAKE = 2
 _FLOODED = 3
 # Flow metrics resulting in single flow
 PSINGLE_FMs = ["D8", "D4", "Rho8", "Rho4"]
 # Flow metrics resulting in multiple flow
 PMULTIPLE_FMs = ["Quinn", "Freeman", "Holmgren", "Dinf"]
 
 
 class PriorityFloodFlowRouter(Component):
-
     """Component to accumulate flow and calculate drainage area based RICHDEM software package.
 
     See also: https://richdem.readthedocs.io/en/latest/
 
 
     .. note::
```

### Comparing `landlab-2.7.0/landlab/components/profiler/base_profiler.py` & `landlab-2.8.0/landlab/components/profiler/base_profiler.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 # ! /usr/env/python
 """Base class for profile constructors."""
 
-from abc import ABC, abstractmethod
+from abc import ABC
+from abc import abstractmethod
 
 import matplotlib.pyplot as plt
 from matplotlib.collections import LineCollection
 
 from landlab import Component
 from landlab.plot import imshow_grid
 from landlab.utils.return_array import return_array_at_node
@@ -168,15 +169,15 @@
         ...     fa.run_one_step()
         ...     sp.run_one_step(dt=dt)
         ...     z[mg.core_nodes] += 0.001 * dt
         ...
         >>> profiler = ChannelProfiler(mg)
         >>> profiler.run_one_step()
         >>> np.round(profiler.colors, decimals=2)
-        array([[ 0.27,  0.  ,  0.33,  1.  ]])
+        array([[0.27, 0.  , 0.33, 1.  ]])
         """
         return self._colors
 
     def plot_profiles(
         self,
         field="topographic__elevation",
         xlabel="Distance Along Profile",
```

### Comparing `landlab-2.7.0/landlab/components/profiler/channel_profiler.py` & `landlab-2.8.0/landlab/components/profiler/channel_profiler.py`

 * *Files 4% similar despite different names*

```diff
@@ -335,62 +335,62 @@
 
     The value of the segment between nodes 40 and 41 has the following
     components:
 
     >>> profiler.data_structure[40][(40, 41)]["ids"]
     array([40, 41])
     >>> profiler.data_structure[40][(40, 41)]["distances"]
-    array([ 0.,  1.])
+    array([0., 1.])
     >>> np.round(profiler.data_structure[40][(40, 41)]["color"], decimals=2)
-    array([ 0.27,  0.  ,  0.33,  1.  ])
+    array([0.27, 0.  , 0.33, 1.  ])
 
     A parallel structure exists for the segment between nodes 41 and 54:
 
     >>> profiler.data_structure[40][(41, 54)]["ids"]
     array([41, 42, 43, 44, 54])
     >>> profiler.data_structure[40][(41, 54)]["distances"]
-    array([ 1.,  2.,  3.,  4.,  5.])
+    array([1., 2., 3., 4., 5.])
     >>> np.round(profiler.data_structure[40][(41, 54)]["color"], decimals=2)
-    array([ 0.27,  0.  ,  0.33,  1.  ])
+    array([0.27, 0.  , 0.33, 1.  ])
 
     And the segment between nodes 41  and 62.
 
     >>> profiler.data_structure[40][(41, 62)]["ids"]
     array([41, 51, 61, 62])
     >>> profiler.data_structure[40][(41, 62)]["distances"]
-    array([ 1.,  2.,  3.,  4.])
+    array([1., 2., 3., 4.])
     >>> np.round(profiler.data_structure[40][(41, 62)]["color"], decimals=2)
-    array([ 0.27,  0.  ,  0.33,  1.  ])
+    array([0.27, 0.  , 0.33, 1.  ])
 
     The rest of the ``profile_structure`` encodes information about the second
     watershed, which drains to node 8.
 
     >>> profiler.data_structure[8].keys()
     odict_keys([(8, 26), (26, 23), (26, 66)])
 
     >>> profiler.data_structure[8][(8, 26)]["ids"]
     array([ 8, 18, 17, 16, 26])
     >>> profiler.data_structure[8][(8, 26)]["distances"]
-    array([ 0.,  1.,  2.,  3.,  4.])
+    array([0., 1., 2., 3., 4.])
     >>> np.round(profiler.data_structure[8][(8, 26)]["color"], decimals=2)
-    array([ 0.13,  0.57,  0.55,  1.  ])
+    array([0.13, 0.57, 0.55, 1.  ])
 
     >>> profiler.data_structure[8][(26, 23)]["ids"]
     array([26, 25, 24, 23])
     >>> profiler.data_structure[8][(26, 23)]["distances"]
-    array([ 4.,  5.,  6.,  7.])
+    array([4., 5., 6., 7.])
     >>> np.round(profiler.data_structure[8][(26, 23)]["color"], decimals=2)
-    array([ 0.13,  0.57,  0.55,  1.  ])
+    array([0.13, 0.57, 0.55, 1.  ])
 
     >>> profiler.data_structure[8][(26, 66)]["ids"]
     array([26, 36, 46, 56, 66])
     >>> profiler.data_structure[8][(26, 66)]["distances"]
-    array([ 4.,  5.,  6.,  7.,  8.])
+    array([4., 5., 6., 7., 8.])
     >>> np.round(profiler.data_structure[8][(26, 66)]["color"], decimals=2)
-    array([ 0.13,  0.57,  0.55,  1.  ])
+    array([0.13, 0.57, 0.55, 1.  ])
 
     The ChannelProfiler is designed to be flexible, and by careful combination
     of its instantiation variables can be used to extract many useful forms of
     profile. In these examples, we will use the default
     ``channel_definition_field``, the drainage area.
 
     To illustrate, lets start by creating a landscape model.
```

### Comparing `landlab-2.7.0/landlab/components/profiler/profiler.py` & `landlab-2.8.0/landlab/components/profiler/profiler.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,15 @@
 # ! /usr/env/python
 """profiler.py component to create profiles with user-defined endpoints."""
 from collections import OrderedDict
 
 import numpy as np
-from matplotlib import cm, colors, pyplot as plt
+from matplotlib import cm
+from matplotlib import colors
+from matplotlib import pyplot as plt
 
 from landlab.components.profiler.base_profiler import _BaseProfiler
 
 
 class Profiler(_BaseProfiler):
     """Extract and plot profiles set up using points within a grid.
 
@@ -94,17 +96,17 @@
 
     The data structure contains data of segment samples. Below is the first
     segment.
 
     >>> profiler.data_structure[0]["ids"]
     array([10, 11, 12, 13, 14, 15, 16])
     >>> profiler.data_structure[0]["distances"]
-    array([  0.,  10.,  20.,  30.,  40.,  50.,  60.])
+    array([ 0., 10., 20., 30., 40., 50., 60.])
     >>> np.round(profiler.data_structure[0]["color"], decimals=2)
-    array([ 0.27,  0.  ,  0.33,  1.  ])
+    array([0.27, 0.  , 0.33, 1.  ])
 
     Note that the first node of the second segment is the same as the final
     node of the first segment.
 
     >>> profiler.data_structure[1]["ids"]
     array([16, 26, 35, 45, 54, 64])
```

### Comparing `landlab-2.7.0/landlab/components/profiler/trickle_down_profiler.py` & `landlab-2.8.0/landlab/components/profiler/trickle_down_profiler.py`

 * *Files 2% similar despite different names*

```diff
@@ -214,30 +214,30 @@
 
     The value of the segment between nodes 40 and 54 has the following
     components:
 
     >>> profiler.data_structure[54][(40, 54)]["ids"]
     array([40, 41, 42, 43, 44, 54])
     >>> profiler.data_structure[54][(40, 54)]["distances"]
-    array([ 0.,  1.,  2.,  3.,  4.,  5.])
+    array([0., 1., 2., 3., 4., 5.])
     >>> np.round(profiler.data_structure[54][(40, 54)]["color"], decimals=2)
-    array([ 0.27,  0.  ,  0.33,  1.  ])
+    array([0.27, 0.  , 0.33, 1.  ])
 
     The rest of the ``profile_structure`` encodes information about the second
     profile which starts at node 66.
 
     >>> profiler.data_structure[66].keys()
     dict_keys([(8, 66)])
 
     >>> profiler.data_structure[66][(8, 66)]["ids"]
     array([ 8, 18, 17, 16, 26, 36, 46, 56, 66])
     >>> profiler.data_structure[66][(8, 66)]["distances"]
-    array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])
+    array([0., 1., 2., 3., 4., 5., 6., 7., 8.])
     >>> np.round(profiler.data_structure[66][(8, 66)]["color"], decimals=2)
-    array([ 0.13,  0.57,  0.55,  1.  ])
+    array([0.13, 0.57, 0.55, 1.  ])
 
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     None Listed
```

### Comparing `landlab-2.7.0/landlab/components/sink_fill/fill_sinks.py` & `landlab-2.8.0/landlab/components/sink_fill/fill_sinks.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,21 @@
 """Created on Mon Oct 19.
 
 @author: dejh
 """
+
 import contextlib
 
 import numpy as np
 
-from landlab import Component, FieldError, RasterModelGrid
-from landlab.components import DepressionFinderAndRouter, FlowAccumulator
+from landlab import Component
+from landlab import FieldError
+from landlab import RasterModelGrid
+from landlab.components import DepressionFinderAndRouter
+from landlab.components import FlowAccumulator
 
 # TODO: this should probably follow Barnes et al., 2014 for max efficiency
 
 
 class SinkFiller(Component):
     """This component identifies depressions in a topographic surface, then
     fills them in in the topography.  No attempt is made to conserve sediment
```

### Comparing `landlab-2.7.0/landlab/components/sink_fill/sink_fill_barnes.py` & `landlab-2.8.0/landlab/components/sink_fill/sink_fill_barnes.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/soil_moisture/infiltrate_soil_green_ampt.py` & `landlab-2.8.0/landlab/components/soil_moisture/infiltrate_soil_green_ampt.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 
 import numpy as np
 
 from landlab import Component
 
 
 class SoilInfiltrationGreenAmpt(Component):
-
     """Infiltrate surface water into a soil following the Green-Ampt method.
 
     This component calculates the infiltation of surface water into the soil,
     using the Green-Ampt method. The component tracks the depth of infiltrated
     water over time, in the field soil_water_infiltration__depth. It also
     modifies the depth of surface water (surface_water__depth) as surface water
     progressively infiltrates into the soil below.
@@ -29,22 +28,22 @@
     >>> SI = SoilInfiltrationGreenAmpt(
     ...     mg, hydraulic_conductivity=hydraulic_conductivity
     ... )
     >>> for i in range(10):  # 100s total
     ...     SI.run_one_step(10.0)
     ...
     >>> mg.at_node["surface_water__depth"]
-    array([  1.00000000e-08,   1.00000000e-08,   1.00000000e-08,
-             1.00000000e-08,   1.00000000e-08,   1.00000000e-08,
-             9.88530416e-03,   9.88530416e-03,   9.88530416e-03,
-             9.88530416e-03,   9.88530416e-03,   9.88530416e-03])
+    array([1.00000000e-08, 1.00000000e-08, 1.00000000e-08,
+           1.00000000e-08, 1.00000000e-08, 1.00000000e-08,
+           9.88530416e-03, 9.88530416e-03, 9.88530416e-03,
+           9.88530416e-03, 9.88530416e-03, 9.88530416e-03])
     >>> mg.at_node["soil_water_infiltration__depth"]
-    array([ 0.20999999,  0.20999999,  0.20999999,  0.20999999,  0.20999999,
-            0.20999999,  0.2001147 ,  0.2001147 ,  0.2001147 ,  0.2001147 ,
-            0.2001147 ,  0.2001147 ])
+    array([0.20999999, 0.20999999, 0.20999999, 0.20999999, 0.20999999,
+           0.20999999, 0.2001147 , 0.2001147 , 0.2001147 , 0.2001147 ,
+           0.2001147 , 0.2001147 ])
 
     Notes
     -----
     This code is based on an overland flow model by Francis Rengers and
     colleagues, after Julien et al., 1995. The infiltration scheme follows the
     Green and Ampt equation. It was implemented in Landlab by DEJH, March 2016.
```

### Comparing `landlab-2.7.0/landlab/components/soil_moisture/soil_moisture_dynamics.py` & `landlab-2.8.0/landlab/components/soil_moisture/soil_moisture_dynamics.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/space/ext/calc_qs.pyx` & `landlab-2.8.0/landlab/components/space/ext/calc_qs.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 import numpy as np
 
-cimport cython
 cimport numpy as np
 
 
 cdef extern from "math.h":
     double exp(double x) nogil
 
 DTYPE_FLOAT = np.double
 ctypedef np.double_t DTYPE_FLOAT_t
 
 DTYPE_INT = int
 ctypedef np.int_t DTYPE_INT_t
 
 
-def calculate_qs_in(np.ndarray[DTYPE_INT_t, ndim=1] stack_flip_ud,
-                    np.ndarray[DTYPE_INT_t, ndim=1] flow_receivers,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] cell_area_at_node,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] q,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] qs,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] qs_in,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] Es,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] Er,
-                    DTYPE_FLOAT_t v_s,
-                    DTYPE_FLOAT_t F_f):
+def calculate_qs_in(
+    np.ndarray[DTYPE_INT_t, ndim=1] stack_flip_ud,
+    np.ndarray[DTYPE_INT_t, ndim=1] flow_receivers,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] cell_area_at_node,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] q,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] qs,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] qs_in,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] Es,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] Er,
+    DTYPE_FLOAT_t v_s,
+    DTYPE_FLOAT_t F_f,
+):
     """Calculate and qs and qs_in."""
     # define internal variables
     cdef unsigned int n_nodes = stack_flip_ud.shape[0]
     cdef unsigned int node_id
     cdef unsigned int i
 
     # iterate top to bottom through the stack, calculate qs and adjust  qs_in
@@ -42,16 +43,19 @@
         # the upstream to downstream node ordering).
 
         # Because calculation of qs requires qs_in, this operation must be done
         # in an upstream to downstream loop, and cannot be vectorized.
 
         # there is water flux (q) and this node is not a pit then calculate qs.
         if q[node_id] > 0 and (flow_receivers[node_id] != node_id):
-            qs[node_id] = (qs_in[node_id] + ((Es[node_id]) + ((1.0 - F_f) * (Er[node_id]))) * cell_area_at_node[node_id]) / \
-                            (1.0 + (v_s * cell_area_at_node[node_id] / (q[node_id])))
+            qs[node_id] = (
+                qs_in[node_id]
+                + ((Es[node_id]) + ((1.0 - F_f) * (Er[node_id])))
+                * cell_area_at_node[node_id]
+            ) / (1.0 + (v_s * cell_area_at_node[node_id] / (q[node_id])))
 
             # finally, add this nodes qs to recieiving nodes qs_in.
             # if qs[node_id] == 0, then there is no need for this line to be
             # evaluated.
             qs_in[flow_receivers[node_id]] += qs[node_id]
 
         else:
```

### Comparing `landlab-2.7.0/landlab/components/space/ext/calc_sequential_ero_depo.pyx` & `landlab-2.8.0/landlab/components/space/ext/calc_sequential_ero_depo.pyx`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,9 @@
 import numpy as np
 
-cimport cython
 cimport numpy as np
 
 
 cdef extern from "math.h":
     double exp(double x) nogil
 
 from libc.math cimport exp, log
@@ -14,87 +13,107 @@
 
 DTYPE_INT = int
 ctypedef np.int_t DTYPE_INT_t
 
 DTYPE_UINT8 = np.uint8
 ctypedef np.uint8_t DTYPE_UINT8_t
 
-from libc.stdio cimport printf
 
-
-def _sequential_ero_depo(np.ndarray[DTYPE_INT_t, ndim=1] stack_flip_ud_sel,
-                    np.ndarray[DTYPE_INT_t, ndim=1] flow_receivers,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] cell_area,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] q,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] qs,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] qs_in,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] Es,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] Er,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] Q_to_the_m,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] slope,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] H,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] br,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] sed_erosion_term,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] bed_erosion_term,
-                    np.ndarray[DTYPE_FLOAT_t, ndim=1] K_sed,
-                    DTYPE_FLOAT_t v,
-                    DTYPE_FLOAT_t phi,
-                    DTYPE_FLOAT_t F_f,
-                    DTYPE_FLOAT_t H_star,
-                    DTYPE_FLOAT_t dt,
-                    DTYPE_FLOAT_t thickness_lim):
+def _sequential_ero_depo(
+    np.ndarray[DTYPE_INT_t, ndim=1] stack_flip_ud_sel,
+    np.ndarray[DTYPE_INT_t, ndim=1] flow_receivers,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] cell_area,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] q,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] qs,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] qs_in,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] Es,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] Er,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] Q_to_the_m,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] slope,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] H,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] br,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] sed_erosion_term,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] bed_erosion_term,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] K_sed,
+    DTYPE_FLOAT_t v,
+    DTYPE_FLOAT_t phi,
+    DTYPE_FLOAT_t F_f,
+    DTYPE_FLOAT_t H_star,
+    DTYPE_FLOAT_t dt,
+    DTYPE_FLOAT_t thickness_lim,
+):
 
     """Calculate and qs and qs_in."""
     # define internal variables
     cdef unsigned int node_id
-    cdef unsigned int i
     cdef double H_Before
     cdef double vol_SSY_riv
     vol_SSY_riv =0.0
 
     for node_id in stack_flip_ud_sel:
-        qs_out = (qs_in[node_id] + Es[node_id]*cell_area[node_id] + (1.0-F_f)*Er[node_id]* cell_area[node_id]) / \
-                        (1.0+(v*cell_area[node_id]/q[node_id]))
+        qs_out = (
+            qs_in[node_id]
+            + Es[node_id] * cell_area[node_id]
+            + (1.0 - F_f) * Er[node_id] * cell_area[node_id]
+        ) / (1.0 + (v * cell_area[node_id] / q[node_id]))
+
         depo_rate = v*qs_out/q[node_id]
-        H_loc       =   H[node_id]
-        H_Before    =   H[node_id]
-        slope_loc   =   slope[node_id]
+        H_loc = H[node_id]
+        H_Before = H[node_id]
+        slope_loc = slope[node_id]
         sed_erosion_loc = sed_erosion_term[node_id]
         bed_erosion_loc = bed_erosion_term[node_id]
 
         # Correct for thick soils where soil thickness can grow to inf
         if (H_loc > thickness_lim or slope_loc <= 0 or   sed_erosion_loc==0):
             H_loc += (depo_rate / (1 - phi) - sed_erosion_loc/ (1 - phi)) * dt
         else:
             # Blowup
             if (depo_rate == (K_sed[node_id] * Q_to_the_m[node_id] * slope_loc)) :
                 H_loc = H_loc * log(
-                    ((sed_erosion_loc/ (1 - phi)) / H_star)
-                    * dt
-                    + exp(H_loc / H_star)
+                    ((sed_erosion_loc / (1 - phi)) / H_star) * dt + exp(H_loc / H_star)
                 )
             # No blowup
             else:
-                H_loc = H_star* np.log(
-                    (1 / ((depo_rate / (1 - phi)) / (sed_erosion_loc/ (1 - phi))- 1))
+                H_loc = H_star * np.log(
+                    (1 / ((depo_rate / (1 - phi)) / (sed_erosion_loc / (1 - phi)) - 1))
                     * (
-                        exp((depo_rate / (1 - phi)- (sed_erosion_loc/ (1 - phi)))* (dt / H_star))
-                        * (((depo_rate/ (1 - phi)/ (sed_erosion_loc/ (1 - phi))) - 1)* exp(H_loc/ H_star)+1)
-                        - 1
+                        exp(
+                            (depo_rate / (1 - phi) - (sed_erosion_loc / (1 - phi)))
+                            * (dt / H_star)
                         )
+                        * (
+                            (
+                                (depo_rate / (1 - phi) / (sed_erosion_loc / (1 - phi)))
+                                - 1
+                            )
+                            * exp(H_loc / H_star)
+                            + 1
+                        )
+                        - 1
+                    )
                 )
             # In case soil depth evolves to infinity, fall back to no entrainment
             if H_loc == np.inf:
-                H_loc =H[node_id]+ (depo_rate / (1 - phi) - sed_erosion_loc/ (1 - phi)) * dt
-
+                H_loc = (
+                    H[node_id]
+                    + (depo_rate / (1 - phi) - sed_erosion_loc/ (1 - phi)) * dt
+                )
 
-        H_loc = max(0,H_loc)
+        H_loc = max(0, H_loc)
         ero_bed = bed_erosion_loc* (exp(-H_loc / H_star))
-        qs_out_adj =  qs_in[node_id] - ((H_loc - H_Before)*(1-phi)*cell_area[node_id]/dt) +(1.0-F_f)*ero_bed* cell_area[node_id]# should always be bigger than 0
+
+        # should always be bigger than 0
+        qs_out_adj = (
+            qs_in[node_id]
+            - ((H_loc - H_Before) * (1 - phi) * cell_area[node_id] / dt)
+            + (1.0 - F_f) * ero_bed * cell_area[node_id]
+        )
 
         qs[node_id] = qs_out_adj
         qs_in[flow_receivers[node_id]] += qs[node_id]
 
         H[node_id] = H_loc
-        br[node_id]  += -dt * ero_bed
+        br[node_id] += -dt * ero_bed
         vol_SSY_riv += F_f*ero_bed* cell_area[node_id]
+
     return vol_SSY_riv
```

### Comparing `landlab-2.7.0/landlab/components/space/space.py` & `landlab-2.8.0/landlab/components/space/space.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 import numpy as np
 from scipy.integrate import quad
 
 from landlab.components.erosion_deposition.generalized_erosion_deposition import (
     DEFAULT_MINIMUM_TIME_STEP,
+)
+from landlab.components.erosion_deposition.generalized_erosion_deposition import (
     _GeneralizedErosionDeposition,
 )
 from landlab.utils.return_array import return_array_at_node
 
 from .ext.calc_qs import calculate_qs_in
 
 ROOT2 = np.sqrt(2.0)  # syntactic sugar for precalculated square root of 2
@@ -119,24 +121,24 @@
     ...     ha.run_one_step(dt=space_dt)
     ...     mg.at_node["bedrock__elevation"][0] -= 2e-6 * space_dt
     ...
 
     Now we test to see if soil depth and topography are right:
 
     >>> np.around(mg.at_node["soil__depth"], decimals=3)
-    array([ 0.5  ,  0.5  ,  0.5  ,  0.5  ,  0.5  ,  0.5  ,  0.495,  0.492,
-            0.491,  0.5  ,  0.5  ,  0.492,  0.492,  0.49 ,  0.5  ,  0.5  ,
-            0.491,  0.49 ,  0.484,  0.5  ,  0.5  ,  0.5  ,  0.5  ,  0.5  ,
-            0.5  ])
+    array([0.5  , 0.5  , 0.5  , 0.5  , 0.5  , 0.5  , 0.495, 0.492,
+           0.491, 0.5  , 0.5  , 0.492, 0.492, 0.49 , 0.5  , 0.5  ,
+           0.491, 0.49 , 0.484, 0.5  , 0.5  , 0.5  , 0.5  , 0.5  ,
+           0.5  ])
 
     >>> np.around(mg.at_node["topographic__elevation"], decimals=3)
-    array([ 0.423,  1.536,  2.573,  3.511,  4.561,  1.582,  0.424,  0.428,
-            0.438,  5.51 ,  2.54 ,  0.428,  0.428,  0.438,  6.526,  3.559,
-            0.438,  0.438,  0.45 ,  7.553,  4.559,  5.541,  6.57 ,  7.504,
-            8.51 ])
+    array([0.423, 1.536, 2.573, 3.511, 4.561, 1.582, 0.424, 0.428,
+           0.438, 5.51 , 2.54 , 0.428, 0.428, 0.438, 6.526, 3.559,
+           0.438, 0.438, 0.45 , 7.553, 4.559, 5.541, 6.57 , 7.504,
+           8.51 ])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     Shobe, C., Tucker, G., Barnhart, K. (2017). The SPACE 1.0 model: a Landlab
     component for 2-D calculation of sediment transport, bedrock erosion, and
@@ -649,19 +651,19 @@
         ...     sp_crit_sed=0,
         ...     sp_crit_br=0,
         ...     solver="adaptive",
         ... )
         >>> sp.run_one_step(dt=10.0)
 
         >>> np.round(sp.Es[5:7], 4)
-        array([ 0.0029,  0.0074])
+        array([0.0029, 0.0074])
         >>> np.round(sp.Er[5:7], 4)
-        array([ 0.0032,  0.0085])
+        array([0.0032, 0.0085])
         >>> np.round(H[5:7], 3)
-        array([ 0.088,  0.078])
+        array([0.088, 0.078])
         """
 
         # Initialize remaining_time, which records how much of the global time
         # step we have yet to use up.
         remaining_time = dt
 
         z = self._grid.at_node["topographic__elevation"]
```

### Comparing `landlab-2.7.0/landlab/components/space/space_large_scale_eroder.py` & `landlab-2.8.0/landlab/components/space/space_large_scale_eroder.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 """Grid-based simulation of lateral erosion by channels in a drainage network.
 
 Benjamin Campforts
 """
 
 import numpy as np
 
-from landlab import Component, RasterModelGrid
+from landlab import Component
+from landlab import RasterModelGrid
 from landlab.grid.nodestatus import NodeStatus
 from landlab.utils.return_array import return_array_at_node
 
 from ..depression_finder.lake_mapper import _FLOODED
 from .ext.calc_sequential_ero_depo import _sequential_ero_depo
 
 ROOT2 = np.sqrt(2.0)  # syntactic sugar for precalculated square root of 2
@@ -458,15 +459,14 @@
     def sediment_influx(self):
         """Volumetric sediment influx to each node."""
         return self.grid.at_node["sediment__influx"]
 
     def _calc_erosion_rates(self):
         """Calculate erosion rates."""
 
-        br = self.grid.at_node["bedrock__elevation"]
         H = self.grid.at_node["soil__depth"]
 
         # if sp_crits are zero, then this colapses to correct all the time.
         if np.isclose(self._n_sp, 1.0):
             S_to_the_n = self._slope
         else:
             S_to_the_n = np.power(self._slope, self._n_sp)
@@ -492,20 +492,14 @@
         ) / (
             1 - self._phi
         )  # convert from a volume to a mass flux.
         self._br_erosion_term = omega_br - self._sp_crit_br * (
             1.0 - np.exp(-omega_br_over_sp_crit)
         )
 
-        # Do not allow for the formation of potholes (addition v2)
-        r = self._grid.at_node["flow__receiver_node"]
-        br_e_max = br - br[r]
-        br_e_max[br_e_max < 0] = 0
-        self._br_erosion_term = np.minimum(self._br_erosion_term, br_e_max)
-
         self._Es = self._sed_erosion_term * (1.0 - np.exp(-H / self._H_star))
         self._Er = self._br_erosion_term * np.exp(-H / self._H_star)
 
         # if the soil layer becomes exceptionally thick (e.g. because of
         # landslide derived sediment deposition(,) the algorithm will become
         # unstable because np.exp(x) with x > 709 yeilds inf values.
         # Therefore soil depth is temporqlly topped of at 200m and the remaining
```

### Comparing `landlab-2.7.0/landlab/components/spatial_precip/generate_spatial_precip.py` & `landlab-2.8.0/landlab/components/spatial_precip/generate_spatial_precip.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,15 @@
 import contextlib
 
 import numpy as np
-from scipy.stats import fisk, genextreme
+from scipy.stats import fisk
+from scipy.stats import genextreme
 
-from landlab import Component, RasterModelGrid
+from landlab import Component
+from landlab import RasterModelGrid
 
 
 class SpatialPrecipitationDistribution(Component):
     """Generate spatially resolved precipitation events.
 
     A component to generate a sequence of spatially resolved storms over a
     grid, following a lightly modified version (see below) of the
@@ -1381,17 +1383,17 @@
                     # only need to add the bit that got rained on, so:
                     self._temp_dataslots2[:entries] *= duration_val / 60.0
                     seas_cum_Ptot_gauge[mask_name] += self._temp_dataslots2[:entries]
                     # collect storm totals for all gauges into rows by storm
                     Storm_total_local_seas[storm, :] = (
                         self._rain_int_gauge[opennodes] * duration_val / 60.0
                     )
-                    Storm_total_local_year[
-                        (storm + storms_yr_so_far), :
-                    ] = Storm_total_local_seas[storm, :]
+                    Storm_total_local_year[(storm + storms_yr_so_far), :] = (
+                        Storm_total_local_seas[storm, :]
+                    )
                     self._max_storm_depth = Storm_total_local_seas[storm, :].max()
 
                     self._Storm_total_local_seas = Storm_total_local_seas
                     self._Storm_total_local_year = Storm_total_local_year
                     Storm_running_sum_seas[1, :] = Storm_total_local_seas[storm, :]
                     np.nansum(
                         Storm_running_sum_seas, axis=0, out=Storm_running_sum_seas[0, :]
@@ -1418,17 +1420,17 @@
                         # Don't create Ptotal_local per MS... just
                         breaker = False
                         break
                     if storm + 1 == self._max_numstorms:
                         raise ValueError("_max_numstorms set too low for this run")
                 storms_yr_so_far = seas_storm_count
                 self._storm_running_sum_of_seasons += Storm_running_sum_seas[0, :]
-                self._total_rainfall_last_season[
-                    self._opennodes
-                ] = Storm_running_sum_seas[0, :]
+                self._total_rainfall_last_season[self._opennodes] = (
+                    Storm_running_sum_seas[0, :]
+                )
                 self._storm_running_sum_1st_seas += Storm_running_sum_seas[0, :]
                 if yield_seasons:
                     yield seas_storm_count
 
             self._total_rf_year[opennodes] = self._storm_running_sum_of_seasons
             if yield_years is True and yield_seasons is False:
                 yield year_storm_count
@@ -1589,17 +1591,17 @@
         """
         return self._total_rf_year
 
     @property
     def total_rainfall_this_season(self):
         """Get the accumulated, spatially resolved total rainfall over the grid
         for the season so far (mm)."""
-        self._running_total_rainfall_this_season[
-            self._opennodes
-        ] = self._Storm_running_sum_seas
+        self._running_total_rainfall_this_season[self._opennodes] = (
+            self._Storm_running_sum_seas
+        )
         return self._running_total_rainfall_this_season
 
     @property
     def total_rainfall_this_year(self):
         """Get the accumulated, spatially resolved total rainfall over the grid
         for the year so far (mm)."""
         self._running_total_rainfall_this_year[self._opennodes] = (
```

### Comparing `landlab-2.7.0/landlab/components/species_evolution/README.md` & `landlab-2.8.0/landlab/components/species_evolution/README.md`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/species_evolution/base_taxon.py` & `landlab-2.8.0/landlab/components/species_evolution/base_taxon.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 #!/usr/bin/env python
 """Base Taxon of SpeciesEvolver."""
-from abc import ABC, abstractmethod
+from abc import ABC
+from abc import abstractmethod
 
 
 class Taxon(ABC):
     """Base Taxon of SpeciesEvolver.
 
     A SpeciesEvolver Taxon represents a group of organisms. Examples of groups
     represented by this object include an analogue group (e.g., seed plants in
```

### Comparing `landlab-2.7.0/landlab/components/species_evolution/record.py` & `landlab-2.8.0/landlab/components/species_evolution/record.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/species_evolution/species_evolver.py` & `landlab-2.8.0/landlab/components/species_evolution/species_evolver.py`

 * *Files 2% similar despite different names*

```diff
@@ -79,17 +79,17 @@
 
     Create a model grid with mountain scale resolution. The elevation is
     equally low throughout the grid at model onset.
 
     >>> mg = RasterModelGrid((3, 7), 1000)
     >>> z = mg.add_ones("topographic__elevation", at="node")
     >>> z.reshape(mg.shape)
-    array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.],
-           [ 1.,  1.,  1.,  1.,  1.,  1.,  1.],
-           [ 1.,  1.,  1.,  1.,  1.,  1.,  1.]])
+    array([[1., 1., 1., 1., 1., 1., 1.],
+           [1., 1., 1., 1., 1., 1., 1.],
+           [1., 1., 1., 1., 1., 1., 1.]])
 
     Instantiate the component with the grid as the first parameter.
 
     >>> se = SpeciesEvolver(mg)
 
     ZoneController requires a function that returns a mask of the total extent
     of taxa habitat. The mask is a boolean array where `True` values represent
@@ -118,15 +118,15 @@
     node is below 100. The ``zones`` attribute of ``ZoneController`` returns a
     list of the zones that currently exist in the model. Below we return the
     mask of the single zone by indexing this list.
 
     >>> zc.zones[0].mask
     array([ True,  True,  True,  True,  True,  True,  True,  True,  True,
             True,  True,  True,  True,  True,  True,  True,  True,  True,
-            True,  True,  True], dtype=bool)
+            True,  True,  True])
 
     Populate a taxon to the zone.
 
     >>> taxon = zc.populate_zones_uniformly(1)
     >>> se.track_taxa(taxon)
 
     The attribute, ``taxa_data_frame`` indicates only the one taxon exists
@@ -146,17 +146,17 @@
 
     Force a change in the zone mask to demonstrate component functionality.
     Here we begin a new time step where topography is uplifted by 200 that
     forms a ridge trending north-south in the center of the grid.
 
     >>> z[[3, 10, 17]] = 200
     >>> z.reshape(mg.shape)
-    array([[   1.,    1.,    1.,  200.,    1.,    1.,    1.],
-           [   1.,    1.,    1.,  200.,    1.,    1.,    1.],
-           [   1.,    1.,    1.,  200.,    1.,    1.,    1.]])
+    array([[  1.,   1.,   1., 200.,   1.,   1.,   1.],
+           [  1.,   1.,   1., 200.,   1.,   1.,   1.],
+           [  1.,   1.,   1., 200.,   1.,   1.,   1.]])
 
     The current elevation, the elevation following uplift, is represented here.
     ::
 
         - - - ^ - - -       elevation:  - 1
         - - - ^ - - -                   ^ 200
         - - - ^ - - -
```

### Comparing `landlab-2.7.0/landlab/components/species_evolution/zone.py` & `landlab-2.8.0/landlab/components/species_evolution/zone.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 #!/usr/bin/env python
 """Zone functions and class of SpeciesEvolver."""
 from collections import OrderedDict
-from enum import IntEnum, unique
+from enum import IntEnum
+from enum import unique
 
 import numpy as np
 from pandas import Series
 
 
 @unique
 class Connection(IntEnum):
```

### Comparing `landlab-2.7.0/landlab/components/species_evolution/zone_controller.py` & `landlab-2.8.0/landlab/components/species_evolution/zone_controller.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 #!/usr/bin/env python
 """ZoneController of SpeciesEvolver."""
 import numpy as np
 from scipy.ndimage.measurements import label
 
 from .record import Record
-from .zone import Zone, _update_zones
+from .zone import Zone
+from .zone import _update_zones
 from .zone_taxon import ZoneTaxon
 
 
 class ZoneController:
     """Controls zones and populates them with taxa.
 
     This object manages 'zones' that are used to evaluate the spatial aspect of
```

### Comparing `landlab-2.7.0/landlab/components/species_evolution/zone_taxon.py` & `landlab-2.8.0/landlab/components/species_evolution/zone_taxon.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/steepness_index/channel_steepness.py` & `landlab-2.8.0/landlab/components/steepness_index/channel_steepness.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,12 @@
 """Created on Mon Oct 19.
 
 @author: dejh
 """
 
-
 import numpy as np
 
 from landlab import Component
 
 
 class SteepnessFinder(Component):
     """This component calculates steepness indices, sensu Wobus et al. 2006,
@@ -37,34 +36,34 @@
     >>> for i in range(10):
     ...     mg.at_node["topographic__elevation"][mg.core_nodes] += 10.0
     ...     _ = fr.run_one_step()
     ...     sp.run_one_step(1000.0)
     ...
     >>> sf.calculate_steepnesses()
     >>> mg.at_node["channel__steepness_index"].reshape((3, 10))[1, :]
-    array([  0.        ,  29.28427125,   1.        ,   1.        ,
-             1.        ,   1.        ,   1.        ,   1.        ,
-             0.99999997,   0.        ])
+    array([ 0.        , 29.28427125,  1.        ,  1.        ,
+            1.        ,  1.        ,  1.        ,  1.        ,
+            0.99999997,  0.        ])
     >>> sf.hillslope_mask
     array([ True,  True,  True,  True,  True,  True,  True,  True,  True,
             True, False, False, False, False, False, False, False, False,
            False,  True,  True,  True,  True,  True,  True,  True,  True,
-            True,  True,  True], dtype=bool)
+            True,  True,  True])
 
     >>> sf = SteepnessFinder(mg, min_drainage_area=10000.0, discretization_length=350.0)
     >>> sf.calculate_steepnesses()
     >>> mg.at_node["channel__steepness_index"].reshape((3, 10))[1, :]
-    array([ 0.        ,  3.08232295,  3.08232295,  3.08232295,  1.        ,
-            1.        ,  1.        ,  1.        ,  0.        ,  0.        ])
+    array([0.        , 3.08232295, 3.08232295, 3.08232295, 1.        ,
+           1.        , 1.        , 1.        , 0.        , 0.        ])
 
     >>> sf = SteepnessFinder(mg, min_drainage_area=10000.0, elev_step=1.5)
     >>> sf.calculate_steepnesses()
     >>> mg.at_node["channel__steepness_index"].reshape((3, 10))[1, :]
-    array([ 0.        ,  1.22673541,  1.2593727 ,  1.27781936,  1.25659369,
-            1.12393156,  0.97335328,  0.79473963,  0.56196578,  0.        ])
+    array([0.        , 1.22673541, 1.2593727 , 1.27781936, 1.25659369,
+           1.12393156, 0.97335328, 0.79473963, 0.56196578, 0.        ])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     None Listed
 
@@ -373,23 +372,23 @@
         >>> fr = FlowAccumulator(mg, flow_director="D8")
         >>> sf = SteepnessFinder(mg)
         >>> _ = fr.run_one_step()
         >>> ch_nodes = np.arange(18, 9, -1)
         >>> ch_dists = sf.channel_distances_downstream(ch_nodes)
         >>> interp_pt_elevs = np.array([0.0, 30.0, 60.0, 90.0, 120.0])
         >>> sf.interpolate_slopes_with_step(ch_nodes, ch_dists, interp_pt_elevs)
-        array([ 1.67970205,  1.67970205,  1.67970205,  1.65129294,  1.62115336,
-        1.5811951 ,  1.53157521,  1.44240187,  1.36442227])
+        array([1.67970205, 1.67970205, 1.67970205, 1.65129294, 1.62115336,
+               1.5811951 , 1.53157521, 1.44240187, 1.36442227])
         >>> mg.at_node["topographic__steepest_slope"][ch_nodes]
-        array([ 1.69383001,  1.66972677,  1.64200694,  1.60928598,  1.56915472,
-        1.51678178,  1.43964028,  1.25892541,  0.        ])
+        array([1.69383001, 1.66972677, 1.64200694, 1.60928598, 1.56915472,
+               1.51678178, 1.43964028, 1.25892541, 0.        ])
         >>> mg.at_node["topographic__elevation"][:] = mg.node_x
         >>> interp_pt_elevs = np.array([0.0, 25.0, 50.0, 75.0, 80.0])
         >>> sf.interpolate_slopes_with_step(ch_nodes, ch_dists, interp_pt_elevs)
-        array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
+        array([1., 1., 1., 1., 1., 1., 1., 1., 1.])
         """
         ch_z = self._grid.at_node["topographic__elevation"][ch_nodes]
         assert (
             ch_z[0] >= interp_pt_elevs[-1]
         ), "Highest interp_pt_elev must be below top channel node"
         interp_pt_x = np.interp(interp_pt_elevs, ch_z[::-1], ch_dists[::-1])
         interp_pt_S = np.empty_like(interp_pt_elevs)
@@ -459,21 +458,21 @@
         >>> ch_A = mg.at_node["drainage_area"][ch_nodes]
         >>> ch_S = mg.at_node["topographic__steepest_slope"][ch_nodes]
 
         >>> ksn_25 = sf.calc_ksn_discretized(ch_dists, ch_A, ch_S, 0.5, 25.0)
         >>> ksn_25.size == ch_dists.size - 1
         True
         >>> ksn_25
-        array([ -1.        ,  11.0668192 ,  11.0668192 ,  15.70417802,
-                15.70417802,  15.70417802,  19.3433642 ,  19.3433642 ])
+        array([-1.        , 11.0668192 , 11.0668192 , 15.70417802,
+               15.70417802, 15.70417802, 19.3433642 , 19.3433642 ])
 
         >>> ksn_10 = sf.calc_ksn_discretized(ch_dists, ch_A, ch_S, 0.5, 10.0)
         >>> ksn_10
-        array([  8.40896415,   8.40896415,  13.16074013,  13.16074013,
-                16.5487546 ,  16.5487546 ,  19.3433642 ,  19.3433642 ])
+        array([ 8.40896415,  8.40896415, 13.16074013, 13.16074013,
+               16.5487546 , 16.5487546 , 19.3433642 , 19.3433642 ])
 
         >>> ch_ksn_overdiscretized = sf.calc_ksn_discretized(
         ...     ch_dists, ch_A, ch_S, 0.5, 10.0
         ... )
         >>> np.allclose(ch_ksn_overdiscretized, ksn_10)
         True
         """
```

### Comparing `landlab-2.7.0/landlab/components/stream_power/cfuncs.pyx` & `landlab-2.8.0/landlab/components/stream_power/cfuncs.pyx`

 * *Files 3% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 import numpy as np
 
-cimport cython
 cimport numpy as np
 
 from scipy.optimize import newton
 
 # suspect that the function _brentq is in c and thus this is the most effective
 # method for using the brentq method in cython.
 from scipy.optimize._zeros import _brentq as brentq
 
-#from libc.math cimport fabs
+# from libc.math cimport fabs
 
 
 DTYPE_FLOAT = np.double
 ctypedef np.double_t DTYPE_FLOAT_t
 
 DTYPE_INT = int
 ctypedef np.int_t DTYPE_INT_t
 
 
 cdef extern from "math.h":
     double fabs(double x) nogil
     double pow(double x, double y) nogil
 
 
-def brent_method_erode_variable_threshold(np.ndarray[DTYPE_INT_t, ndim=1] src_nodes,
-                                          np.ndarray[DTYPE_INT_t, ndim=1] dst_nodes,
-                                          np.ndarray[DTYPE_FLOAT_t, ndim=1] threshsxdt,
-                                          np.ndarray[DTYPE_FLOAT_t, ndim=1] alpha,
-                                          DTYPE_FLOAT_t n,
-                                          np.ndarray[DTYPE_FLOAT_t, ndim=1] z):
+def brent_method_erode_variable_threshold(
+    np.ndarray[DTYPE_INT_t, ndim=1] src_nodes,
+    np.ndarray[DTYPE_INT_t, ndim=1] dst_nodes,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] threshsxdt,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] alpha,
+    DTYPE_FLOAT_t n,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] z,
+):
     """Erode node elevations using Brent's method for stability.
 
     The alpha value is given as
 
     alpha = delta_t*K * (A)**m/(delta_x**n)
 
     It will be multiplied by the value:
@@ -62,15 +63,14 @@
     cdef unsigned int src_id
     cdef unsigned int dst_id
     cdef unsigned int i
     cdef double z_old
     cdef double z_downstream
     cdef double thresholddt
     cdef double z_diff_old
-    cdef double z_diff
     cdef double alpha_param
     cdef double beta_param
     cdef double check_function
     cdef double x
 
     # Loop through nodes.
     for i in range(n_nodes):
@@ -121,21 +121,25 @@
 
                 # if n is 1, finding x has an analytical solution. Otherwise,
                 # use the the numerical solution given by root finding
                 if n != 1.0:
 
                     # The threshold values passed here are the defaults if one
                     # were to import brentq from scipy.optimize
-                    x = brentq(erode_fn,
-                                       0.0, 1.0,
-                                       1e-12,4.4408920985006262e-16,
-                                       100,
-                                       (alpha_param, beta_param, n),
-                                       False,
-                                       True)
+                    x = brentq(
+                        erode_fn,
+                        0.0,
+                        1.0,
+                        1e-12,
+                        4.4408920985006262e-16,
+                        100,
+                        (alpha_param, beta_param, n),
+                        False,
+                        True,
+                    )
 
                 else:
                     # Analytical solution
                     x = (1.0 + beta_param)/(1.0 + alpha_param)
 
                 # If x is provided as a value greater than zero, calculate
                 # z at t=t+delta_t useing the values of x, z_downstream and
@@ -147,27 +151,30 @@
                 else:
                     z[src_id] = z_downstream + 1.0e-15
 
                 # Nothing is returned from this function as it serves to update
                 # the array z.
 
 
-def brent_method_erode_fixed_threshold(np.ndarray[DTYPE_INT_t, ndim=1] src_nodes,
-                                       np.ndarray[DTYPE_INT_t, ndim=1] dst_nodes,
-                                       DTYPE_FLOAT_t threshsxdt,
-                                       np.ndarray[DTYPE_FLOAT_t, ndim=1] alpha,
-                                       DTYPE_FLOAT_t n,
-                                       np.ndarray[DTYPE_FLOAT_t, ndim=1] z):
+def brent_method_erode_fixed_threshold(
+    np.ndarray[DTYPE_INT_t, ndim=1] src_nodes,
+    np.ndarray[DTYPE_INT_t, ndim=1] dst_nodes,
+    DTYPE_FLOAT_t threshsxdt,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] alpha,
+    DTYPE_FLOAT_t n,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] z,
+):
     """Erode node elevations.
 
-    The alpha value is given as
+    The alpha value is given as::
 
-    alpha = delta_t*K * (A)**m/(delta_x**n)
+        alpha = delta_t*K * (A)**m/(delta_x**n)
+
+    It will be multiplied by the value::
 
-    It will be multiplied by the value:
         (z_node(t) - z_downstream(t+delta_t))**(n-1)
 
     to become the alpha value defined below in the function used in erode_fun
     used in the root-finding operation.
 
     Parameters
     ----------
@@ -188,15 +195,14 @@
     cdef unsigned int n_nodes = src_nodes.shape[0]
     cdef unsigned int src_id
     cdef unsigned int dst_id
     cdef unsigned int i
     cdef double z_old
     cdef double z_downstream
     cdef double z_diff_old
-    cdef double z_diff
     cdef double alpha_param
     cdef double beta_param
     cdef double check_function
     cdef double x
 
     # Loop through nodes.
     for i in range(n_nodes):
@@ -247,21 +253,25 @@
 
                 # if n is 1, finding x has an analytical solution. Otherwise,
                 # use the the numerical solution given by root finding
                 if n != 1.0:
 
                     # The threshold values passed here are the defaults if one
                     # were to import brentq from scipy.optimize
-                    x = brentq(erode_fn,
-                                       0.0, 1.0,
-                                       1e-12,4.4408920985006262e-16,
-                                       100,
-                                       (alpha_param, beta_param, n),
-                                       False,
-                                       True)
+                    x = brentq(
+                        erode_fn,
+                        0.0,
+                        1.0,
+                        1e-12,
+                        4.4408920985006262e-16,
+                        100,
+                        (alpha_param, beta_param, n),
+                        False,
+                        True,
+                    )
 
                 else:
                     # Analytical solution
                     x = (1.0 + beta_param)/(1.0 + alpha_param)
 
                 # If x is provided as a value greater than zero, calculate
                 # z at t=t+delta_t useing the values of x, z_downstream and
@@ -273,18 +283,20 @@
                 else:
                     z[src_id] = z_downstream + 1.0e-15
 
                 # Nothing is returned from this function as it serves to update
                 # the array z.
 
 
-def erode_fn(DTYPE_FLOAT_t x,
-             DTYPE_FLOAT_t alpha,
-             DTYPE_FLOAT_t beta,
-             DTYPE_FLOAT_t n):
+def erode_fn(
+    DTYPE_FLOAT_t x,
+    DTYPE_FLOAT_t alpha,
+    DTYPE_FLOAT_t beta,
+    DTYPE_FLOAT_t n,
+):
     """Evaluates the solution to the water-depth equation.
 
     Called by scipy.brentq() to find solution for $x$ using Brent's method.
 
     Parameters
     ----------
     x : float
@@ -303,38 +315,43 @@
 
     This equation represents the implicit solution for normalized topographic
     elevation $x$ at the  next time step. This solution is inspired by the
     Appendix of Braun and Willet (2012) but was generalized to include an a
     threshold value such that if the threshold is not exceeded, no erosion will
     occur.
 
-    Consider stream power erosion under the equation:
+    Consider stream power erosion under the equation::
 
         E = K * (A)**m * S**n - threshold_sp,
 
     on a grid with link delta_x and for a timestep of delta_t.
 
     When iterating from downstream to upstream in the drainage stack, at a
     given node at time = t+delta_t, the value of the node at time = t, and the
     value of the downstream node at time t+delta_t is known.
 
-    Define
-    x = (z_node(t+delta_t) - z_downstream(t+delta_t))/(z_node(t) - z_downstream(t+delta_t)).
+    Define::
+
+        x = (
+            z_node(t + delta_t) - z_downstream(t + delta_t)
+        ) / (z_node(t) - z_downstream(t + delta_t))
 
-    A discretized version of the stream power equation above yeilds the equation
+    A discretized version of the stream power equation above yeilds the equation::
 
-    f = x - 1 + alpha*(x**n) - beta
+        f = x - 1 + alpha*(x**n) - beta
 
-    where
+    where::
 
-    alpha = delta_t*K * (A)**m/(delta_x**n) * (z_node(t) - z_downstream(t+delta_t))**(n-1)
+        alpha = delta_t * K * A ** m / (delta_x ** n) * (
+            z_node(t) - z_downstream(t + delta_t)
+        ) ** (n - 1)
 
-    and
+    and::
 
-    beta = threshold_sp*delta_t/(z_node(t) - z_downstream(t+delta_t))
+        beta = threshold_sp * delta_t / (z_node(t) - z_downstream(t + delta_t))
 
     Finding the root of f provides the implicit solution for the stream power
     equation.
 
     If f(x=1) = 0, then no erosion occurs as potential erosion is cancelled by
     the erosion threshold and the topography at the given node does not change.
 
@@ -359,20 +376,22 @@
     cdef double f
 
     f = x - 1.0 + (alpha * pow(x, n)) - beta
 
     return f
 
 
-def smooth_stream_power_eroder_solver(np.ndarray[DTYPE_INT_t, ndim=1] src_nodes,
-                                      np.ndarray[DTYPE_INT_t, ndim=1] dst_nodes,
-                                      np.ndarray[DTYPE_FLOAT_t, ndim=1] z,
-                                      np.ndarray[DTYPE_FLOAT_t, ndim=1] alpha,
-                                      np.ndarray[DTYPE_FLOAT_t, ndim=1] gamma,
-                                      np.ndarray[DTYPE_FLOAT_t, ndim=1] delta):
+def smooth_stream_power_eroder_solver(
+    np.ndarray[DTYPE_INT_t, ndim=1] src_nodes,
+    np.ndarray[DTYPE_INT_t, ndim=1] dst_nodes,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] z,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] alpha,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] gamma,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] delta,
+):
     """Erode node elevations using Newtons Method for smoothed Stream Power. "
 
     This method takes three parameters, alpha, gamma, and delta.
 
     alpha = K A^m dt / L
 
     delta = K A^m / (L * wc)
@@ -392,49 +411,50 @@
     gamma : array_like
         Erosion equation parameter.
     delta : array_like
         Erosion equation parameter.
     z : array_like
         Node elevations.
     """
-    cdef unsigned int n_nodes = src_nodes.shape[0]
     cdef unsigned int src_id
     cdef unsigned int dst_id
     cdef unsigned int i
 
-    cdef double epilon
-
-
-
     for i in range(len(src_nodes)):
         src_id = src_nodes[i]
         dst_id = dst_nodes[src_id]
 
         if src_id != dst_id and z[src_id] > z[dst_id]:
 
             # calculate epsilon
-            epsilon = (alpha[src_id] * z[dst_id]
-                       + gamma[src_id] + z[src_id])
+            epsilon = (alpha[src_id] * z[dst_id] + gamma[src_id] + z[src_id])
 
             # calculate new z
-            z[src_id] = newton(new_elev, z[src_id],
-                             fprime=new_elev_prime,
-                             args=(alpha[src_id],
-                                   z[dst_id],
-                                   gamma[src_id],
-                                   delta[src_id],
-                                   epsilon))
-
-
-def new_elev(DTYPE_FLOAT_t x,
-             DTYPE_FLOAT_t a,
-             DTYPE_FLOAT_t b,
-             DTYPE_FLOAT_t c,
-             DTYPE_FLOAT_t d,
-             DTYPE_FLOAT_t e):
+            z[src_id] = newton(
+                new_elev,
+                z[src_id],
+                fprime=new_elev_prime,
+                args=(
+                    alpha[src_id],
+                    z[dst_id],
+                    gamma[src_id],
+                    delta[src_id],
+                    epsilon,
+                )
+            )
+
+
+def new_elev(
+    DTYPE_FLOAT_t x,
+    DTYPE_FLOAT_t a,
+    DTYPE_FLOAT_t b,
+    DTYPE_FLOAT_t c,
+    DTYPE_FLOAT_t d,
+    DTYPE_FLOAT_t e,
+):
     """Equation for elevation of a node at timestep t+1.
 
     Parameters
     ----------
     x : float
         Value of new elevation
     a : float
@@ -451,20 +471,22 @@
     cdef double f
 
     f = x * (1.0 + a) + c * np.exp(-d * (x - b)) - e
 
     return f
 
 
-def new_elev_prime(DTYPE_FLOAT_t x,
-                   DTYPE_FLOAT_t a,
-                   DTYPE_FLOAT_t b,
-                   DTYPE_FLOAT_t c,
-                   DTYPE_FLOAT_t d,
-                   DTYPE_FLOAT_t e):
+def new_elev_prime(
+    DTYPE_FLOAT_t x,
+    DTYPE_FLOAT_t a,
+    DTYPE_FLOAT_t b,
+    DTYPE_FLOAT_t c,
+    DTYPE_FLOAT_t d,
+    DTYPE_FLOAT_t e,
+):
     """Equation for elevation of a node at timestep t+1.
 
     Parameters
     ----------
     x : float
         Value of new elevation
     a : float
```

### Comparing `landlab-2.7.0/landlab/components/stream_power/fastscape_stream_power.py` & `landlab-2.8.0/landlab/components/stream_power/fastscape_stream_power.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,22 +4,21 @@
 # This module attempts to "component-ify" GT's Fastscape stream
 # power erosion.
 # Created DEJH, March 2014.
 
 
 import numpy as np
 
-from landlab import Component, RasterModelGrid
+from landlab import Component
+from landlab import RasterModelGrid
 from landlab.utils.return_array import return_array_at_node
 
 from ..depression_finder.lake_mapper import _FLOODED
-from .cfuncs import (
-    brent_method_erode_fixed_threshold,
-    brent_method_erode_variable_threshold,
-)
+from .cfuncs import brent_method_erode_fixed_threshold
+from .cfuncs import brent_method_erode_variable_threshold
 
 
 class FastscapeEroder(Component):
     r"""Fastscape stream power erosion.
 
     This class uses the Braun-Willett Fastscape approach to calculate the
     amount of erosion at each node in a grid, following a stream power
@@ -75,61 +74,61 @@
     ... ]
     >>> z = grid.add_field("topographic__elevation", z, at="node")
     >>> fr = FlowAccumulator(grid, flow_director="D8")
     >>> sp = FastscapeEroder(grid, K_sp=1.0)
     >>> fr.run_one_step()
     >>> sp.run_one_step(dt=1.0)
     >>> z
-    array([ 7.        ,  7.        ,  7.        ,  7.        ,  7.        ,
-            7.        ,  2.92996598,  2.02996598,  4.01498299,  7.        ,
-            7.        ,  0.85993197,  1.87743897,  3.28268321,  7.        ,
-            7.        ,  0.28989795,  0.85403051,  2.42701526,  7.        ,
-            7.        ,  0.        ,  7.        ,  7.        ,  7.        ])
+    array([7.        , 7.        , 7.        , 7.        , 7.        ,
+           7.        , 2.92996598, 2.02996598, 4.01498299, 7.        ,
+           7.        , 0.85993197, 1.87743897, 3.28268321, 7.        ,
+           7.        , 0.28989795, 0.85403051, 2.42701526, 7.        ,
+           7.        , 0.        , 7.        , 7.        , 7.        ])
 
     >>> grid = RasterModelGrid((3, 7), xy_spacing=1.0)
     >>> z = np.array(grid.node_x**2.0)
     >>> z = grid.add_field("topographic__elevation", z, at="node")
     >>> grid.status_at_node[grid.nodes_at_left_edge] = grid.BC_NODE_IS_FIXED_VALUE
     >>> grid.status_at_node[grid.nodes_at_top_edge] = grid.BC_NODE_IS_CLOSED
     >>> grid.status_at_node[grid.nodes_at_bottom_edge] = grid.BC_NODE_IS_CLOSED
     >>> grid.status_at_node[grid.nodes_at_right_edge] = grid.BC_NODE_IS_CLOSED
     >>> fr = FlowAccumulator(grid, flow_director="D8")
     >>> sp = FastscapeEroder(grid, K_sp=0.1, m_sp=0.0, n_sp=2.0, threshold_sp=2.0)
     >>> fr.run_one_step()
     >>> sp.run_one_step(dt=10.0)
     >>> z.reshape(grid.shape)[1, :]
-    array([  0.        ,   1.        ,   4.        ,   8.52493781,
-            13.29039716,  18.44367965,  36.        ])
+    array([ 0.        ,  1.        ,  4.        ,  8.52493781,
+           13.29039716, 18.44367965, 36.        ])
 
     >>> grid = RasterModelGrid((3, 7), xy_spacing=1.0)
     >>> z = np.array(grid.node_x**2.0)
     >>> z = grid.add_field("topographic__elevation", z, at="node")
     >>> grid.status_at_node[grid.nodes_at_left_edge] = grid.BC_NODE_IS_FIXED_VALUE
     >>> grid.status_at_node[grid.nodes_at_top_edge] = grid.BC_NODE_IS_CLOSED
     >>> grid.status_at_node[grid.nodes_at_bottom_edge] = grid.BC_NODE_IS_CLOSED
     >>> grid.status_at_node[grid.nodes_at_right_edge] = grid.BC_NODE_IS_CLOSED
     >>> cell_area = 1.0
     >>> fr = FlowAccumulator(grid, flow_director="D8", runoff_rate=2.0)
     >>> grid.at_node["water__unit_flux_in"]
-    array([ 2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.,
-            2.,  2.,  2.,  2.,  2.,  2.,  2.,  2.])
+    array([2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2.,
+           2., 2., 2., 2., 2., 2., 2., 2.])
     >>> K_field = grid.ones(at="node")  # K can be a field
     >>> sp = FastscapeEroder(
     ...     grid,
     ...     K_sp=K_field,
     ...     m_sp=1.0,
     ...     n_sp=0.6,
     ...     threshold_sp=grid.node_x,
     ...     discharge_field="surface_water__discharge",
     ... )
     >>> fr.run_one_step()
     >>> sp.run_one_step(1.0)
     >>> z.reshape(grid.shape)[1, :]
-    array([  0.        ,   0.0647484 ,   0.58634455,   2.67253503,
-             8.49212152,  20.92606987,  36.        ])
+    array([ 0.        ,  0.0647484 ,  0.58634455,  2.67253503,
+            8.49212152, 20.92606987, 36.        ])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     None Listed
```

### Comparing `landlab-2.7.0/landlab/components/stream_power/sed_flux_dep_incision.py` & `landlab-2.8.0/landlab/components/stream_power/sed_flux_dep_incision.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 import warnings
 
 import numpy as np
 import scipy.constants
 
-from landlab import Component, MissingKeyError
+from landlab import Component
+from landlab import MissingKeyError
 from landlab.utils.decorators import make_return_array_immutable
 
 
 class SedDepEroder(Component):
     """
     This module implements sediment flux dependent channel incision
     following::
@@ -1106,17 +1107,17 @@
         ...     Dchar=None,
         ...     set_threshold_from_Dchar=False,
         ...     set_Dchar_from_threshold=True,
         ...     threshold_Shields=thresh_shields,
         ...     g=9.81,
         ... )
         >>> sde1.characteristic_grainsize.reshape(mg1.shape)
-        array([[ 0.59962823,  0.29981412,  0.19987608,  0.14990706],
-               [ 0.11992565,  0.09993804,  0.08566118,  0.07495353],
-               [ 0.06662536,  0.05996282,  0.05451166,  0.04996902]])
+        array([[0.59962823, 0.29981412, 0.19987608, 0.14990706],
+               [0.11992565, 0.09993804, 0.08566118, 0.07495353],
+               [0.06662536, 0.05996282, 0.05451166, 0.04996902]])
 
         >>> mg2 = RasterModelGrid((3, 4))
         >>> z2 = mg2.add_zeros("node", "topographic__elevation")
         >>> fa2 = FlowAccumulator(mg2)
         >>> sde2 = SedDepEroder(
         ...     mg2,
         ...     threshold_shear_stress=100.0,
@@ -1127,17 +1128,17 @@
         ...     threshold_Shields=None,
         ...     slope_sensitive_threshold=True,
         ...     g=9.81,
         ... )
         >>> S = mg2.at_node["topographic__steepest_slope"]
         >>> S[:] = 0.05  # thresh = 100 Pa @ 5pc slope
         >>> sde2.characteristic_grainsize.reshape(mg2.shape)
-        array([[ 0.08453729,  0.08453729,  0.08453729,  0.08453729],
-               [ 0.08453729,  0.08453729,  0.08453729,  0.08453729],
-               [ 0.08453729,  0.08453729,  0.08453729,  0.08453729]])
+        array([[0.08453729, 0.08453729, 0.08453729, 0.08453729],
+               [0.08453729, 0.08453729, 0.08453729, 0.08453729],
+               [0.08453729, 0.08453729, 0.08453729, 0.08453729]])
         """
         # Dchar is None means self._lamb_flag, Dchar is spatially variable,
         # and not calculated until the main loop
         assert (
             self._Qc == "MPM"
         ), "Characteristic grainsize is only calculated if Qc == 'MPM'"
         if self._Dchar_in is not None:
```

### Comparing `landlab-2.7.0/landlab/components/stream_power/stream_power.py` & `landlab-2.8.0/landlab/components/stream_power/stream_power.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,17 +1,16 @@
 import numpy as np
 
-from landlab import Component, MissingKeyError
+from landlab import Component
+from landlab import MissingKeyError
 from landlab.utils.return_array import return_array_at_node
 
 from ..depression_finder.lake_mapper import _FLOODED
-from .cfuncs import (
-    brent_method_erode_fixed_threshold,
-    brent_method_erode_variable_threshold,
-)
+from .cfuncs import brent_method_erode_fixed_threshold
+from .cfuncs import brent_method_erode_variable_threshold
 
 
 class StreamPowerEroder(Component):
     """Erode where channels are.
 
     Implemented as:
 
@@ -54,34 +53,34 @@
     ... )
     >>> z = mg.add_field("topographic__elevation", z, at="node")
     >>> fr = FlowAccumulator(mg, flow_director="D8")
     >>> sp = StreamPowerEroder(mg, K_sp=1.0)
     >>> fr.run_one_step()
     >>> sp.run_one_step(dt=1.0)
     >>> z
-    array([ 7.        ,  7.        ,  7.        ,  7.        ,  7.        ,
-            7.        ,  2.92996598,  2.02996598,  4.01498299,  7.        ,
-            7.        ,  0.85993197,  1.87743897,  3.28268321,  7.        ,
-            7.        ,  0.28989795,  0.85403051,  2.42701526,  7.        ,
-            7.        ,  0.        ,  7.        ,  7.        ,  7.        ])
+    array([7.        , 7.        , 7.        , 7.        , 7.        ,
+           7.        , 2.92996598, 2.02996598, 4.01498299, 7.        ,
+           7.        , 0.85993197, 1.87743897, 3.28268321, 7.        ,
+           7.        , 0.28989795, 0.85403051, 2.42701526, 7.        ,
+           7.        , 0.        , 7.        , 7.        , 7.        ])
 
     >>> mg2 = RasterModelGrid((3, 7))
     >>> z = np.array(mg2.node_x**2.0)
     >>> z = mg2.add_field("topographic__elevation", z, at="node")
     >>> mg2.status_at_node[mg2.nodes_at_left_edge] = mg2.BC_NODE_IS_FIXED_VALUE
     >>> mg2.status_at_node[mg2.nodes_at_top_edge] = mg2.BC_NODE_IS_CLOSED
     >>> mg2.status_at_node[mg2.nodes_at_bottom_edge] = mg2.BC_NODE_IS_CLOSED
     >>> mg2.status_at_node[mg2.nodes_at_right_edge] = mg2.BC_NODE_IS_CLOSED
     >>> fr2 = FlowAccumulator(mg2, flow_director="D8")
     >>> sp2 = StreamPowerEroder(mg2, K_sp=0.1, m_sp=0.0, n_sp=2.0, threshold_sp=2.0)
     >>> fr2.run_one_step()
     >>> sp2.run_one_step(dt=10.0)
     >>> z.reshape((3, 7))[1, :]
-    array([  0.        ,   1.        ,   4.        ,   8.52493781,
-            13.29039716,  18.44367965,  36.        ])
+    array([ 0.        ,  1.        ,  4.        ,  8.52493781,
+           13.29039716, 18.44367965, 36.        ])
 
     >>> mg3 = RasterModelGrid((5, 5), xy_spacing=2.0)
     >>> z = mg.node_x / 100.0
     >>> z = mg3.add_field("topographic__elevation", z, at="node")
     >>> mg3.status_at_node[mg3.nodes_at_left_edge] = mg3.BC_NODE_IS_FIXED_VALUE
     >>> mg3.status_at_node[mg3.nodes_at_top_edge] = mg3.BC_NODE_IS_CLOSED
     >>> mg3.status_at_node[mg3.nodes_at_bottom_edge] = mg3.BC_NODE_IS_CLOSED
@@ -96,19 +95,19 @@
     ...     b_sp=0.5,
     ...     c_sp=1.0,
     ...     discharge_field="surface_water__discharge",
     ... )
     >>> fr3.run_one_step()
     >>> sp3.run_one_step(1.0)
     >>> z
-    array([ 0.        ,  0.1       ,  0.2       ,  0.3       ,  0.4       ,
-            0.        ,  0.02898979,  0.0859932 ,  0.17463772,  0.4       ,
-            0.        ,  0.02240092,  0.06879049,  0.14586033,  0.4       ,
-            0.        ,  0.01907436,  0.05960337,  0.12929386,  0.4       ,
-            0.        ,  0.1       ,  0.2       ,  0.3       ,  0.4       ])
+    array([0.        , 0.1       , 0.2       , 0.3       , 0.4       ,
+           0.        , 0.02898979, 0.0859932 , 0.17463772, 0.4       ,
+           0.        , 0.02240092, 0.06879049, 0.14586033, 0.4       ,
+           0.        , 0.01907436, 0.05960337, 0.12929386, 0.4       ,
+           0.        , 0.1       , 0.2       , 0.3       , 0.4       ])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     None Listed
```

### Comparing `landlab-2.7.0/landlab/components/stream_power/stream_power_smooth_threshold.py` & `landlab-2.8.0/landlab/components/stream_power/stream_power_smooth_threshold.py`

 * *Files 7% similar despite different names*

```diff
@@ -64,24 +64,24 @@
     >>> from landlab.components import StreamPowerSmoothThresholdEroder
     >>> sp = StreamPowerSmoothThresholdEroder(rg, K_sp=1.0)
     >>> sp.thresholds
     1.0
     >>> sp.run_one_step(dt=1.0)
     >>> import numpy as np
     >>> np.round(z[5:7], 3)
-    array([ 1.646,  0.667])
+    array([1.646, 0.667])
     >>> z[5] = 2.0
     >>> z[6] = 1.0
     >>> import numpy as np
     >>> q = np.zeros(rg.number_of_nodes) + 0.25
     >>> q[6] = 100.0
     >>> sp = StreamPowerSmoothThresholdEroder(rg, K_sp=1.0, discharge_field=q)
     >>> sp.run_one_step(dt=1.0)
     >>> np.round(z[5:7], 3)
-    array([ 1.754,  0.164])
+    array([1.754, 0.164])
 
     References
     ----------
     **Required Software Citation(s) Specific to this Component**
 
     Barnhart, K., Glade, R., Shobe, C., Tucker, G. (2019). Terrainbento 1.0: a
     Python package for multi-model analysis in long-term drainage basin
@@ -264,19 +264,19 @@
         >>> from landlab.components import FlowAccumulator
         >>> fr = FlowAccumulator(rg, flow_director="D4")
         >>> fr.run_one_step()
         >>> from landlab.components import StreamPowerSmoothThresholdEroder
         >>> sp = StreamPowerSmoothThresholdEroder(rg, K_sp=1.0)
         >>> sp.run_one_step(dt=1.0)
         >>> sp.alpha
-        array([ 0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.])
+        array([0., 0., 0., 0., 1., 0., 0., 0., 0.])
         >>> sp.gamma
-        array([ 0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.])
+        array([0., 0., 0., 0., 1., 0., 0., 0., 0.])
         >>> sp.delta
-        array([ 0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.])
+        array([0., 0., 0., 0., 1., 0., 0., 0., 0.])
         """
         if not self._erode_flooded_nodes:
             flood_status = self._grid.at_node["flood_status_code"]
             flooded_nodes = np.nonzero(flood_status == _FLOODED)[0]
         else:
             flooded_nodes = []
```

### Comparing `landlab-2.7.0/landlab/components/taylor_nonlinear_hillslope_flux/taylor_nonlinear_hillslope_flux.py` & `landlab-2.8.0/landlab/components/taylor_nonlinear_hillslope_flux/taylor_nonlinear_hillslope_flux.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,19 +5,19 @@
 @author: G Tucker
 """
 
 # Cubic hillslope flux component
 
 import numpy as np
 
-from landlab import Component, LinkStatus
+from landlab import Component
+from landlab import LinkStatus
 
 
 class TaylorNonLinearDiffuser(Component):
-
     """Hillslope evolution using a Taylor Series expansion of the Andrews-
     Bucknam formulation of nonlinear hillslope flux derived following following
     Ganti et al., 2012. The flux is given as::
 
         qs = KS * (1 + (S / Sc)**2 + (S / Sc)**4 + ... + (S / Sc)**2(n - 1))
 
     where *K* is is the diffusivity, *S* is the slope, *Sc* is the critical slope, and
```

### Comparing `landlab-2.7.0/landlab/components/tectonics/listric_kinematic_extender.py` & `landlab-2.8.0/landlab/components/tectonics/listric_kinematic_extender.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,17 @@
 See notebook tutorial for theory and examples.
 
 @author: gtucker
 """
 
 import numpy as np
 
-from landlab import Component, HexModelGrid, RasterModelGrid
+from landlab import Component
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.components import AdvectionSolverTVD
 
 
 def dist_to_line(Px, Py, x0, y0, alpha):
     """Calculate and return the distance of point(x) (Px, Py) to the
     line described by x = x0 + t cos alpha, y = y0 + t sin alpha.
```

### Comparing `landlab-2.7.0/landlab/components/threshold_eroder/cfuncs.pyx` & `landlab-2.8.0/landlab/components/threshold_eroder/cfuncs.pyx`

 * *Files 14% similar despite different names*

```diff
@@ -1,32 +1,34 @@
 import numpy as np
 
-cimport cython
 cimport numpy as np
 
 DTYPE_INT = int
 ctypedef np.int_t DTYPE_INT_t
 
 DTYPE_FLOAT = np.float64
 ctypedef np.float64_t DTYPE_FLOAT_t
 
 
-cpdef _thresholder(np.ndarray[DTYPE_INT_t, ndim=1] stack,
-             np.ndarray[DTYPE_INT_t, ndim=1] link_to_rcvr,
-             np.ndarray[DTYPE_INT_t, ndim=1] receivers,
-             np.ndarray[DTYPE_FLOAT_t, ndim=1] linkLengths,
-             np.ndarray[DTYPE_FLOAT_t, ndim=1] el,
-             DTYPE_FLOAT_t slope_thres):
-
+cpdef _thresholder(
+    np.ndarray[DTYPE_INT_t, ndim=1] stack,
+    np.ndarray[DTYPE_INT_t, ndim=1] link_to_rcvr,
+    np.ndarray[DTYPE_INT_t, ndim=1] receivers,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] linkLengths,
+    np.ndarray[DTYPE_FLOAT_t, ndim=1] el,
+    DTYPE_FLOAT_t slope_thres,
+):
     """
     Calcualte D8 flow dirs
     stack: the flow upstream node order
     link_to_rcvr: Link to receiver
     receivers: receivers
     linkLengths: length of links
     el: topographic elevation
     """
     cdef int node
 
     for node in stack:
         dist_to_rcvr = linkLengths[link_to_rcvr[node]]
-        el[node]  = np.minimum(el[node],el[receivers[node]] + slope_thres*dist_to_rcvr)
+        el[node] = np.minimum(
+            el[node], el[receivers[node]] + slope_thres * dist_to_rcvr
+        )
```

### Comparing `landlab-2.7.0/landlab/components/threshold_eroder/threshold_eroder.py` & `landlab-2.8.0/landlab/components/threshold_eroder/threshold_eroder.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 #!/usr/bin/env python3
 """Created on Wed Aug  4 11:00:08 2021.
 
 @author: benjamincampforts
 """
-from landlab import Component, RasterModelGrid
+from landlab import Component
+from landlab import RasterModelGrid
 
 from .cfuncs import _thresholder
 
 
 class ThresholdEroder(Component):
-
     """Threshold eroder.
 
     Threshold eroder that cuts off slopes at a given threshold slope (Sc) and
     assumes material to dissolve away
 
     .. math::
```

### Comparing `landlab-2.7.0/landlab/components/tidal_flow/tidal_flow_calculator.py` & `landlab-2.8.0/landlab/components/tidal_flow/tidal_flow_calculator.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,17 @@
 """
 Calculate cycle-averaged tidal flow field using approach of Mariotti (2018)
 """
 
 import numpy as np
 from scipy.sparse.linalg import spsolve
 
-from landlab import Component, HexModelGrid, RasterModelGrid
+from landlab import Component
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.grid.mappers import map_min_of_link_nodes_to_link
 from landlab.utils import get_core_node_matrix
 from landlab.utils.return_array import return_array_at_link
 
 _FOUR_THIRDS = 4.0 / 3.0
 _M2_PERIOD = (12.0 + (25.2 / 60.0)) * 3600.0  # M2 tidal period, in seconds
 
@@ -240,18 +242,17 @@
         >>> grid = RasterModelGrid((3, 5))
         >>> z = grid.add_zeros("topographic__elevation", at="node")
         >>> z[5:10] = [10.0, 0.25, 0.0, -0.25, -10.0]
         >>> period = 4.0e4  # tidal period in s, for convenient calculation
         >>> tfc = TidalFlowCalculator(grid, tidal_period=period)
         >>> rate = tfc.calc_tidal_inundation_rate()
         >>> 0.5 * rate[5:10] * period  # depth in m
-        array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
+        array([0.  , 0.25, 0.5 , 0.75, 1.  ])
         >>> rate[5:10]  # rate in m/s
-        array([  0.00000000e+00,   1.25000000e-05,   2.50000000e-05,
-                  3.75000000e-05,   5.00000000e-05])
+        array([0.00e+00, 1.25e-05, 2.50e-05, 3.75e-05, 5.00e-05])
 
         Notes
         -----
         This calculates I in Mariotti (2018) using his equation (1).
         """
         return (
             self._tidal_half_range
@@ -271,15 +272,15 @@
         --------
         >>> grid = RasterModelGrid((3, 5))
         >>> z = grid.add_zeros("topographic__elevation", at="node")
         >>> z[6:9] = [1.0, 2.0, -2.0]
         >>> tfc = TidalFlowCalculator(grid, tidal_range=3.1, min_water_depth=0.02)
         >>> tfc._calc_effective_water_depth()
         >>> tfc._water_depth[6:9]
-        array([ 0.275,  0.02 ,  2.   ])
+        array([0.275, 0.02 , 2.   ])
         """
         high_tide_depth = (self.mean_sea_level + self._tidal_half_range) - self._elev
         low_tide_depth = np.maximum(
             (self.mean_sea_level - self._tidal_half_range) - self._elev, 0.0
         )
         self._water_depth[:] = (high_tide_depth + low_tide_depth) / 2.0
         self._water_depth[self._water_depth <= self._min_depth] = self._min_depth
```

### Comparing `landlab-2.7.0/landlab/components/transport_length_diffusion/transport_length_hillslope_diffusion.py` & `landlab-2.8.0/landlab/components/transport_length_diffusion/transport_length_hillslope_diffusion.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/uniform_precip/generate_uniform_precip.py` & `landlab-2.8.0/landlab/components/uniform_precip/generate_uniform_precip.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,24 +6,23 @@
 
 No particular units must be used, but it was written with the storm units in
 hours (hr) and depth units in millimeters (mm)
 
 Written by Jordan Adams, 2013, updated May 2016
 """
 
-
 import random
 
 import numpy as np
 
-from landlab import Component, ModelGrid
+from landlab import Component
+from landlab import ModelGrid
 
 
 class PrecipitationDistribution(Component):
-
     """Generate precipitation events.
 
     This component can generate a random storm duration, interstorm
     duration, precipitation intensity or storm depth from a Poisson
     distribution when given a mean value.
 
     Examples
@@ -646,15 +645,15 @@
         """Generate and return a random variable from a stretched exponential
         distribution with given scale and shape.
 
         Examples
         --------
         >>> np.random.seed(0)
         >>> np.round(np.random.rand(3), 6)  # these are our 3 rand #s to test
-        array([ 0.548814,  0.715189,  0.602763])
+        array([0.548814, 0.715189, 0.602763])
         >>> from landlab.components import PrecipitationDistribution
         >>> pd = PrecipitationDistribution(
         ...     mean_storm_duration=1.0,
         ...     mean_interstorm_duration=1.0,
         ...     mean_storm_depth=1.0,
         ... )
         >>> np.random.seed(0)  # re-set seed so we get the same 3 #s
```

### Comparing `landlab-2.7.0/landlab/components/vegetation_dynamics/vegetation_dynamics.py` & `landlab-2.8.0/landlab/components/vegetation_dynamics/vegetation_dynamics.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/components/weathering/exponential_weathering.py` & `landlab-2.8.0/landlab/components/weathering/exponential_weathering.py`

 * *Files 0% similar despite different names*

```diff
@@ -6,15 +6,14 @@
 
 import numpy as np
 
 from landlab import Component
 
 
 class ExponentialWeatherer(Component):
-
     """Calculate exponential weathering of bedrock on hillslopes.
 
     Uses exponential soil production function in the style of Ahnert (1976).
 
     Consider that ``w0`` is the maximum soil production rate and
     that ``w_star`` is the characteristic soil production depth. The
     soil production rate ``w0`` is given as a function of the soil
```

### Comparing `landlab-2.7.0/landlab/components/weathering/exponential_weathering_integrated.py` & `landlab-2.8.0/landlab/components/weathering/exponential_weathering_integrated.py`

 * *Files 0% similar despite different names*

```diff
@@ -8,15 +8,14 @@
 
 import numpy as np
 
 from landlab import Component
 
 
 class ExponentialWeathererIntegrated(Component):
-
     """
     This component implements exponential weathering of bedrock on
     hillslopes. Uses exponential soil production function in the style
     of Ahnert (1976).
 
     Consider that ``w_0`` is the maximum soil production rate and
     that ``d_start`` is the characteristic soil production depth. The
```

### Comparing `landlab-2.7.0/landlab/core/errors.py` & `landlab-2.8.0/landlab/core/errors.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,31 +1,28 @@
 class Error(Exception):
-
     """Base class for exceptions raised from this module."""
 
     pass
 
 
 class MissingKeyError(Error):
-
     """Error to indicate a missing parameter key.
 
     Raise this error if the parameter dictionary file does not contain a
     requested *key*.
     """
 
     def __init__(self, key):
         self._key = key
 
     def __str__(self):
         return self._key
 
 
 class ParameterValueError(Error):
-
     """Error to indicate a bad parameter values.
 
     Raise this error if a parameter value given by *key* is not of the
     expected type.
     """
 
     def __init__(self, key, val, expected_type):
```

### Comparing `landlab-2.7.0/landlab/core/messages.py` & `landlab-2.8.0/landlab/core/messages.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/core/model_component.py` & `landlab-2.8.0/landlab/core/model_component.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/core/model_parameter_loader.py` & `landlab-2.8.0/landlab/core/model_parameter_loader.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/core/utils.py` & `landlab-2.8.0/landlab/core/utils.py`

 * *Files 3% similar despite different names*

```diff
@@ -21,30 +21,33 @@
 import errno
 import importlib
 import inspect
 import os
 import pathlib
 import re
 import shutil
+import sys
 
 import numpy as np
-import pkg_resources
+
+if sys.version_info >= (3, 12):  # pragma: no cover (PY12+)
+    import importlib.resources as importlib_resources
+else:  # pragma: no cover (<PY312)
+    import importlib_resources
 
 SIZEOF_INT = np.dtype(int).itemsize
 
 
 class ExampleData:
     def __init__(self, example, case=""):
         self._example = example
         self._case = case
 
         self._base = pathlib.Path(
-            pkg_resources.resource_filename(
-                "landlab", str(pathlib.Path("data").joinpath(example, case))
-            )
+            importlib_resources.files("landlab") / "data" / example / case
         )
 
     @property
     def base(self):
         return self._base
 
     def fetch(self):
@@ -151,15 +154,15 @@
     >>> radians_to_degrees(0.0)
     90.0
     >>> radians_to_degrees(np.pi / 2.0)
     0.0
     >>> radians_to_degrees(-3 * np.pi / 2.0)
     0.0
     >>> radians_to_degrees(np.array([-np.pi, np.pi]))
-    array([ 270.,  270.])
+    array([270., 270.])
     """
     degrees = (5.0 * np.pi / 2.0 - rads) % (2.0 * np.pi)
     return 180.0 / np.pi * degrees
 
 
 def as_id_array(array):
     """Convert an array to an array of ids.
@@ -640,23 +643,21 @@
         contains any problematic LLCAT entries. Keys: 'MISSING' - list of names
         of any public method or property without an LLCAT declared.
     """
     import inspect
     import re
     from copy import copy
 
-    from landlab import (
-        FramedVoronoiGrid,
-        HexModelGrid,
-        ModelGrid,
-        NetworkModelGrid,
-        RadialModelGrid,
-        RasterModelGrid,
-        VoronoiDelaunayGrid,
-    )
+    from landlab import FramedVoronoiGrid
+    from landlab import HexModelGrid
+    from landlab import ModelGrid
+    from landlab import NetworkModelGrid
+    from landlab import RadialModelGrid
+    from landlab import RasterModelGrid
+    from landlab import VoronoiDelaunayGrid
 
     grid_str_to_grid = {
         "ModelGrid": ModelGrid,
         "RasterModelGrid": RasterModelGrid,
         "HexModelGrid": HexModelGrid,
         "RadialModelGrid": RadialModelGrid,
         "VoronoiDelaunayGrid": VoronoiDelaunayGrid,
```

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin.dbf` & `landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin.dbf`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin.shp` & `landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin.shp`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin.shp.xml` & `landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin.shp.xml`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.dbf` & `landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.dbf`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.shp` & `landlab-2.8.0/landlab/data/io/shapefile/methow/MethowSubBasin_Nodes_4.shp`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/methow/Methow_Network.dbf` & `landlab-2.8.0/landlab/data/io/shapefile/methow/Methow_Network.dbf`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/methow/Methow_Network.shp` & `landlab-2.8.0/landlab/data/io/shapefile/methow/Methow_Network.shp`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/methow/Methow_Network.shx` & `landlab-2.8.0/landlab/data/io/shapefile/methow/Methow_Network.shx`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/redb/a001_network.dbf` & `landlab-2.8.0/landlab/data/io/shapefile/redb/a001_network.dbf`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/redb/a001_network.shp` & `landlab-2.8.0/landlab/data/io/shapefile/redb/a001_network.shp`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/redb/a001_network.shp.xml` & `landlab-2.8.0/landlab/data/io/shapefile/redb/a001_network.shp.xml`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/redb/a001_nodes_att.dbf` & `landlab-2.8.0/landlab/data/io/shapefile/redb/a001_nodes_att.dbf`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/redb/a001_nodes_att.shp.xml` & `landlab-2.8.0/landlab/data/io/shapefile/redb/a001_nodes_att.shp.xml`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Links.dbf` & `landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Links.dbf`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Links.qmd` & `landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Links.qmd`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Links.shp` & `landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Links.shp`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Links.shx` & `landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Links.shx`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Nodes.dbf` & `landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Nodes.dbf`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Nodes.qmd` & `landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Nodes.qmd`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Nodes.shp` & `landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Nodes.shp`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data/io/shapefile/soque/Soque_Nodes.shx` & `landlab-2.8.0/landlab/data/io/shapefile/soque/Soque_Nodes.shx`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/data_record/data_record.py` & `landlab-2.8.0/landlab/data_record/data_record.py`

 * *Files 2% similar despite different names*

```diff
@@ -164,15 +164,15 @@
         ``xarray.Dataset``.
 
         >>> dr1.dataset.to_dataframe()
               mean_elevation
         time
         0.0              100
         >>> dr1.dataset.time.values
-        array([ 0.])
+        array([0.])
         >>> dr1.variable_names
         ['mean_elevation']
         >>> dr1.dataset["mean_elevation"].values
         array([100])
         >>> list(dr1.dataset.attrs.items())
         [('time_units', 'y')]
 
@@ -469,18 +469,18 @@
         ...     new_item_loc={
         ...         "grid_element": np.array([["node"]]),
         ...         "element_id": np.array([[6]]),
         ...     },
         ...     new_record={"item_size": (["item_id", "time"], np.array([[0.2]]))},
         ... )
         >>> dr3.dataset["element_id"].values
-        array([[  1.,   6.],
-               [  3.,  nan]])
+        array([[ 1.,  6.],
+               [ 3., nan]])
         >>> dr3.get_data([2.0], [0], "item_size")
-        array([ 0.2])
+        array([0.2])
 
         The 'add_record' method can also be used to add a non item-related
         record:
 
         >>> dr3.add_record(time=[50.0], new_record={"mean_elev": (["time"], [110])})
         >>> dr3.dataset["mean_elev"].to_dataframe()
               mean_elev
@@ -689,15 +689,15 @@
         [0.0, 1.0]
 
         If a data variable is also added with the new items ('size' in this
         example), the values for this variable are filled with 'nan' for the
         pre-existing items:
 
         >>> dr3.dataset["size"][:, 1].values
-        array([ nan,  nan,  10.,   5.])
+        array([nan, nan, 10.,  5.])
 
         The previous line calls the values of the variable 'size', for all
         items, at time=1; the first two items don't have a value for the
         variable 'size'.
         """
         if time is None and "time" in self._dataset["grid_element"].coords:
             raise ValueError(
@@ -830,15 +830,15 @@
         ...         np.array([[0.3], [0.4], [0.8], [0.4]]),
         ...     )
         ... }
         >>> dr4 = DataRecord(grid, time=[50.0], items=my_items4, data_vars=my_data4)
         >>> dr4.get_data([50.0], [2], "element_id")
         array([3])
         >>> dr4.get_data(time=[50.0], data_variable="item_size")
-        array([  0.3,  0.4,  0.8,  0.4])
+        array([0.3, 0.4, 0.8, 0.4])
         >>> dr4.get_data(item_id=[1, 2], data_variable="grid_element")
         array([['node'],
                ['node']], dtype=object)
         """
         try:
             self._dataset[data_variable]
         except KeyError as exc:
@@ -947,24 +947,24 @@
         ...     "item_size": (
         ...         ["item_id", "time"],
         ...         np.array([[0.3], [0.4], [0.8], [0.4]]),
         ...     )
         ... }
         >>> dr4 = DataRecord(grid, time=[50.0], items=my_items4, data_vars=my_data4)
         >>> dr4.dataset["item_size"].values
-        array([[ 0.3],
-               [ 0.4],
-               [ 0.8],
-               [ 0.4]])
+        array([[0.3],
+               [0.4],
+               [0.8],
+               [0.4]])
         >>> dr4.set_data([50.0], [2], "item_size", [0.5])
         >>> dr4.dataset["item_size"].values
-        array([[ 0.3],
-               [ 0.4],
-               [ 0.5],
-               [ 0.4]])
+        array([[0.3],
+               [0.4],
+               [0.5],
+               [0.4]])
         """
         if data_variable not in self.variable_names:
             raise KeyError(
                 "the variable '{}' is not in the " "DataRecord".format(data_variable)
             )
 
         # If record to be changed is 'grid_element' or 'element_id',
@@ -1085,15 +1085,15 @@
         ...     data_vars={
         ...         "ages": (["item_id"], np.array(ages)),
         ...         "volumes": (["item_id"], np.array(volumes)),
         ...     },
         ... )
         >>> s = dr.calc_aggregate_value(func=xr.Dataset.sum, data_variable="ages")
         >>> s
-        array([ 46.,  14.,  15.,  16.,   8.,  10.,  nan,  nan,  nan])
+        array([46., 14., 15., 16.,  8., 10., nan, nan, nan])
         >>> len(s) == grid.number_of_nodes
         True
 
         If you want to first filter the DataRecord and then aggregate, first
         create a filter array with dimensions matching that of the DataRecord
         and has `True` for entries that should be retained and False for
         entries that should be ignored.
@@ -1102,50 +1102,50 @@
         greater than 10 we would to the following:
 
         >>> f = dr.dataset["ages"] > 10.0
         >>> v_f = dr.calc_aggregate_value(
         ...     func=xr.Dataset.sum, data_variable="volumes", filter_array=f
         ... )
         >>> v_f
-        array([  8.,   3.,   4.,   5.,  nan,  nan,  nan,  nan,  nan])
+        array([ 8.,  3.,  4.,  5., nan, nan, nan, nan, nan])
 
         If we wanted the value for elements with no volume to be zero instead
         of np.nan we could use the keyword argument ``fill_value``.
 
         >>> f = dr.dataset["ages"] > 10.0
         >>> v_f = dr.calc_aggregate_value(
         ...     func=xr.Dataset.sum,
         ...     data_variable="volumes",
         ...     filter_array=f,
         ...     fill_value=0.0,
         ... )
         >>> v_f
-        array([  8.,   3.,   4.,   5.,  0.,  0.,  0.,  0.,  0.])
+        array([8., 3., 4., 5., 0., 0., 0., 0., 0.])
 
         An array of ``fill_value`` is returned when ``filter_array`` is all
         ``False`` (np.nan is the default value).
 
         >>> f = dr.dataset["ages"] > 4000.0
         >>> v_f = dr.calc_aggregate_value(
         ...     func=xr.Dataset.sum, data_variable="volumes", filter_array=f
         ... )
         >>> v_f
-        array([  nan,   nan,   nan,   nan,  nan,  nan,  nan,  nan,  nan])
+        array([nan, nan, nan, nan, nan, nan, nan, nan, nan])
 
         Other values can be specified for ``fill_value``.
 
         >>> f = dr.dataset["ages"] > 4000.0
         >>> v_f = dr.calc_aggregate_value(
         ...     func=xr.Dataset.sum,
         ...     data_variable="volumes",
         ...     filter_array=f,
         ...     fill_value=0.0,
         ... )
         >>> v_f
-        array([  0.,   0.,   0.,   0.,  0.,  0.,  0.,  0.,  0.])
+        array([0., 0., 0., 0., 0., 0., 0., 0., 0.])
         """
         filter_at = self._dataset["grid_element"] == at
 
         filter_valid_element = (self._dataset["element_id"] >= 0) * (
             self._dataset["element_id"] < self._grid[at].size
         )
 
@@ -1210,27 +1210,27 @@
         grid_element and element_id of the items has been filled with 'nan'
         for these time coordinates.
 
         >>> dr3.dataset["grid_element"].values
         array([['node', nan, nan],
                ['link', nan, nan]], dtype=object)
         >>> dr3.dataset["element_id"].values
-        array([[  1.,  nan,  nan],
-               [  3.,  nan,  nan]])
+        array([[ 1., nan, nan],
+               [ 3., nan, nan]])
 
         To fill these values with the last valid value, use the method
         ffill_grid_element_and_id:
 
         >>> dr3.ffill_grid_element_and_id()
         >>> dr3.dataset["grid_element"].values
         array([['node', 'node', 'node'],
                ['link', 'link', 'link']], dtype=object)
         >>> dr3.dataset["element_id"].values
-        array([[ 1.,  1.,  1.],
-               [ 3.,  3.,  3.]])
+        array([[1., 1., 1.],
+               [3., 3., 3.]])
 
         In some applications, there may be no prior valid value. Under these
         circumstances, those values will stay as NaN. That is, this only
         forward fills, and does not backfill.
 
         >>> my_items3 = {
         ...     "grid_element": np.array([["node"], ["link"]]),
@@ -1258,62 +1258,62 @@
         Two items have been added at a new timestep 1.0:
 
         >>> dr3.number_of_items
         4
         >>> dr3.time_coordinates
         [0.0, 1.0]
         >>> dr3.dataset["element_id"].values
-        array([[  1.,  nan],
-               [  3.,  nan],
-               [ nan,   4.],
-               [ nan,   4.]])
+        array([[ 1., nan],
+               [ 3., nan],
+               [nan,  4.],
+               [nan,  4.]])
         >>> dr3.dataset["grid_element"].values
         array([['node', nan],
                ['link', nan],
                [nan, 'node'],
                [nan, 'node']], dtype=object)
 
         We expect that the NaN's to the left of the 4.s will stay NaN. And they
         do.
 
         >>> dr3.ffill_grid_element_and_id()
         >>> dr3.dataset["element_id"].values
-        array([[  1.,   1.],
-               [  3.,   3.],
-               [ nan,   4.],
-               [ nan,   4.]])
+        array([[ 1.,  1.],
+               [ 3.,  3.],
+               [nan,  4.],
+               [nan,  4.]])
         >>> dr3.dataset["grid_element"].values
         array([['node', 'node'],
                ['link', 'link'],
                [nan, 'node'],
                [nan, 'node']], dtype=object)
 
         Finally, if we add a new time, we see that we need to fill in the
         full time column.
 
         >>> dr3.add_record(time=[2])
         >>> dr3.dataset["element_id"].values
-        array([[  1.,   1.,  nan],
-               [  3.,   3.,  nan],
-               [ nan,   4.,  nan],
-               [ nan,   4.,  nan]])
+        array([[ 1.,  1., nan],
+               [ 3.,  3., nan],
+               [nan,  4., nan],
+               [nan,  4., nan]])
         >>> dr3.dataset["grid_element"].values
         array([['node', 'node', nan],
                ['link', 'link', nan],
                [nan, 'node', nan],
                [nan, 'node', nan]], dtype=object)
 
         And that forward filling fills everything as expected.
 
         >>> dr3.ffill_grid_element_and_id()
         >>> dr3.dataset["element_id"].values
-        array([[  1.,   1.,   1.],
-               [  3.,   3.,   3.],
-               [ nan,   4.,   4.],
-               [ nan,   4.,   4.]])
+        array([[ 1.,  1.,  1.],
+               [ 3.,  3.,  3.],
+               [nan,  4.,  4.],
+               [nan,  4.,  4.]])
 
         >>> dr3.dataset["grid_element"].values
         array([['node', 'node', 'node'],
                ['link', 'link', 'link'],
                [nan, 'node', 'node'],
                [nan, 'node', 'node']], dtype=object)
         """
```

### Comparing `landlab-2.7.0/landlab/field/errors.py` & `landlab-2.8.0/landlab/field/errors.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,38 +1,34 @@
 class Error(Exception):
-
     """Base class for errors in this module."""
 
     pass
 
 
 class FieldError(Error, KeyError):
-
     """Raise this error for a missing field name."""
 
     def __init__(self, field):
         self._field = field
 
     def __str__(self):
         return self._field
 
 
 class GroupError(Error, KeyError):
-
     """Raise this error for a missing group name."""
 
     def __init__(self, group):
         self._group = group
 
     def __str__(self):
         return self._group
 
 
 class GroupSizeError(Error, KeyError):
-
     """Raise this error if a group has changed sizes."""
 
     def __init__(self, group, old_size, new_size):
         self._group = group
         self._old_size = old_size
         self._new_size = new_size
```

### Comparing `landlab-2.7.0/landlab/field/graph_field.py` & `landlab-2.8.0/landlab/field/graph_field.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 """Define collections of fields that are attached to a *Landlab*
 :class:`~landlab.graph.graph.Graph`.
 """
+
 import numpy as np
 import xarray as xr
 
-from .errors import FieldError, GroupError
+from .errors import FieldError
+from .errors import GroupError
 
 
 def reshape_for_storage(array, field_size=None):
     """Reshape an array to be stored as a field.
 
     For reshaping rules, see :func:`~.shape_for_storage`.
 
@@ -160,15 +162,15 @@
     >>> from landlab.field.graph_field import FieldDataset
 
     >>> ds = FieldDataset("node")
     >>> ds.size is None
     True
     >>> ds.set_value("air_temperature", [1.0, 1.0, 1.0, 1.0])
     >>> ds["air_temperature"]
-    array([ 1.,  1.,  1.,  1.])
+    array([1., 1., 1., 1.])
     >>> ds.size
     4
     >>> ds.set_value("air_temperature", [1.0, 1.0, 1.0])
     Traceback (most recent call last):
     ValueError: unable to reshape array to field size (3 != 4)
 
     >>> ds = FieldDataset("node", fixed_size=False)
@@ -177,15 +179,15 @@
     >>> ds.set_value("air_temperature", [1.0, 1.0, 1.0, 1.0])
     >>> ds.size
     4
     >>> ds.set_value("air_temperature", [0.0, 0.0])
     >>> ds.size
     2
     >>> ds["air_temperature"]
-    array([ 0.,  0.])
+    array([0., 0.])
     """
 
     def __init__(self, name, size=None, fixed_size=True):
         """Create a container to hold a collection of *Landlab* fields.
 
         Parameters
         ----------
@@ -215,15 +217,15 @@
         --------
         >>> from landlab.field.graph_field import FieldDataset
 
         >>> ds = FieldDataset("grid", size=1)
         >>> ds.set_value("air_temperature", [1.0, 1.0, 1.0])
         >>> ds.set_value("ground_temperature", [0.0, 0.0])
         >>> ds["ground_temperature"]
-        array([[ 0.,  0.]])
+        array([[0.,  0.]])
 
         >>> ds = FieldDataset("grid", size=1)
         >>> ds.set_value("air_temperature", 0.1)
         >>> ds["air_temperature"]
         array(0.1)
         """
         return self._size
@@ -249,30 +251,30 @@
         --------
         >>> from landlab.field.graph_field import FieldDataset
 
         >>> ds = FieldDataset("node", fixed_size=False)
         >>> ds.set_value("air_temperature", [1.0, 1.0, 1.0, 1.0])
         >>> ds.set_value("air_temperature", [0.0, 0.0])
         >>> ds["air_temperature"]
-        array([ 0.,  0.])
+        array([0.,  0.])
 
         >>> ds.fixed_size = True
         >>> ds.size
         2
         >>> ds.set_value("air_temperature", [1.0, 1.0, 1.0])
         Traceback (most recent call last):
         ValueError: unable to reshape array to field size (4 != 2)
         """
         return self._fixed_size
 
     @fixed_size.setter
     def fixed_size(self, fixed_size):
         self._fixed_size = bool(fixed_size)
         if self._fixed_size:
-            self.size = self._ds.dims[self._name]
+            self.size = self._ds.sizes[self._name]
 
     @property
     def units(self):
         """Return units for each of the fields of the dataset."""
         return self._units
 
     def set_units(self, name, new_units):
@@ -424,31 +426,31 @@
     >>> fields = GraphFields()
     >>> fields.new_field_location("node", 12)
     >>> fields.new_field_location("cell", 2)
 
     Create some new value arrays for each of the data fields.
 
     >>> fields.ones("node")
-    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
+    array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])
     >>> fields.zeros("cell")
-    array([ 0.,  0.])
+    array([0., 0.])
 
     Create new value arrays and add them to the data fields. Because the data
     fields are in different groups (node and cell), they can have the same
     name.
 
     >>> fields.add_ones("topographic__elevation", at="node")
-    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
+    array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])
     >>> fields.at_node["topographic__elevation"]
-    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
+    array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])
 
     >>> fields.add_ones("topographic__elevation", at="cell")
-    array([ 1.,  1.])
+    array([1., 1.])
     >>> fields.at_cell["topographic__elevation"]
-    array([ 1.,  1.])
+    array([1., 1.])
 
     Each group acts as a :class:`dict` so, for instance, to get the variables names
     in a group use the :meth:`keys` method,
 
     >>> list(fields.at_cell.keys())
     ['topographic__elevation']
 
@@ -459,15 +461,15 @@
     >>> fields = GraphFields()
     >>> fields.new_field_location("grid", None)
     >>> fields.at_grid["g"] = 9.81
     >>> fields.at_grid["g"]
     array(9.81)
     >>> fields.at_grid["w"] = (3.0, 4.0)
     >>> fields.at_grid["w"]
-    array([ 3.,  4.])
+    array([3., 4.])
 
     The dimensions of groups can also be specified when the object is
     instantiated. In this case, group sizes are specified as a dictionary
     with keys being group names and values group sizes.
 
     >>> fields = GraphFields({"node": 6, "grid": None})
     >>> fields.at_grid["g"] = 9.81
@@ -760,15 +762,15 @@
 
         Add a field, initialized to ones, called *topographic__elevation*
         to the *node* group. The *field_values* method returns a reference
         to the field's data.
 
         >>> _ = fields.add_ones("topographic__elevation", at="node")
         >>> fields.field_values("topographic__elevation", at="node")
-        array([ 1.,  1.,  1.,  1.])
+        array([1., 1., 1., 1.])
 
         Raise FieldError if *field* does not exist in *group*.
 
         >>> fields.field_values("planet_surface__temperature", at="node")
         Traceback (most recent call last):
         ...
         FieldError: planet_surface__temperature
@@ -844,22 +846,22 @@
 
         Add a field, initialized to ones, called *topographic__elevation*
         to the *node* group. The *field_values* method returns a reference
         to the field's data.
 
         >>> _ = fields.add_ones("topographic__elevation", at="node")
         >>> fields.field_values("topographic__elevation", at="node")
-        array([ 1.,  1.,  1.,  1.])
+        array([1., 1., 1., 1.])
 
         Alternatively, if the second argument is an array, its size is
         checked and returned if correct.
 
         >>> vals = np.array([4.0, 5.0, 7.0, 3.0])
         >>> fields.return_array_or_field_values(vals, at="node")
-        array([ 4.,  5.,  7.,  3.])
+        array([4., 5., 7., 3.])
 
         Raise FieldError if *field* does not exist in *group*.
 
         >>> fields.return_array_or_field_values("surface__temperature", at="node")
         Traceback (most recent call last):
         ...
         FieldError: surface__temperature
@@ -1014,15 +1016,15 @@
 
         Examples
         --------
         >>> from landlab.field import GraphFields
         >>> field = GraphFields()
         >>> field.new_field_location("node", 4)
         >>> field.ones("node")
-        array([ 1.,  1.,  1.,  1.])
+        array([1., 1., 1., 1.])
         >>> field.ones("node", dtype=int)
         array([1, 1, 1, 1])
 
         Note that a new field is *not* added to the collection of fields.
 
         >>> list(field.keys("node"))
         []
@@ -1054,15 +1056,15 @@
 
         Examples
         --------
         >>> from landlab.field import GraphFields
         >>> field = GraphFields()
         >>> field.new_field_location("node", 4)
         >>> field.zeros("node")
-        array([ 0.,  0.,  0.,  0.])
+        array([0., 0., 0., 0.])
 
         Note that a new field is *not* added to the collection of fields.
 
         >>> list(field.keys("node"))
         []
 
         :meta landlab: field-add
@@ -1305,21 +1307,21 @@
         --------
         Add a new, named field to a collection of fields.
 
         >>> from landlab.field import GraphFields
         >>> field = GraphFields()
         >>> field.new_field_location("node", 4)
         >>> field.add_ones("topographic__elevation", at="node")
-        array([ 1.,  1.,  1.,  1.])
+        array([1., 1., 1., 1.])
         >>> list(field.keys("node"))
         ['topographic__elevation']
         >>> field["node"]["topographic__elevation"]
-        array([ 1.,  1.,  1.,  1.])
+        array([1., 1., 1., 1.])
         >>> field.at_node["topographic__elevation"]
-        array([ 1.,  1.,  1.,  1.])
+        array([1., 1., 1., 1.])
 
         :meta landlab: field-add
         """
         data = self.add_empty(*args, **kwds)
         data.fill(1)
         return data
```

### Comparing `landlab-2.7.0/landlab/framework/component.py` & `landlab-2.8.0/landlab/framework/component.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/framework/decorators.py` & `landlab-2.8.0/landlab/framework/decorators.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/framework/interfaces.py` & `landlab-2.8.0/landlab/framework/interfaces.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/graph/dual.py` & `landlab-2.8.0/landlab/graph/dual.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """Define a graph of nodes-links-patches and its dual.
 
 This class should not be used directly. Instead, it should be used as a
 base class when defining other types of graphs.
 """
+
 import inspect
 from functools import cached_property
 
 import numpy as np
 
 from ..core.utils import as_id_array
 from .graph import Graph
```

### Comparing `landlab-2.7.0/landlab/graph/framed_voronoi/dual_framed_voronoi.py` & `landlab-2.8.0/landlab/graph/framed_voronoi/dual_framed_voronoi.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,15 +6,14 @@
 
 from ..dual import DualGraph
 from ..voronoi.dual_voronoi import DualVoronoiGraph
 from .framed_voronoi import FramedVoronoiGraph
 
 
 class DualFramedVoronoiGraph(DualGraph, FramedVoronoiGraph):
-
     """Graph of a unstructured grid of Voronoi Delaunay cells and
     irregular patches. It is a special type of VoronoiDelaunay graph in which
     the initial set of points is arranged in a fixed lattice (e.g. like a rectangular
     raster grid) named here "layout" and the core points are then moved aroung their
     initial position by a random distance, lower than a certain threshold.
 
     Examples
@@ -22,19 +21,19 @@
     >>> from landlab.graph import DualFramedVoronoiGraph
 
     >>> graph = DualFramedVoronoiGraph((3, 3), seed=200)
     >>> graph.number_of_nodes
     9
 
     >>> graph.x_of_node[2:4]
-    array([ 2.,  0.])
+    array([2., 0.])
     >>> graph.y_of_node[2:4]
-    array([ 0.   ,  0.749])
+    array([0.   , 0.749])
     >>> graph.y_of_node[5]
-    1.2509999999999999
+    1.251
     """
 
     def __init__(
         self,
         shape,
         xy_spacing=(1.0, 1.0),
         xy_of_lower_left=(0.0, 0.0),
```

### Comparing `landlab-2.7.0/landlab/graph/framed_voronoi/framed_voronoi.py` & `landlab-2.8.0/landlab/graph/framed_voronoi/framed_voronoi.py`

 * *Files 0% similar despite different names*

```diff
@@ -284,19 +284,19 @@
     >>> from landlab.graph import FramedVoronoiGraph
 
     >>> graph = FramedVoronoiGraph((3, 3), seed=200)
     >>> graph.number_of_nodes
     9
 
     >>> graph.x_of_node[2:4]
-    array([ 2.,  0.])
+    array([2., 0.])
     >>> graph.y_of_node[2:4]
-    array([ 0.   ,  0.749])
+    array([0.   , 0.749])
     >>> graph.y_of_node[5]
-    1.2509999999999999
+    1.251
 
     >>> graph.number_of_links
     16
     >>> graph.number_of_patches
     8
     """
```

### Comparing `landlab-2.7.0/landlab/graph/graph.py` & `landlab-2.8.0/landlab/graph/graph.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,17 +7,17 @@
 --------
 
 >>> from landlab.graph import NetworkGraph, Graph
 
 >>> node_x, node_y = [0, 0, 0, 1, 1, 1, 2, 2, 2], [0, 1, 2, 0, 1, 2, 0, 1, 2]
 >>> graph = NetworkGraph((node_y, node_x), sort=True)
 >>> graph.x_of_node
-array([ 0.,  1.,  2.,  0.,  1.,  2.,  0.,  1.,  2.])
+array([0., 1., 2., 0., 1., 2., 0., 1., 2.])
 >>> graph.y_of_node
-array([ 0.,  0.,  0.,  1.,  1.,  1.,  2.,  2.,  2.])
+array([0., 0., 0., 1., 1., 1., 2., 2., 2.])
 >>> graph.ndim
 2
 
 >>> links = [
 ...     (0, 1),
 ...     (1, 2),
 ...     (0, 3),
@@ -63,32 +63,34 @@
        [ 9, 11,  8,  6]])
 >>> graph.nodes_at_patch
 array([[4, 3, 0, 1],
        [5, 4, 1, 2],
        [7, 6, 3, 4],
        [8, 7, 4, 5]])
 """
+
 import json
 from functools import cached_property
 
 import numpy as np
 import xarray as xr
 
 from ..core.utils import as_id_array
 from ..utils.decorators import read_only_array
 from .object.at_node import get_links_at_node
 from .object.at_patch import get_nodes_at_patch
-from .quantity.of_link import (
-    get_angle_of_link,
-    get_length_of_link,
-    get_midpoint_of_link,
-)
-from .quantity.of_patch import get_area_of_patch, get_centroid_of_patch
+from .quantity.of_link import get_angle_of_link
+from .quantity.of_link import get_length_of_link
+from .quantity.of_link import get_midpoint_of_link
+from .quantity.of_patch import get_area_of_patch
+from .quantity.of_patch import get_centroid_of_patch
 from .sort import reindex_by_xy
-from .sort.sort import reorient_link_dirs, reverse_one_to_many, sort_spokes_at_hub
+from .sort.sort import reorient_link_dirs
+from .sort.sort import reverse_one_to_many
+from .sort.sort import sort_spokes_at_hub
 from .ugrid import ugrid_from_unstructured
 
 
 def find_perimeter_nodes(graph):
     """Find nodes on the perimeter of a graph.
 
     Uses a convex hull to locate the perimeter nodes of a graph.
@@ -309,17 +311,17 @@
 
         Examples
         --------
         >>> from landlab.graph import Graph
         >>> node_x, node_y = [0, 1, 2, 0, 1, 2], [0, 0, 0, 1, 1, 1]
         >>> graph = Graph((node_y, node_x))
         >>> graph.xy_of_node[:, 0]
-        array([ 0.,  1.,  2.,  0.,  1.,  2.])
+        array([0., 1., 2., 0., 1., 2.])
         >>> graph.xy_of_node[:, 1]
-        array([ 0.,  0.,  0.,  1.,  1.,  1.])
+        array([0., 0., 0., 1., 1., 1.])
 
         :meta landlab: info-node
         """
         return np.stack((self.x_of_node, self.y_of_node)).T.copy()
 
     @property
     def x_of_node(self):
@@ -327,15 +329,15 @@
 
         Examples
         --------
         >>> from landlab.graph import Graph
         >>> node_x, node_y = [0, 1, 2, 0, 1, 2], [0, 0, 0, 1, 1, 1]
         >>> graph = Graph((node_y, node_x))
         >>> graph.x_of_node
-        array([ 0.,  1.,  2.,  0.,  1.,  2.])
+        array([0., 1., 2., 0., 1., 2.])
 
         :meta landlab: info-node
         """
         return self.ds["x_of_node"].values
 
     @property
     def y_of_node(self):
@@ -343,15 +345,15 @@
 
         Examples
         --------
         >>> from landlab.graph import Graph
         >>> node_x, node_y = [0, 1, 2, 0, 1, 2], [0, 0, 0, 1, 1, 1]
         >>> graph = Graph((node_y, node_x))
         >>> graph.y_of_node
-        array([ 0.,  0.,  0.,  1.,  1.,  1.])
+        array([0., 0., 0., 1., 1., 1.])
 
         :meta landlab: info-node
         """
         return self.ds["y_of_node"].values
 
     @cached_property
     def node_x(self):
@@ -405,15 +407,15 @@
         >>> node_x, node_y = [0, 1, 2, 0, 1, 2], [0, 0, 0, 1, 1, 1]
         >>> graph = Graph((node_y, node_x))
         >>> graph.number_of_nodes == 6
         True
 
         :meta landlab: info-node
         """
-        return self.ds.dims["node"]
+        return self.ds.sizes["node"]
 
     @property
     def nodes_at_link(self):
         """Get nodes at either end of links.
 
         Examples
         --------
@@ -528,15 +530,15 @@
         ...     (7, 8),
         ... )
         >>> graph = Graph((node_y, node_x), links=links)
         >>> graph.number_of_links == 12
         True
         """
         try:
-            return self.ds.dims["link"]
+            return self.ds.sizes["link"]
         except KeyError:
             return 0
 
     @cached_property
     @read_only_array
     def links_at_node(self):
         """Get links touching a node.
@@ -639,15 +641,15 @@
         >>> import numpy as np
         >>> from landlab.graph import Graph
 
         >>> node_x, node_y = ([0, 1, 2, 0, 1, 2], [0, 0, 0, 1, 1, 1])
         >>> links = ((0, 1), (1, 2), (0, 3), (1, 4), (2, 5), (3, 4), (4, 5))
         >>> graph = Graph((node_y, node_x), links=links)
         >>> graph.angle_of_link * 180.0 / np.pi
-        array([  0.,   0.,  90.,  90.,  90.,   0.,   0.])
+        array([ 0.,  0., 90., 90., 90.,  0.,  0.])
 
         :meta landlab: info-link
         """
         return get_angle_of_link(self)
 
     @cached_property
     @read_only_array
@@ -657,15 +659,15 @@
         Examples
         --------
         >>> import numpy as np
         >>> from landlab.graph import UniformRectilinearGraph
 
         >>> graph = UniformRectilinearGraph((2, 3), spacing=(1, 2))
         >>> graph.length_of_link
-        array([ 2.,  2.,  1.,  1.,  1.,  2.,  2.])
+        array([2., 2., 1., 1., 1., 2., 2.])
 
         :meta landlab: info-link
         """
         return get_length_of_link(self)
 
     @cached_property
     @read_only_array
@@ -675,17 +677,17 @@
         Examples
         --------
         >>> import numpy as np
         >>> from landlab.graph import UniformRectilinearGraph
 
         >>> graph = UniformRectilinearGraph((2, 3), spacing=(1, 2))
         >>> graph.midpoint_of_link
-        array([[ 1. ,  0. ], [ 3. ,  0. ],
-               [ 0. ,  0.5], [ 2. ,  0.5], [ 4. ,  0.5],
-               [ 1. ,  1. ], [ 3. ,  1. ]])
+        array([[1. , 0. ], [3. , 0. ],
+               [0. , 0.5], [2. , 0.5], [4. , 0.5],
+               [1. , 1. ], [3. , 1. ]])
 
         :meta landlab: info-link
         """
         return get_midpoint_of_link(self)
 
     @cached_property
     @read_only_array
@@ -803,55 +805,54 @@
         >>> from landlab.graph import TriGraph
         >>> graph = TriGraph((3, 2), spacing=2.0, node_layout="hex", sort=True)
 
         >>> np.round(graph.unit_vector_at_link[:, 0], decimals=5)
         array([ 1. , -0.5,  0.5, -0.5,  0.5,  1. ,  1. ,  0.5, -0.5,  0.5, -0.5,
                 1. ])
         >>> np.round(graph.unit_vector_at_link[:, 1], decimals=5)
-        array([ 0.     ,  0.86603,  0.86603,  0.86603,  0.86603,  0.     ,
-                0.     ,  0.86603,  0.86603,  0.86603,  0.86603,  0.     ])
+        array([0.     , 0.86603, 0.86603, 0.86603, 0.86603, 0.     ,
+               0.     , 0.86603, 0.86603, 0.86603, 0.86603, 0.     ])
         """
         u = np.diff(self.xy_of_node[self.nodes_at_link], axis=1).reshape((-1, 2))
         return u / np.linalg.norm(u, axis=1).reshape((-1, 1))
 
     @cached_property
     @read_only_array
     def unit_vector_at_node(self):
         """Get a unit vector for each node.
 
         Examples
         --------
         >>> from landlab.graph import UniformRectilinearGraph
         >>> graph = UniformRectilinearGraph((3, 3))
         >>> graph.unit_vector_at_node
-        array([[ 1.,  1.],
-               [ 2.,  1.],
-               [ 1.,  1.],
-               [ 1.,  2.],
-               [ 2.,  2.],
-               [ 1.,  2.],
-               [ 1.,  1.],
-               [ 2.,  1.],
-               [ 1.,  1.]])
+        array([[1., 1.],
+               [2., 1.],
+               [1., 1.],
+               [1., 2.],
+               [2., 2.],
+               [1., 2.],
+               [1., 1.],
+               [2., 1.],
+               [1., 1.]])
 
         >>> from landlab.graph import TriGraph
         >>> graph = TriGraph((3, 2), spacing=2.0, node_layout="hex", sort=True)
 
         >>> unit_vector_at_node = np.round(graph.unit_vector_at_node, decimals=5)
         >>> unit_vector_at_node[:, 0]
-        array([ 2.,  2.,  2.,  4.,  2.,  2.,  2.])
+        array([2., 2., 2., 4., 2., 2., 2.])
         >>> unit_vector_at_node[:, 1]
-        array([ 1.73205,  1.73205,  1.73205,  3.4641 ,  1.73205,  1.73205,  1.73205])
+        array([1.73205, 1.73205, 1.73205, 3.4641 , 1.73205, 1.73205, 1.73205])
         """
         unit_vector_at_link = np.vstack((self.unit_vector_at_link, [0.0, 0.0]))
         return np.abs(unit_vector_at_link[self.links_at_node]).sum(axis=1)
 
 
 class Graph(NetworkGraph):
-
     """Define the connectivity of a graph of nodes, links, and patches."""
 
     def __init__(self, node_y_and_x, links=None, patches=None, sort=False):
         if patches is not None and len(patches) == 0:
             patches = None
         self._ds = ugrid_from_unstructured(node_y_and_x, links=links, patches=patches)
 
@@ -908,16 +909,16 @@
         ...     (5, 8),
         ...     (6, 7),
         ...     (7, 8),
         ... )
         >>> patches = ((0, 3, 5, 2), (1, 4, 6, 3))
         >>> graph = Graph((node_y, node_x), links=links, patches=patches)
         >>> graph.xy_of_patch
-        array([[ 0.5,  0.5],
-              [ 1.5,  0.5]])
+        array([[0.5, 0.5],
+               [1.5, 0.5]])
 
         :meta landlab: info-patch
         """
         return get_centroid_of_patch(self)
 
     @cached_property
     @read_only_array
@@ -941,15 +942,15 @@
         ...     (5, 8),
         ...     (6, 7),
         ...     (7, 8),
         ... )
         >>> patches = ((0, 3, 5, 2), (1, 4, 6, 3))
         >>> graph = Graph((node_y, node_x), links=links, patches=patches)
         >>> graph.area_of_patch
-        array([ 1.,  1.])
+        array([1.,  1.])
 
         :meta landlab: info-patch
         """
         return get_area_of_patch(self)
 
     @property
     def number_of_patches(self):
@@ -977,15 +978,15 @@
         >>> graph = Graph((node_y, node_x), links=links, patches=patches)
         >>> graph.number_of_patches == 2
         True
 
         :meta landlab: info-patch
         """
         try:
-            return self.ds.dims["patch"]
+            return self.ds.sizes["patch"]
         except KeyError:
             return 0
 
     @property
     def links_at_patch(self):
         """Get the links that define a patch.
```

### Comparing `landlab-2.7.0/landlab/graph/graph_convention.py` & `landlab-2.8.0/landlab/graph/graph_convention.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,12 @@
 import re
 from collections import OrderedDict
 
 
 class GraphConvention:
-
     """Define a naming convention for graph elements."""
 
     def __init__(self, node, edge, face, nodes=None, edges=None, faces=None):
         """Define a graph element naming convention.
 
         Parameters
         ----------
@@ -76,15 +75,14 @@
     @property
     def faces(self):
         """The plural name for face."""
         return self._faces
 
 
 class ConventionConverter:
-
     """Convert between graph element naming conventions."""
 
     CONVENTION = {
         "nlp": GraphConvention("node", "link", "patch", faces="patches"),
         "nef": GraphConvention("node", "edge", "face"),
         "cfc": GraphConvention("corner", "face", "cell"),
     }
```

### Comparing `landlab-2.7.0/landlab/graph/hex/dual_hex.py` & `landlab-2.8.0/landlab/graph/hex/dual_hex.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,36 @@
 import numpy as np
 
 from ..dual import DualGraph
 from ..voronoi.dual_voronoi import DualVoronoiGraph
-from .hex import (
-    HorizontalHexTriGraph,
-    HorizontalRectTriGraph,
-    TriGraph,
-    VerticalHexTriGraph,
-    VerticalRectTriGraph,
-)
+from .hex import HorizontalHexTriGraph
+from .hex import HorizontalRectTriGraph
+from .hex import TriGraph
+from .hex import VerticalHexTriGraph
+from .hex import VerticalRectTriGraph
 
 
 class DualHexGraph(DualGraph, TriGraph):
-
     """Graph of a structured grid of triangles.
 
     Examples
     --------
     >>> import numpy as np
     >>> from landlab.graph import DualHexGraph
 
     >>> graph = DualHexGraph((3, 2), node_layout="hex")
     >>> graph.number_of_nodes
     7
     >>> graph.number_of_corners
     6
 
     >>> np.round(graph.y_of_node * 2.0 / np.sqrt(3))
-    array([ 0.,  0.,  1.,  1.,  1.,  2.,  2.])
+    array([0., 0., 1., 1., 1., 2., 2.])
     >>> graph.x_of_node
-    array([ 0.5,  1.5,  0. ,  1. ,  2. ,  0.5,  1.5])
+    array([0.5, 1.5, 0. , 1. , 2. , 0.5, 1.5])
     """
 
     def __init__(
         self,
         shape,
         spacing=1.0,
         xy_of_lower_left=(0.0, 0.0),
```

### Comparing `landlab-2.7.0/landlab/graph/hex/ext/hex.pyx` & `landlab-2.8.0/landlab/graph/hex/ext/hex.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -12,16 +12,14 @@
 def fill_xy_of_node_hex_horizontal(
     shape,
     np.ndarray[np.double_t, ndim=1] x_of_node,
     np.ndarray[np.double_t, ndim=1] y_of_node,
 ):
     """Get x and y coordinates for each node."""
     cdef long n_rows = shape[0]
-    cdef long n_cols = shape[1]
-    cdef long n_nodes = len(x_of_node)
     cdef long longest_row = n_rows // 2
     cdef long row
     cdef long offset
     cdef long *size_of_row
     cdef long *offset_to_row
     cdef double x0
 
@@ -206,20 +204,18 @@
         row = (offset // stride) * 2 + 1
         for n in range(offset, offset + n_cols + 1):
             x_of_node[n] = n - offset
             y_of_node[n] = row
 
 
 @cython.boundscheck(False)
-def get_nodes_at_link(shape,
-                   np.ndarray[DTYPE_t, ndim=2] nodes_at_link):
+def get_nodes_at_link(
+    shape, np.ndarray[DTYPE_t, ndim=2] nodes_at_link
+):
     """Get nodes at the tail and head of each node."""
-    cdef int n_links = nodes_at_link.shape[0]
-    cdef int n_short_rows = (shape[0] + 1) // 2
-    cdef int n_long_rows = shape[0] // 2
     cdef int n_cols = shape[1]
     cdef int n_rows = shape[0]
     cdef int stride = 2 * n_cols + 1
     cdef int row
     cdef int n
     cdef int link
 
@@ -265,16 +261,14 @@
 
 
 @cython.boundscheck(False)
 def get_links_at_patch(shape,
                        np.ndarray[DTYPE_t, ndim=2] links_at_patch):
     """Get links that bound each patch."""
     cdef int n_patches = links_at_patch.shape[0]
-    cdef int n_short_rows = (shape[0] + 1) // 2
-    cdef int n_long_rows = shape[0] // 2
     cdef int n_cols = shape[1]
     cdef int n_rows = shape[0]
     cdef int row
     cdef int n
     cdef int patch
     cdef int link
     cdef int link_at_row
```

### Comparing `landlab-2.7.0/landlab/graph/hex/ext/perimeternodes.pyx` & `landlab-2.8.0/landlab/graph/hex/ext/perimeternodes.pyx`

 * *Files 3% similar despite different names*

```diff
@@ -44,17 +44,15 @@
 @cython.boundscheck(False)
 def fill_perimeter_nodes_rect_vertical(
     shape,
     np.ndarray[DTYPE_t, ndim=1] perimeter_nodes,
 ):
     cdef int n_rows = shape[0]
     cdef int n_cols = shape[1]
-    cdef int n_nodes = n_rows * n_cols
     cdef int i
-    cdef int node
     cdef int offset_to_right_edge
     cdef int offset_to_top_edge
     cdef int offset_to_left_edge
     cdef int offset_to_bottom_edge
 
     offset_to_top_edge = n_rows - 1
     offset_to_left_edge = offset_to_top_edge + n_cols - 1
@@ -102,16 +100,15 @@
     cdef int n_rows = shape[0]
     cdef int n_cols = shape[1]
     cdef int longest_row = n_rows // 2
     cdef int offset_to_right_edge
     cdef int offset_to_top_edge
     cdef int offset_to_left_edge
     cdef int offset_to_bottom_edge
-    cdef int i, i0
-    cdef int node
+    cdef int i
     cdef int row
     cdef int * nodes_per_row
 
     try:
         nodes_per_row = <int *>malloc(n_rows * sizeof(int))
 
         nodes_per_row[0] = n_cols
@@ -159,17 +156,15 @@
     cdef int n_cols = shape[1]
     cdef int longest_col = n_cols // 2
     cdef int max_nodes_per_row = n_cols - n_cols // 2
     cdef int offset_to_right_edge
     cdef int offset_to_top_edge
     cdef int offset_to_left_edge
     cdef int offset_to_bottom_edge
-    cdef int i, i0
-    cdef int node
-    cdef int row
+    cdef int i
 
     if n_cols % 2 == 1:
         offset_to_top_edge = n_rows - 1
     else:
         offset_to_top_edge = n_rows
     offset_to_left_edge = offset_to_top_edge + n_cols - 1
     offset_to_bottom_edge = offset_to_left_edge + n_rows - 1
```

### Comparing `landlab-2.7.0/landlab/graph/hex/hex.py` & `landlab-2.8.0/landlab/graph/hex/hex.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,19 +15,19 @@
         * - *
 
 >>> from landlab.graph import TriGraph
 >>> graph = TriGraph((5, 2), node_layout="hex", sort=True)
 >>> graph.number_of_nodes
 14
 >>> graph.x_of_node
-array([ 1. ,  2. ,
-        0.5,  1.5,  2.5,
-        0. ,  1. ,  2. ,  3. ,
-        0.5,  1.5, 2.5,
-        1. ,  2. ])
+array([1. , 2. ,
+       0.5, 1.5, 2.5,
+       0. , 1. , 2. , 3. ,
+       0.5, 1.5, 2.5,
+       1. , 2. ])
 >>> graph.number_of_links
 29
 >>> graph.number_of_patches
 16
 
 ::
 
@@ -38,30 +38,31 @@
     * - * - * - *
 
 >>> from landlab.graph import TriGraph
 >>> graph = TriGraph((3, 4), orientation="horizontal", node_layout="rect", sort=True)
 >>> graph.number_of_nodes
 12
 >>> graph.x_of_node.reshape((3, 4))
-array([[ 0. ,  1. ,  2. ,  3. ],
-       [ 0.5,  1.5,  2.5,  3.5],
-       [ 0. ,  1. ,  2. ,  3. ]])
+array([[0. , 1. , 2. , 3. ],
+       [0.5, 1.5, 2.5, 3.5],
+       [0. , 1. , 2. , 3. ]])
 >>> graph.number_of_links
 23
 >>> graph.number_of_patches
 12
 """
 
 from functools import cached_property
 
 import numpy as np
 
 from ...core.utils import as_id_array
 from ...grid.linkorientation import LinkOrientation
-from ...utils.decorators import cache_result_in_object, make_return_array_immutable
+from ...utils.decorators import cache_result_in_object
+from ...utils.decorators import make_return_array_immutable
 from ..graph import Graph
 from ..voronoi.voronoi import DelaunayGraph
 
 
 class HorizontalRectTriGraphCython:
     @staticmethod
     def xy_of_node(shape, spacing=1.0, xy_of_lower_left=(0.0, 0.0)):
@@ -885,29 +886,28 @@
                 links_at_node[self.node_at_link_tail[links], col] = links
                 links_at_node[self.node_at_link_head[links], col + 3] = links
 
         return links_at_node
 
 
 class TriGraph(HexGraphExtras, DelaunayGraph):
-
     """Graph of a structured grid of triangles.
 
     Examples
     --------
     >>> import numpy as np
     >>> from landlab.graph import TriGraph
 
     >>> graph = TriGraph((3, 2))
     >>> graph.number_of_nodes == 6
     True
     >>> np.round(graph.y_of_node * 2.0 / np.sqrt(3))
-    array([ 0.,  0.,  1.,  1.,  2.,  2.])
+    array([0., 0., 1., 1., 2., 2.])
     >>> graph.x_of_node
-    array([ 0. ,  1. ,  0.5,  1.5,  0. ,  1. ])
+    array([0. , 1. , 0.5, 1.5, 0. , 1. ])
     """
 
     def __init__(
         self,
         shape,
         spacing=1.0,
         xy_of_lower_left=(0.0, 0.0),
```

### Comparing `landlab-2.7.0/landlab/graph/matrix/at_node.py` & `landlab-2.8.0/landlab/graph/matrix/at_node.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/graph/matrix/at_patch.py` & `landlab-2.8.0/landlab/graph/matrix/at_patch.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/graph/matrix/ext/at_patch.pyx` & `landlab-2.8.0/landlab/graph/matrix/ext/at_patch.pyx`

 * *Files 16% similar despite different names*

```diff
@@ -4,25 +4,27 @@
 cimport numpy as np
 
 DTYPE = int
 ctypedef np.int_t DTYPE_t
 
 
 @cython.boundscheck(False)
-def fill_links_at_patch(np.ndarray[DTYPE_t, ndim=1] links_at_patch,
-                        np.ndarray[DTYPE_t, ndim=1] offset_to_patch,
-                        np.ndarray[DTYPE_t, ndim=2] out):
+def fill_links_at_patch(
+    np.ndarray[DTYPE_t, ndim=1] links_at_patch,
+    np.ndarray[DTYPE_t, ndim=1] offset_to_patch,
+    np.ndarray[DTYPE_t, ndim=2] out,
+):
     cdef int i
     cdef int link
     cdef int patch
     cdef int offset
     cdef int n_links
     cdef int n_patches = len(offset_to_patch) - 1
 
     for patch in range(n_patches):
         offset = offset_to_patch[patch]
         n_links = offset_to_patch[patch + 1] - offset
 
         link = 0
         for i in range(offset, offset + n_links):
-          out[patch, link] = links_at_patch[i]
-          link += 1
+            out[patch, link] = links_at_patch[i]
+            link += 1
```

### Comparing `landlab-2.7.0/landlab/graph/matrix/ext/matrix.pyx` & `landlab-2.8.0/landlab/graph/matrix/ext/matrix.pyx`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/graph/object/at_node.py` & `landlab-2.8.0/landlab/graph/object/at_node.py`

 * *Files 2% similar despite different names*

```diff
@@ -112,15 +112,16 @@
     ...     links_at_node, link_dirs_at_node, angle_of_link, inplace=True
     ... )
     >>> links_at_node
     array([[0, 2], [2, 1], [3, 0],  [1, 3]])
     >>> link_dirs_at_node
     array([[-1,  1], [-1, -1], [-1,  1], [ 1,  1]], dtype=int8)
     """
-    from .ext.at_node import reorder_link_dirs_at_node, reorder_links_at_node
+    from .ext.at_node import reorder_link_dirs_at_node
+    from .ext.at_node import reorder_links_at_node
 
     out = (
         np.asarray(links_at_node, dtype=int),
         np.asarray(link_dirs_at_node, dtype=np.int8),
     )
 
     if inplace and (out[0] is not links_at_node or out[1] is not link_dirs_at_node):
```

### Comparing `landlab-2.7.0/landlab/graph/object/at_patch.py` & `landlab-2.8.0/landlab/graph/object/at_patch.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/graph/object/ext/at_node.pyx` & `landlab-2.8.0/landlab/graph/object/ext/at_node.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -5,18 +5,20 @@
 from libc.stdlib cimport free, malloc
 
 ctypedef np.int_t DTYPE_t
 ctypedef np.int8_t INT8TYPE_t
 
 
 @cython.boundscheck(False)
-def find_links_at_node(DTYPE_t node,
-                       np.ndarray[DTYPE_t, ndim=2] nodes_at_link,
-                       np.ndarray[DTYPE_t, ndim=1] links_at_node,
-                       np.ndarray[INT8TYPE_t, ndim=1] link_dirs_at_node):
+def find_links_at_node(
+    DTYPE_t node,
+    np.ndarray[DTYPE_t, ndim=2] nodes_at_link,
+    np.ndarray[DTYPE_t, ndim=1] links_at_node,
+    np.ndarray[INT8TYPE_t, ndim=1] link_dirs_at_node,
+):
     """Find links touching a node and their directions.
 
     Parameters
     ----------
     node : int
         A node ID.
     nodes_at_link : ndarray of int, shape `(n_links, 2)`
@@ -48,17 +50,19 @@
 
         link += 1
 
     return n_links_found
 
 
 @cython.boundscheck(False)
-def get_links_at_node(np.ndarray[DTYPE_t, ndim=2] nodes_at_link,
-                      np.ndarray[DTYPE_t, ndim=2] links_at_node,
-                      np.ndarray[INT8TYPE_t, ndim=2] link_dirs_at_node):
+def get_links_at_node(
+    np.ndarray[DTYPE_t, ndim=2] nodes_at_link,
+    np.ndarray[DTYPE_t, ndim=2] links_at_node,
+    np.ndarray[INT8TYPE_t, ndim=2] link_dirs_at_node,
+):
     """Get links touching each node and their directions.
 
     Parameters
     ----------
     nodes_at_link : ndarray of int, shape `(n_links, 2)`
         Node identifiers for each link tail and head.
     links_at_node : ndarray of int, shape `(n_nodes, max_nodes_per_link)`
@@ -66,47 +70,52 @@
     link_dirs_at_node : ndarray of int, shape `(n_nodes, max_nodes_per_link)`
         Buffer to hold link directions for each node.
     """
     cdef int node
     cdef int n_nodes = links_at_node.shape[0]
 
     for node in range(n_nodes):
-        find_links_at_node(node, nodes_at_link, links_at_node[node],
-                           link_dirs_at_node[node])
+        find_links_at_node(
+            node, nodes_at_link, links_at_node[node], link_dirs_at_node[node]
+        )
 
 
 @cython.boundscheck(False)
-def reorder_links_at_node(np.ndarray[DTYPE_t, ndim=2] links_at_node,
-                          np.ndarray[DTYPE_t, ndim=2] sorted_links):
+def reorder_links_at_node(
+    np.ndarray[DTYPE_t, ndim=2] links_at_node,
+    np.ndarray[DTYPE_t, ndim=2] sorted_links,
+):
     cdef int n_nodes = links_at_node.shape[0]
     cdef int n_links_per_node = links_at_node.shape[1]
     cdef int i
     cdef int node
     cdef int *buffer = <int *>malloc(n_links_per_node * sizeof(int))
 
     try:
-      for node in range(n_nodes):
-          for i in range(n_links_per_node):
-              buffer[i] = links_at_node[node, sorted_links[node, i]]
-          for i in range(n_links_per_node):
-            links_at_node[node, i] = buffer[i]
+        for node in range(n_nodes):
+            for i in range(n_links_per_node):
+                buffer[i] = links_at_node[node, sorted_links[node, i]]
+            for i in range(n_links_per_node):
+                links_at_node[node, i] = buffer[i]
     finally:
         free(buffer)
 
 
 @cython.boundscheck(False)
-def reorder_link_dirs_at_node(np.ndarray[INT8TYPE_t, ndim=2] link_dirs_at_node,
-                              np.ndarray[DTYPE_t, ndim=2] sorted_links):
+def reorder_link_dirs_at_node(
+    np.ndarray[INT8TYPE_t, ndim=2] link_dirs_at_node,
+    np.ndarray[DTYPE_t, ndim=2] sorted_links,
+):
     cdef int n_nodes = link_dirs_at_node.shape[0]
     cdef int n_links_per_node = link_dirs_at_node.shape[1]
     cdef int i
     cdef int node
     cdef int *buffer = <int *>malloc(n_links_per_node * sizeof(int))
 
     try:
-      for node in range(n_nodes):
-          for i in range(n_links_per_node):
-              buffer[i] = link_dirs_at_node[node, sorted_links[node, i]]
-          for i in range(n_links_per_node):
-            link_dirs_at_node[node, i] = buffer[i]
+        for node in range(n_nodes):
+            for i in range(n_links_per_node):
+                buffer[i] = link_dirs_at_node[node, sorted_links[node, i]]
+            for i in range(n_links_per_node):
+                link_dirs_at_node[node, i] = buffer[i]
     finally:
         free(buffer)
```

### Comparing `landlab-2.7.0/landlab/graph/object/ext/at_patch.pyx` & `landlab-2.8.0/landlab/graph/object/ext/at_patch.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,20 @@
 import numpy as np
 
 cimport cython
 cimport numpy as np
-from libc.stdlib cimport free, malloc, qsort
-
-from ...sort.ext.argsort cimport unique_int
+from libc.stdlib cimport free, malloc
 
 
 @cython.boundscheck(True)
 def get_rightmost_edge_at_patch(
     np.ndarray[long, ndim=2, mode="c"] links_at_patch,
     np.ndarray[double, ndim=2, mode="c"] xy_of_link,
-    np.ndarray[long, ndim=1, mode="c"] edge):
+    np.ndarray[long, ndim=1, mode="c"] edge,
+):
     cdef int n_patches = links_at_patch.shape[0]
     cdef int n_cols = links_at_patch.shape[1]
     cdef int patch
     cdef int link
     cdef int n
     cdef int max_n
     cdef double max_x
@@ -35,15 +34,15 @@
 
 cdef find_common_node(long * link_a, long * link_b):
     if link_a[0] == link_b[0] or link_a[0] == link_b[1]:
         return link_a[0]
     elif link_a[1] == link_b[0] or link_a[1] == link_b[1]:
         return link_a[1]
     else:
-        raise ValueError('links are not connected')
+        raise ValueError("links are not connected")
 
 
 cdef all_nodes_at_patch(long * links_at_patch, long max_links,
                         long * nodes_at_link, long * out):
     cdef long n_links = max_links
     cdef long link
     cdef long i
@@ -82,33 +81,29 @@
 @cython.boundscheck(True)
 def get_nodes_at_patch(np.ndarray[long, ndim=2, mode="c"] links_at_patch,
                        np.ndarray[long, ndim=2, mode="c"] nodes_at_link,
                        np.ndarray[long, ndim=2, mode="c"] nodes_at_patch):
     cdef int n_patches = links_at_patch.shape[0]
     cdef int max_links_at_patch = links_at_patch.shape[1]
     cdef int patch
-    cdef int link
-    cdef int i
-    cdef int n_links
-    cdef int n_unique
     cdef long * all_nodes = <long *>malloc(2 * links_at_patch.shape[1] * sizeof(long))
 
     try:
         for patch in range(n_patches):
-            n_links = _nodes_at_patch(
+            _nodes_at_patch(
                 &links_at_patch[patch, 0], max_links_at_patch,
                 &nodes_at_link[0, 0], &nodes_at_patch[patch, 0])
     finally:
         free(all_nodes)
 
 
 cdef _nodes_at_patch(long * links_at_patch, long max_links,
                      long * nodes_at_link, long * out):
     cdef long n_links = max_links
-    cdef long link, next_link, prev_link
+    cdef long link, next_link
     cdef long i
 
     while links_at_patch[n_links - 1] == -1:
         n_links -= 1
 
     next_link = links_at_patch[0]
     for i in range(0, n_links - 1):
```

### Comparing `landlab-2.7.0/landlab/graph/quantity/ext/of_link.pyx` & `landlab-2.8.0/landlab/graph/quantity/ext/of_link.pyx`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/graph/quantity/ext/of_patch.pyx` & `landlab-2.8.0/landlab/graph/quantity/ext/of_patch.pyx`

 * *Files 11% similar despite different names*

```diff
@@ -5,29 +5,33 @@
 from libc.stdlib cimport free, malloc
 
 DTYPE = int
 ctypedef np.int_t DTYPE_t
 
 
 @cython.boundscheck(False)
-def calc_area_at_patch(np.ndarray[long, ndim=2] nodes_at_patch,
-                       np.ndarray[np.float_t, ndim=1] x_of_node,
-                       np.ndarray[np.float_t, ndim=1] y_of_node,
-                       np.ndarray[np.float_t, ndim=1] out):
+def calc_area_at_patch(
+    np.ndarray[long, ndim=2] nodes_at_patch,
+    np.ndarray[np.float_t, ndim=1] x_of_node,
+    np.ndarray[np.float_t, ndim=1] y_of_node,
+    np.ndarray[np.float_t, ndim=1] out,
+):
     cdef long n_patches = nodes_at_patch.shape[0]
     cdef long n_vertices = nodes_at_patch.shape[1]
     cdef long n
 
     for n in range(n_patches):
-      out[n] = calc_area_of_patch(&nodes_at_patch[n, 0], n_vertices,
-                                  &x_of_node[0], &y_of_node[0])
+        out[n] = calc_area_of_patch(
+            &nodes_at_patch[n, 0], n_vertices, &x_of_node[0], &y_of_node[0]
+        )
 
 
-cdef calc_area_of_patch(long * nodes_at_patch, long n_vertices,
-                        double * x_of_node, double * y_of_node):
+cdef calc_area_of_patch(
+    long * nodes_at_patch, long n_vertices, double * x_of_node, double * y_of_node
+):
     cdef int n
     cdef int node
     cdef double * x_of_vertex = <double *>malloc(n_vertices * sizeof(double))
     cdef double * y_of_vertex = <double *>malloc(n_vertices * sizeof(double))
 
     try:
         for n in range(n_vertices):
@@ -41,30 +45,37 @@
         return calc_area_of_polygon(x_of_vertex, y_of_vertex, n + 1)
     finally:
         free(y_of_vertex)
         free(x_of_vertex)
 
 
 @cython.boundscheck(False)
-def calc_centroid_at_patch(np.ndarray[long, ndim=2] nodes_at_patch,
-                           np.ndarray[np.float_t, ndim=1] x_of_node,
-                           np.ndarray[np.float_t, ndim=1] y_of_node,
-                           np.ndarray[np.float_t, ndim=2] out):
+def calc_centroid_at_patch(
+    np.ndarray[long, ndim=2] nodes_at_patch,
+    np.ndarray[np.float_t, ndim=1] x_of_node,
+    np.ndarray[np.float_t, ndim=1] y_of_node,
+    np.ndarray[np.float_t, ndim=2] out,
+):
     cdef long n_patches = nodes_at_patch.shape[0]
     cdef long n_vertices = nodes_at_patch.shape[1]
     cdef long n
 
     for n in range(n_patches):
-        calc_centroid_of_patch(&nodes_at_patch[n, 0], n_vertices,
-                               &x_of_node[0], &y_of_node[0],
-                               &out[n, 0])
+        calc_centroid_of_patch(
+            &nodes_at_patch[n, 0], n_vertices, &x_of_node[0], &y_of_node[0], &out[n, 0]
+        )
 
 
-cdef calc_centroid_of_patch(long * nodes_at_patch, long n_vertices,
-                            double * x_of_node, double * y_of_node, double * out):
+cdef calc_centroid_of_patch(
+    long * nodes_at_patch,
+    long n_vertices,
+    double * x_of_node,
+    double * y_of_node,
+    double * out,
+):
     cdef int n
     cdef int node
     cdef double * x = <double *>malloc(n_vertices * sizeof(double))
     cdef double * y = <double *>malloc(n_vertices * sizeof(double))
 
     try:
         for n in range(n_vertices):
@@ -76,16 +87,20 @@
             y[n] = y_of_node[node]
         calc_centroid_of_polygon(x, y, n + 1, out)
     finally:
         free(y)
         free(x)
 
 
-cdef calc_centroid_of_polygon(double * x, double * y, long n_vertices,
-                              double * out):
+cdef calc_centroid_of_polygon(
+    double * x,
+    double * y,
+    long n_vertices,
+    double * out,
+):
     cdef double x_of_centroid = 0.
     cdef double y_of_centroid = 0.
     cdef double area = calc_area_of_polygon(x, y, n_vertices)
     cdef double c
     cdef int n
 
     c = x[n_vertices - 1] * y[0] - x[0] * y[n_vertices - 1]
```

### Comparing `landlab-2.7.0/landlab/graph/quantity/of_link.py` & `landlab-2.8.0/landlab/graph/quantity/of_link.py`

 * *Files 2% similar despite different names*

```diff
@@ -61,18 +61,18 @@
     --------
     >>> import numpy as np
     >>> from landlab.graph import UniformRectilinearGraph
     >>> from landlab.graph.quantity.of_link import get_midpoint_of_link
 
     >>> graph = UniformRectilinearGraph((2, 2))
     >>> get_midpoint_of_link(graph)
-    array([[ 0.5,  0. ],
-           [ 0. ,  0.5],
-           [ 1. ,  0.5],
-           [ 0.5,  1. ]])
+    array([[0.5, 0. ],
+           [0. , 0.5],
+           [1. , 0.5],
+           [0.5, 1. ]])
 
     >>> points = np.empty((graph.number_of_links, 2), dtype=float)
     >>> rtn = get_midpoint_of_link(graph, out=points)
     >>> points is rtn
     True
     """
     from .ext.of_link import calc_midpoint_of_link
```

### Comparing `landlab-2.7.0/landlab/graph/quantity/of_patch.py` & `landlab-2.8.0/landlab/graph/quantity/of_patch.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/graph/radial/dual_radial.py` & `landlab-2.8.0/landlab/graph/radial/dual_radial.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 import numpy as np
 
 from ..dual import DualGraph
 from ..voronoi.dual_voronoi import DualVoronoiGraph
-from .radial import RadialGraph, RadialGraphLayout
+from .radial import RadialGraph
+from .radial import RadialGraphLayout
 
 
 class DualRadialGraph(DualGraph, RadialGraph):
-
     """Graph of a series of points on concentric circles.
 
     Examples
     --------
     >>> from landlab.graph import DualRadialGraph
     >>> graph = DualRadialGraph((1, 4), sort=True)
     >>> graph.number_of_corners
```

### Comparing `landlab-2.7.0/landlab/graph/radial/radial.py` & `landlab-2.8.0/landlab/graph/radial/radial.py`

 * *Files 2% similar despite different names*

```diff
@@ -116,15 +116,14 @@
                 angles, 0.5 * step, out=angles
             )
             offset += n_nodes
         return angle_at_node
 
 
 class RadialGraph(RadialGraphExtras, DelaunayGraph):
-
     """Graph of a series of points on concentric circles.
 
     Examples
     --------
     >>> import numpy as np
     >>> from landlab.graph import RadialGraph
     >>> graph = RadialGraph((1, 4), sort=True)
@@ -221,16 +220,16 @@
         -------
         ndarray of float
             The distance from the center node of each node.
 
         >>> from landlab.graph import RadialGraph
         >>> graph = RadialGraph((2, 6), sort=True)
         >>> np.round(graph.radius_at_node, 3)
-        array([ 2.,  2.,  2.,  2.,  2.,  1.,  1.,  2.,  1.,  0.,  1.,  2.,  1.,
-                1.,  2.,  2.,  2.,  2.,  2.])
+        array([2., 2., 2., 2., 2., 1., 1., 2., 1., 0., 1., 2., 1.,
+               1., 2., 2., 2., 2., 2.])
 
         :meta landlab: info-node, quantity
         """
         return np.sqrt(
             np.square(self.x_of_node - self._xy_of_center[0])
             + np.square(self.y_of_node - self._xy_of_center[1])
         )
```

### Comparing `landlab-2.7.0/landlab/graph/sort/ext/remap_element.pyx` & `landlab-2.8.0/landlab/graph/sort/ext/remap_element.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -7,16 +7,14 @@
 
 cdef extern from "math.h":
     double atan2(double y, double x) nogil
 
 
 from .spoke_sort import sort_spokes_at_wheel
 
-from .argsort cimport argsort_int
-
 DTYPE = int
 ctypedef np.int_t DTYPE_t
 ctypedef np.uint8_t uint8
 
 
 @cython.boundscheck(False)
 def reverse_one_to_one(np.ndarray[DTYPE_t, ndim=1] mapping,
@@ -24,15 +22,15 @@
     cdef int n_elements = mapping.shape[0]
     cdef int index
     cdef int id_
 
     for index in range(n_elements):
         id_ = mapping[index]
         if id_ >= 0:
-          out[id_] = index
+            out[id_] = index
 
 
 @cython.boundscheck(False)
 def reverse_one_to_many(np.ndarray[DTYPE_t, ndim=2] mapping,
                         np.ndarray[DTYPE_t, ndim=2] out):
     cdef int n_elements = mapping.shape[0]
     cdef int n_cols = mapping.shape[1]
@@ -67,15 +65,15 @@
     old_to_new : ndarray of int
         Mapping from the old identifier to the new identifier.
     """
     cdef int n_elements = elements.shape[0]
     cdef int i
 
     for i in range(n_elements):
-      elements[i] = old_to_new[elements[i]]
+        elements[i] = old_to_new[elements[i]]
 
 
 @cython.boundscheck(False)
 def remap_graph_element_ignore(np.ndarray[DTYPE_t, ndim=1] elements,
                                np.ndarray[DTYPE_t, ndim=1] old_to_new,
                                DTYPE_t bad_val):
     """Remap elements in an array in place, ignoring bad values.
@@ -282,15 +280,14 @@
     np.ndarray[DTYPE_t, ndim=1, mode="c"] data not None,
     np.ndarray[DTYPE_t, ndim=2, mode="c"] pairs not None,
     np.ndarray[DTYPE_t, ndim=1, mode="c"] out not None,
 ):
     cdef long pair
     cdef long n_pairs = out.shape[0]
     cdef long n_values = data.shape[0]
-    cdef long val
     cdef SparseMatrixInt mat
 
     mat = sparse_matrix_alloc_with_tuple(&src_pairs[0, 0], &data[0], n_values, -1)
 
     for pair in range(n_pairs):
         out[pair] = sparse_matrix_get_or_transpose(mat, pairs[pair, 0], pairs[pair, 1])
 
@@ -313,15 +310,14 @@
 
     for pair in range(n_pairs):
         _map_rolling_pairs(mat, &pairs[pair, 0], &out[pair, 0], size_of_row[pair])
 
 
 cdef _map_rolling_pairs(SparseMatrixInt mat, DTYPE_t *pairs, DTYPE_t *out, long size):
     cdef long n
-    cdef long val
 
     if size > 0:
         for n in range(size - 1):
             out[n] = sparse_matrix_get_or_transpose(mat, pairs[n], pairs[n + 1])
 
         n = size - 1
         out[n] = sparse_matrix_get_or_transpose(mat, pairs[n], pairs[0])
```

### Comparing `landlab-2.7.0/landlab/graph/sort/ext/spoke_sort.pyx` & `landlab-2.8.0/landlab/graph/sort/ext/spoke_sort.pyx`

 * *Files 5% similar despite different names*

```diff
@@ -1,19 +1,20 @@
 import numpy as np
 
 cimport cython
 cimport numpy as np
 from libc.math cimport atan2
-from libc.stdlib cimport free, malloc, qsort
+from libc.stdlib cimport free, malloc
 
-from .argsort cimport argsort
+from .argsort cimport argsort_flt
 
 
-cdef _calc_spoke_angles(double * hub, double * spokes, np.int_t n_spokes,
-                        double * angles):
+cdef _calc_spoke_angles(
+    double * hub, double * spokes, np.int_t n_spokes, double * angles
+):
     cdef int i
     cdef double x0 = hub[0]
     cdef double y0 = hub[1]
     cdef double * spoke = spokes
     cdef double two_pi = 2. * np.pi
     cdef double x
     cdef double y
@@ -24,58 +25,59 @@
 
         angles[i] = atan2(y - y0, x - x0)
         if angles[i] < 0.:
             angles[i] += two_pi
         spoke += 2
 
 
-cdef _argsort_spokes_around_hub(long * spokes, int n_spokes,
-                                double * xy_of_spoke, double * xy_of_hub,
-                                int * ordered):
+cdef _argsort_spokes_around_hub(
+    long * spokes,
+    int n_spokes,
+    double * xy_of_spoke,
+    double * xy_of_hub,
+    int * ordered,
+):
     cdef int point
     cdef int spoke
     cdef double * points = <double *>malloc(2 * n_spokes * sizeof(double))
     cdef double * angles = <double *>malloc(n_spokes * sizeof(double))
-    # cdef int * ordered = <int *>malloc(n_spokes * sizeof(int))
-    # cdef int * temp = <int *>malloc(n_spokes * sizeof(int))
 
     try:
         point = 0
         for spoke in range(n_spokes):
             points[point] = xy_of_spoke[2 * spokes[spoke]]
             points[point + 1] = xy_of_spoke[2 * spokes[spoke] + 1]
             point += 2
 
         _calc_spoke_angles(xy_of_hub, points, n_spokes, angles)
-        argsort(angles, n_spokes, ordered)
+        argsort_flt(angles, n_spokes, ordered)
 
         # for spoke in range(n_spokes):
         #     temp[spoke] = spokes[ordered[spoke]]
 
         # for spoke in range(n_spokes):
         #     spokes[spoke] = temp[spoke]
     finally:
         free(angles)
         # free(temp)
         # free(ordered)
         free(points)
 
 
-cdef _sort_spokes_around_hub(long * spokes, int n_spokes, double * xy_of_spoke,
-                             double * xy_of_hub):
-    cdef int point
+cdef _sort_spokes_around_hub(
+    long * spokes, int n_spokes, double * xy_of_spoke, double * xy_of_hub
+):
     cdef int spoke
     # cdef double * points = <double *>malloc(2 * n_spokes * sizeof(double))
     # cdef double * angles = <double *>malloc(n_spokes * sizeof(double))
     cdef int * ordered = <int *>malloc(n_spokes * sizeof(int))
     cdef int * temp = <int *>malloc(n_spokes * sizeof(int))
 
     try:
-        _argsort_spokes_around_hub(spokes, n_spokes, xy_of_spoke, xy_of_hub,
-                                   ordered)
+        _argsort_spokes_around_hub(spokes, n_spokes, xy_of_spoke, xy_of_hub, ordered)
 
         # point = 0
         # for spoke in range(n_spokes):
         #     points[point] = xy_of_spoke[2 * spokes[spoke]]
         #     points[point + 1] = xy_of_spoke[2 * spokes[spoke] + 1]
         #     point += 2
 
@@ -91,35 +93,40 @@
         # free(angles)
         free(temp)
         free(ordered)
         # free(points)
 
 
 @cython.boundscheck(False)
-def calc_spoke_angles(np.ndarray[double, ndim=1, mode="c"] hub,
-                      np.ndarray[double, ndim=1, mode="c"] spokes,
-                      np.ndarray[double, ndim=1, mode="c"] angles):
+def calc_spoke_angles(
+    np.ndarray[double, ndim=1, mode="c"] hub,
+    np.ndarray[double, ndim=1, mode="c"] spokes,
+    np.ndarray[double, ndim=1, mode="c"] angles,
+):
     cdef int n_spokes = spokes.shape[0] // 2
     _calc_spoke_angles(&hub[0], &spokes[0], n_spokes, &angles[0])
 
 
 @cython.boundscheck(False)
-def sort_spokes_around_hub(np.ndarray[long, ndim=1, mode="c"] spokes,
-                           np.ndarray[double, ndim=2, mode="c"] xy_of_spoke,
-                           np.ndarray[double, ndim=1, mode="c"] xy_of_hub):
+def sort_spokes_around_hub(
+    np.ndarray[long, ndim=1, mode="c"] spokes,
+    np.ndarray[double, ndim=2, mode="c"] xy_of_spoke,
+    np.ndarray[double, ndim=1, mode="c"] xy_of_hub,
+):
     cdef int n_spokes = spokes.shape[0]
 
-    _sort_spokes_around_hub(&spokes[0], n_spokes, &xy_of_spoke[0, 0],
-                            &xy_of_hub[0])
+    _sort_spokes_around_hub(&spokes[0], n_spokes, &xy_of_spoke[0, 0], &xy_of_hub[0])
 
 
 @cython.boundscheck(False)
-def argsort_points_around_hub(np.ndarray[double, ndim=2, mode="c"] points,
-                              np.ndarray[double, ndim=1, mode="c"] hub,
-                              np.ndarray[int, ndim=1] out):
+def argsort_points_around_hub(
+    np.ndarray[double, ndim=2, mode="c"] points,
+    np.ndarray[double, ndim=1, mode="c"] hub,
+    np.ndarray[int, ndim=1] out,
+):
     """Sort spokes by angle around a hub.
 
     Parameters
     ----------
     points : ndarray of float, shape `(n_points, 2)`
         Coordinates of points as (*x*, *y*).
     out : ndarray of int, shape `(n_points, )`
@@ -131,50 +138,55 @@
         Indices of sorted points.
     """
     cdef int n_points = points.shape[0]
     cdef double *angles = <double *>malloc(n_points * sizeof(double))
 
     try:
         _calc_spoke_angles(&hub[0], &points[0, 0], n_points, angles)
-        argsort(angles, n_points, &out[0])
+        argsort_flt(angles, n_points, &out[0])
     finally:
-      free(angles)
+        free(angles)
 
     return out
 
 
 @cython.boundscheck(False)
-def argsort_spokes_at_wheel(np.ndarray[long, ndim=1, mode="c"] spokes_at_wheel,
-                            np.ndarray[long, ndim=1, mode="c"] offset_to_wheel,
-                            np.ndarray[double, ndim=2, mode="c"] xy_of_hub,
-                            np.ndarray[double, ndim=2, mode="c"] xy_of_spoke,
-                            np.ndarray[int, ndim=1, mode="c"] ordered):
+def argsort_spokes_at_wheel(
+    np.ndarray[long, ndim=1, mode="c"] spokes_at_wheel,
+    np.ndarray[long, ndim=1, mode="c"] offset_to_wheel,
+    np.ndarray[double, ndim=2, mode="c"] xy_of_hub,
+    np.ndarray[double, ndim=2, mode="c"] xy_of_spoke,
+    np.ndarray[int, ndim=1, mode="c"] ordered,
+):
     cdef int n_wheels = len(offset_to_wheel) - 1
     cdef int i
     cdef int n_spokes
     cdef long * wheel
     cdef int * order
 
     wheel = &spokes_at_wheel[0]
     order = &ordered[0]
     for i in range(n_wheels):
         n_spokes = offset_to_wheel[i + 1] - offset_to_wheel[i]
 
-        _argsort_spokes_around_hub(wheel, n_spokes, &xy_of_spoke[0, 0],
-                                   &xy_of_hub[i, 0], order)
+        _argsort_spokes_around_hub(
+            wheel, n_spokes, &xy_of_spoke[0, 0], &xy_of_hub[i, 0], order
+        )
 
         order += n_spokes
         wheel += n_spokes
 
 
 @cython.boundscheck(False)
-def sort_spokes_at_wheel(np.ndarray[long, ndim=1, mode="c"] spokes_at_wheel,
-                         np.ndarray[long, ndim=1, mode="c"] offset_to_wheel,
-                         np.ndarray[double, ndim=2, mode="c"] xy_of_hub,
-                         np.ndarray[double, ndim=2, mode="c"] xy_of_spoke):
+def sort_spokes_at_wheel(
+    np.ndarray[long, ndim=1, mode="c"] spokes_at_wheel,
+    np.ndarray[long, ndim=1, mode="c"] offset_to_wheel,
+    np.ndarray[double, ndim=2, mode="c"] xy_of_hub,
+    np.ndarray[double, ndim=2, mode="c"] xy_of_spoke,
+):
     """Sort spokes about multiple hubs.
 
     Parameters
     ----------
     spokes_at_wheel : ndarray of int
         Spokes for each wheel.
     offset_to_wheel : ndarray of int
@@ -197,10 +209,9 @@
         n_spokes = offset_to_wheel[i + 1] - offset_to_wheel[i]
         # n_spokes = spokes_per_wheel[i]
         for spoke in range(n_spokes):
             if wheel[spoke] == -1:
                 n_spokes = spoke
                 break
 
-        _sort_spokes_around_hub(wheel, n_spokes, &xy_of_spoke[0, 0],
-                                &xy_of_hub[i, 0])
+        _sort_spokes_around_hub(wheel, n_spokes, &xy_of_spoke[0, 0], &xy_of_hub[i, 0])
         # wheel += n_spokes
```

### Comparing `landlab-2.7.0/landlab/graph/sort/intpair.py` & `landlab-2.8.0/landlab/graph/sort/intpair.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 import numpy as np
 
+from .ext.remap_element import map_pairs_to_values as _map_pairs_to_values
 from .ext.remap_element import (
-    map_pairs_to_values as _map_pairs_to_values,
     map_rolling_pairs_to_values as _map_rolling_pairs_to_values,
-    pair_isin as _pair_isin,
 )
+from .ext.remap_element import pair_isin as _pair_isin
 
 
 def pair_isin(src, pairs, out=None, sorter=None, sorted=False):
     """Check if integer-pairs are contained in source set.
 
     Parameters
     ----------
```

### Comparing `landlab-2.7.0/landlab/graph/sort/sort.py` & `landlab-2.8.0/landlab/graph/sort/sort.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,17 +2,19 @@
 
 This module provides functions that sort the elements of a graph
 structure.
 """
 
 import numpy as np
 
-from ...core.utils import argsort_points_by_x_then_y, as_id_array
+from ...core.utils import argsort_points_by_x_then_y
+from ...core.utils import as_id_array
 from ...utils.jaggedarray import flatten_jagged_array
-from .ext.spoke_sort import sort_spokes_at_wheel
+from ..quantity.ext.of_element import mean_of_children_at_parent
+from .ext.argsort import sort_id_array
 
 
 def remap(src, mapping, out=None, inplace=False):
     """Remap elements in an id array.
 
     Parameters
     ----------
@@ -199,24 +201,39 @@
     ... )
     >>> nodes_at_link = np.array([[0, 1], [1, 2], [2, 3], [3, 0], [2, 4], [3, 4]])
     >>> links_at_patch = np.array([[0, 1, 3, 2], [2, 4, 5, -1]])
     >>> sort_links_at_patch(links_at_patch, nodes_at_link, xy_of_node)
     >>> links_at_patch
     array([[ 2,  1,  0,  3],
            [ 4,  2,  5, -1]])
+
+    >>> xy_of_node = np.array(
+    ...     [
+    ...         [0.0, 0.0],
+    ...         [0.0, 1.0],
+    ...         [1.0, 1.0],
+    ...         [1.0, 0.0],
+    ...         [2.0, 1.0],
+    ...     ]
+    ... )
+    >>> nodes_at_link = np.array([[0, 1], [1, 2], [2, 3], [3, 0], [2, 4], [3, 4]])
+    >>> links_at_patch = np.array([[0, 1, 3, 2], [2, -1, 4, 5]])
+    >>> sort_links_at_patch(links_at_patch, nodes_at_link, xy_of_node)
+    >>> links_at_patch
+    array([[ 2,  1,  0,  3],
+           [ 4,  2,  5, -1]])
     """
     xy_of_link = np.mean(xy_of_node[nodes_at_link], axis=1)
 
-    xy_of_patch = np.mean(xy_of_link[links_at_patch], axis=1)
+    xy_of_patch = np.empty((len(links_at_patch), 2), dtype=float)
 
-    offset_to_wheel = np.arange(links_at_patch.shape[0] + 1) * links_at_patch.shape[1]
+    mean_of_children_at_parent(links_at_patch, xy_of_link[:, 0], xy_of_patch[:, 0])
+    mean_of_children_at_parent(links_at_patch, xy_of_link[:, 1], xy_of_patch[:, 1])
 
-    sort_spokes_at_wheel(
-        links_at_patch.reshape((-1,)), offset_to_wheel, xy_of_patch, xy_of_link
-    )
+    sort_spokes_at_hub(links_at_patch, xy_of_patch, xy_of_link, inplace=True)
 
 
 def reindex_by_xy(graph):
     sorted_nodes = reindex_nodes_by_xy(graph)
 
     if "nodes_at_link" in graph.ds:
         sorted_links = reindex_links_by_xy(graph)
@@ -331,17 +348,17 @@
     >>> x = np.array([1.0, 2.0, 2.0, 0.0, 1.0, 0.0])
     >>> y = np.array([0.0, 0.0, 1.0, 0.0, 1.0, 1.0])
 
     Sort a graph with just points - no links or patches.
 
     >>> _ = sort_graph((y, x))
     >>> y
-    array([ 0.,  0.,  0.,  1.,  1.,  1.])
+    array([0., 0., 0., 1., 1., 1.])
     >>> x
-    array([ 0.,  1.,  2.,  0.,  1.,  2.])
+    array([0., 1., 2., 0., 1., 2.])
 
     Sort the points and links of a graph.
 
     >>> x = np.array([1.0, 2.0, 2.0, 0.0, 1.0, 0.0])
     >>> y = np.array([0.0, 0.0, 1.0, 0.0, 1.0, 1.0])
     >>> links = np.array(
     ...     [[3, 0], [0, 4], [4, 5], [5, 3], [0, 1], [1, 2], [2, 0], [2, 4]]
@@ -424,17 +441,17 @@
     >>> from landlab.graph.sort import sort_nodes
     >>> import numpy as np
     >>> x = np.array([0.0, 1.0, 2.0])
     >>> y = np.array([0.5, 0.0, 1.0])
     >>> sort_nodes((y, x))
     array([1, 0, 2])
     >>> x
-    array([ 1.,  0.,  2.])
+    array([1., 0., 2.])
     >>> y
-    array([ 0. ,  0.5,  1. ])
+    array([0. , 0.5, 1. ])
     """
     sorted_nodes = argsort_points_by_x_then_y((nodes[1], nodes[0]))
     nodes[0][:] = nodes[0][sorted_nodes]
     nodes[1][:] = nodes[1][sorted_nodes]
 
     return sorted_nodes
 
@@ -513,15 +530,16 @@
     >>> sort_patches(links_at_patch, offset_to_patch, xy_of_link)
     array([1, 0])
     >>> links_at_patch
     array([3, 2, 4, 0, 1, 2])
     >>> offset_to_patch
     array([0, 3, 6])
     """
-    from .ext.remap_element import calc_center_of_patch, reorder_patches
+    from .ext.remap_element import calc_center_of_patch
+    from .ext.remap_element import reorder_patches
 
     n_patches = len(offset_to_patch) - 1
     xy_at_patch = np.empty((n_patches, 2), dtype=float)
 
     calc_center_of_patch(links_at_patch, offset_to_patch, xy_of_link, xy_at_patch)
 
     sorted_patches = argsort_points_by_x_then_y(xy_at_patch)
@@ -690,22 +708,28 @@
         spokes_at_hub, xy_of_hub, xy_of_spoke, badval=badval
     )
 
     return angle_of_spoke
 
 
 def sort_spokes_at_hub(spokes_at_hub, xy_of_hub, xy_of_spokes, inplace=False):
-    sorted_spokes = argsort_spokes_at_hub(spokes_at_hub, xy_of_hub, xy_of_spokes)
-
     if inplace:
         out = spokes_at_hub
     else:
         out = np.empty_like(spokes_at_hub)
 
-    return np.take(spokes_at_hub, sorted_spokes, out=out)
+    dx = np.subtract(xy_of_spokes[:, 0][spokes_at_hub], xy_of_hub[:, 0, None])
+    dy = np.subtract(xy_of_spokes[:, 1][spokes_at_hub], xy_of_hub[:, 1, None])
+
+    angle_of_spoke_at_hub = np.arctan2(dy, dx, where=spokes_at_hub != -1)
+    angle_of_spoke_at_hub[angle_of_spoke_at_hub < 0.0] += np.pi * 2.0
+
+    sort_id_array(spokes_at_hub, angle_of_spoke_at_hub, out)
+
+    return out
 
 
 def argsort_spokes_at_hub(spokes_at_hub, xy_of_hub, xy_of_spokes):
     angles = calc_angle_of_spoke(spokes_at_hub, xy_of_hub, xy_of_spokes, badval=np.inf)
     angles[angles < 0] += np.pi
 
     n_hubs, n_spokes = angles.shape
```

### Comparing `landlab-2.7.0/landlab/graph/structured_quad/dual_structured_quad.py` & `landlab-2.8.0/landlab/graph/structured_quad/dual_structured_quad.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,13 @@
 import numpy as np
 
 from ..dual import DualGraph
-from .structured_quad import (
-    RectilinearGraph,
-    StructuredQuadGraph,
-    UniformRectilinearGraph,
-)
+from .structured_quad import RectilinearGraph
+from .structured_quad import StructuredQuadGraph
+from .structured_quad import UniformRectilinearGraph
 
 
 class DualStructuredQuadGraph(DualGraph, StructuredQuadGraph):
     """Dual graph of a structured grid of quadrilaterals.
 
     Examples
     --------
@@ -18,15 +16,15 @@
     >>> node_x = [0, 1, 2, 0, 2, 3, 0, 1, 2]
     >>> graph = DualStructuredQuadGraph((node_y, node_x), shape=(3, 3), sort=True)
     >>> graph.number_of_corners == 4
     True
     >>> graph.y_of_corner
     array([-1.25, -0.75,  0.75,  1.25])
     >>> graph.x_of_corner
-    array([ 2.  ,  0.75,  0.75,  2.  ])
+    array([2.  , 0.75, 0.75, 2.  ])
     >>> graph.node_at_cell
     array([4])
     """
 
     def __init__(self, node_y_and_x, shape=None, sort=True):
         StructuredQuadGraph.__init__(self, node_y_and_x, shape=shape)
 
@@ -104,27 +102,26 @@
         nodes_at_face = np.empty((n_faces, 2), dtype=int)
         fill_nodes_at_face(shape, nodes_at_face)
 
         return nodes_at_face
 
 
 class DualRectilinearGraph(DualGraph, RectilinearGraph):
-
     """Create a dual graph for a rectilinear grid.
 
     Examples
     --------
     >>> from landlab.graph import DualRectilinearGraph
     >>> graph = DualRectilinearGraph(([0, 1, 3], [0, 5, 15, 30]))
     >>> graph.x_of_corner.reshape((2, 3))
     array([[  2.5,  10. ,  22.5],
            [  2.5,  10. ,  22.5]])
     >>> graph.y_of_corner.reshape((2, 3))
-    array([[ 0.5,  0.5,  0.5],
-           [ 2. ,  2. ,  2. ]])
+    array([[0.5, 0.5, 0.5],
+           [2. , 2. , 2. ]])
     >>> graph.number_of_cells == 2
     True
     >>> graph.faces_at_cell
     array([[3, 5, 2, 0],
            [4, 6, 3, 1]])
     """
 
@@ -149,29 +146,28 @@
         return (
             (y_of_node[1:] + y_of_node[:-1]) * 0.5,
             (x_of_node[1:] + x_of_node[:-1]) * 0.5,
         )
 
 
 class DualUniformRectilinearGraph(DualGraph, UniformRectilinearGraph):
-
     """Create a dual graph for a uniform rectilinear grid.
 
     Examples
     --------
     >>> from landlab.graph import DualUniformRectilinearGraph
     >>> graph = DualUniformRectilinearGraph((4, 3))
     >>> graph.x_of_corner.reshape((3, 2))
-    array([[ 0.5,  1.5],
-           [ 0.5,  1.5],
-           [ 0.5,  1.5]])
+    array([[0.5, 1.5],
+           [0.5, 1.5],
+           [0.5, 1.5]])
     >>> graph.y_of_corner.reshape((3, 2))
-    array([[ 0.5,  0.5],
-           [ 1.5,  1.5],
-           [ 2.5,  2.5]])
+    array([[0.5, 0.5],
+           [1.5, 1.5],
+           [2.5, 2.5]])
     >>> graph.number_of_cells == 2
     True
     >>> graph.faces_at_cell
     array([[2, 3, 1, 0],
            [5, 6, 4, 3]])
     """
```

### Comparing `landlab-2.7.0/landlab/graph/structured_quad/ext/at_cell.pyx` & `landlab-2.8.0/landlab/graph/structured_quad/ext/at_cell.pyx`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/graph/structured_quad/ext/at_face.pyx` & `landlab-2.8.0/landlab/graph/structured_quad/ext/at_face.pyx`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/graph/structured_quad/ext/at_link.pyx` & `landlab-2.8.0/landlab/graph/structured_quad/ext/at_link.pyx`

 * *Files 5% similar despite different names*

```diff
@@ -96,15 +96,14 @@
 @cython.boundscheck(False)
 def fill_nodes_at_link(shape, np.ndarray[DTYPE_t, ndim=2] nodes_at_link):
     cdef int row, col
     cdef int link
     cdef int node
     cdef int n_rows = shape[0]
     cdef int n_cols = shape[1]
-    cdef int n_links = (2 * n_cols - 1) * n_rows - n_cols
     cdef int links_per_row = 2 * n_cols - 1
 
     # Horizontal links
     for row in range(n_rows):
         node = row * n_cols
         link = row * links_per_row
         for col in range(n_cols - 1):
```

### Comparing `landlab-2.7.0/landlab/graph/structured_quad/ext/at_node.pyx` & `landlab-2.8.0/landlab/graph/structured_quad/ext/at_node.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -130,15 +130,14 @@
 
 @cython.boundscheck(False)
 def fill_links_at_node(shape, np.ndarray[DTYPE_t, ndim=2] links_at_node):
     cdef int n_rows = shape[0]
     cdef int n_cols = shape[1]
     cdef int n_nodes = n_rows * n_cols
     cdef int links_per_row = 2 * n_cols - 1
-    cdef int patches_per_row = n_cols - 1
 
     # Bottom nodes
     link = 0
     for node in range(1, n_cols - 1):
         links_at_node[node, 0] = link + 1
         links_at_node[node, 1] = link + n_cols
         links_at_node[node, 2] = link
@@ -216,16 +215,14 @@
 
 @cython.boundscheck(False)
 def fill_link_dirs_at_node(shape,
                            np.ndarray[INT8TYPE_t, ndim=2] link_dirs_at_node):
     cdef int n_rows = shape[0]
     cdef int n_cols = shape[1]
     cdef int n_nodes = n_rows * n_cols
-    cdef int links_per_row = 2 * n_cols - 1
-    cdef int patches_per_row = n_cols - 1
 
     # Bottom nodes
     for node in range(1, n_cols - 1):
         link_dirs_at_node[node, 0] = - 1
         link_dirs_at_node[node, 1] = - 1
         link_dirs_at_node[node, 2] = 1
         link_dirs_at_node[node, 3] = 0
```

### Comparing `landlab-2.7.0/landlab/graph/structured_quad/ext/at_patch.pyx` & `landlab-2.8.0/landlab/graph/structured_quad/ext/at_patch.pyx`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/graph/structured_quad/structured_quad.py` & `landlab-2.8.0/landlab/graph/structured_quad/structured_quad.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-from abc import ABC, abstractmethod
+from abc import ABC
+from abc import abstractmethod
 from functools import cached_property
 
 import numpy as np
 
 from ...grid.linkorientation import LinkOrientation
 from ...utils.decorators import read_only_array
 from ..graph import Graph
@@ -12,56 +13,47 @@
     @staticmethod
     def corner_nodes(shape):
         n_rows, n_cols = shape
         return (n_rows * n_cols - 1, (n_rows - 1) * n_cols, 0, n_cols - 1)
 
     @staticmethod
     @abstractmethod
-    def links_at_patch(shape):
-        ...
+    def links_at_patch(shape): ...
 
     @staticmethod
     @abstractmethod
-    def nodes_at_link(shape):
-        ...
+    def nodes_at_link(shape): ...
 
     @staticmethod
     @abstractmethod
-    def horizontal_links(shape):
-        ...
+    def horizontal_links(shape): ...
 
     @staticmethod
     @abstractmethod
-    def vertical_links(shape):
-        ...
+    def vertical_links(shape): ...
 
     @staticmethod
     @abstractmethod
-    def perimeter_nodes(shape):
-        ...
+    def perimeter_nodes(shape): ...
 
     @staticmethod
     @abstractmethod
-    def links_at_node(shape):
-        ...
+    def links_at_node(shape): ...
 
     @staticmethod
     @abstractmethod
-    def patches_at_link(shape):
-        ...
+    def patches_at_link(shape): ...
 
     @staticmethod
     @abstractmethod
-    def link_dirs_at_node(shape):
-        ...
+    def link_dirs_at_node(shape): ...
 
     @staticmethod
     @abstractmethod
-    def patches_at_node(shape):
-        ...
+    def patches_at_node(shape): ...
 
 
 class StructuredQuadLayoutCython(StructuredQuadLayout):
     @staticmethod
     def links_at_patch(shape):
         """Get links that define patches for a raster grid.
 
@@ -654,33 +646,32 @@
         if node_y.shape != node_x.shape:
             raise ValueError("shape mismatch in node x and y coordinates")
 
         return (node_y, node_x)
 
 
 class RectilinearGraph(StructuredQuadGraphExtras):
-
     """Graph of a rectlinear grid of nodes.
 
     Examples
     --------
     >>> from landlab.graph import RectilinearGraph
     >>> graph = RectilinearGraph(([0, 1, 2, 3], [1, 4, 8]))
     >>> graph.number_of_nodes
     12
     >>> graph.y_of_node.reshape(graph.shape)
-    array([[ 0.,  0.,  0.],
-           [ 1.,  1.,  1.],
-           [ 2.,  2.,  2.],
-           [ 3.,  3.,  3.]])
+    array([[0., 0., 0.],
+           [1., 1., 1.],
+           [2., 2., 2.],
+           [3., 3., 3.]])
     >>> graph.x_of_node.reshape(graph.shape)
-    array([[ 1.,  4.,  8.],
-           [ 1.,  4.,  8.],
-           [ 1.,  4.,  8.],
-           [ 1.,  4.,  8.]])
+    array([[1., 4., 8.],
+           [1., 4., 8.],
+           [1., 4., 8.],
+           [1., 4., 8.]])
     """
 
     def __init__(self, nodes, sort=False):
         rows = np.asarray(nodes[0], dtype=float)
         cols = np.asarray(nodes[1], dtype=float)
         node_y_and_x = np.meshgrid(rows, cols, indexing="ij")
 
@@ -691,33 +682,32 @@
         rows = np.asarray(coords[0], dtype=float)
         cols = np.asarray(coords[1], dtype=float)
 
         return np.meshgrid(rows, cols, indexing="ij")
 
 
 class UniformRectilinearGraph(StructuredQuadGraphExtras):
-
     """Graph of a structured grid of quadrilaterals.
 
     Examples
     --------
     >>> from landlab.graph import UniformRectilinearGraph
     >>> graph = UniformRectilinearGraph((4, 3), spacing=(1, 2), origin=(-1, 0))
     >>> graph.number_of_nodes
     12
     >>> graph.y_of_node.reshape(graph.shape)
     array([[-1., -1., -1.],
            [ 0.,  0.,  0.],
            [ 1.,  1.,  1.],
            [ 2.,  2.,  2.]])
     >>> graph.x_of_node.reshape(graph.shape)
-    array([[ 0.,  2.,  4.],
-           [ 0.,  2.,  4.],
-           [ 0.,  2.,  4.],
-           [ 0.,  2.,  4.]])
+    array([[0.,  2.,  4.],
+           [0.,  2.,  4.],
+           [0.,  2.,  4.],
+           [0.,  2.,  4.]])
     >>> graph.links_at_node
     array([[ 0,  2, -1, -1], [ 1,  3,  0, -1], [-1,  4,  1, -1],
            [ 5,  7, -1,  2], [ 6,  8,  5,  3], [-1,  9,  6,  4],
            [10, 12, -1,  7], [11, 13, 10,  8], [-1, 14, 11,  9],
            [15, -1, -1, 12], [16, -1, 15, 13], [-1, -1, 16, 14]])
     >>> graph.link_dirs_at_node
     array([[-1, -1,  0,  0], [-1, -1,  1,  0], [ 0, -1,  1,  0],
```

### Comparing `landlab-2.7.0/landlab/graph/ugrid.py` & `landlab-2.8.0/landlab/graph/ugrid.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/graph/voronoi/dual_voronoi.py` & `landlab-2.8.0/landlab/graph/voronoi/dual_voronoi.py`

 * *Files 1% similar despite different names*

```diff
@@ -20,19 +20,19 @@
         Examples
         --------
         >>> from landlab.graph import DualVoronoiGraph
         >>> node_x = [0, 1, 2, 3, 0.2, 1.2, 2.2, 3.2, 0.4, 1.4, 2.4, 3.4]
         >>> node_y = [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]
         >>> graph = DualVoronoiGraph((node_y, node_x), sort=True)
         >>> graph.x_of_corner
-        array([ 0.5,  1.5,  2.5,  0.7,  1.7,  2.7,  0.7,  1.7,  2.7,  0.9,  1.9,
-                2.9])
+        array([0.5,  1.5,  2.5,  0.7,  1.7,  2.7,  0.7,  1.7,  2.7,  0.9,  1.9,
+               2.9])
         >>> graph.y_of_corner
-        array([ 0.42,  0.42,  0.42,  0.58,  0.58,  0.58,  1.42,  1.42,  1.42,
-                1.58,  1.58,  1.58])
+        array([0.42,  0.42,  0.42,  0.58,  0.58,  0.58,  1.42,  1.42,  1.42,
+               1.58,  1.58,  1.58])
         >>> graph.corners_at_face
         array([[ 0,  3], [ 3,  1], [ 1,  4], [ 4,  2], [ 2,  5],
                [ 3,  6], [ 4,  7], [ 5,  8],
                [ 6,  9], [ 9,  7], [ 7, 10], [10,  8], [ 8, 11]])
         >>> graph.faces_at_corner
         array([[ 0, -1, -1], [ 2,  1, -1], [ 4,  3, -1],
                [ 5,  0,  1], [ 6,  2,  3], [ 7,  4, -1],
```

### Comparing `landlab-2.7.0/landlab/graph/voronoi/ext/delaunay.pyx` & `landlab-2.8.0/landlab/graph/voronoi/ext/delaunay.pyx`

 * *Files 6% similar despite different names*

```diff
@@ -5,17 +5,18 @@
 from libc.stdlib cimport free, malloc
 
 DTYPE = int
 ctypedef np.int_t DTYPE_t
 
 
 @cython.boundscheck(False)
-def remove_patches(np.ndarray[DTYPE_t, ndim=2] links_at_patch,
-                   np.ndarray[DTYPE_t, ndim=1] patches_to_remove):
-    cdef int n_bad_patches = len(patches_to_remove)
+def remove_patches(
+    np.ndarray[DTYPE_t, ndim=2] links_at_patch,
+    np.ndarray[DTYPE_t, ndim=1] patches_to_remove,
+):
     cdef int n_patches = links_at_patch.shape[0]
     cdef int max_links = links_at_patch.shape[1]
     cdef int patch
     cdef int n
 
     new_patch = 0
     for patch in range(n_patches):
@@ -24,35 +25,35 @@
         else:
             for n in range(max_links):
                 links_at_patch[new_patch, n] = links_at_patch[patch, n]
             patch += 1
 
 
 @cython.boundscheck(False)
-def remove_tris(np.ndarray[DTYPE_t, ndim=2] nodes_at_tri,
-                np.ndarray[DTYPE_t, ndim=2] neighbors_at_tri,
-                np.ndarray[DTYPE_t, ndim=1] bad_tris):
+def remove_tris(
+    np.ndarray[DTYPE_t, ndim=2] nodes_at_tri,
+    np.ndarray[DTYPE_t, ndim=2] neighbors_at_tri,
+    np.ndarray[DTYPE_t, ndim=1] bad_tris,
+):
     cdef int n_tris = nodes_at_tri.shape[0]
-    cdef int n_bad_tris = len(bad_tris)
-    cdef int n_patches = n_tris - n_bad_tris
     cdef int tri
     cdef int patch
     cdef int *patch_at_tri = <int *>malloc(n_tris * sizeof(int))
     cdef int n
     cdef int old
 
     try:
         patch = 0
         for tri in range(n_tris):
             if tri in bad_tris:
                 patch_at_tri[tri] = -1
             else:
                 for n in range(3):
-                  nodes_at_tri[patch, n] = nodes_at_tri[tri, n]
-                  neighbors_at_tri[patch, n] = neighbors_at_tri[tri, n]
+                    nodes_at_tri[patch, n] = nodes_at_tri[tri, n]
+                    neighbors_at_tri[patch, n] = neighbors_at_tri[tri, n]
                 patch_at_tri[tri] = patch
                 patch += 1
 
         for tri in range(n_tris):
             for n in range(3):
                 old = neighbors_at_tri[tri, n]
                 if old >= 0:
@@ -60,48 +61,51 @@
                 else:
                     neighbors_at_tri[tri, n] = -1
     finally:
         free(patch_at_tri)
 
 
 @cython.boundscheck(False)
-def _setup_links_at_patch(np.ndarray[DTYPE_t, ndim=2] nodes_at_patch,
-                          np.ndarray[DTYPE_t, ndim=2] tri_neighbors,
-                          np.ndarray[DTYPE_t, ndim=2] nodes_at_link,
-                          np.ndarray[DTYPE_t, ndim=2] links_at_patch):
-  cdef int i
-  cdef int link
-  cdef int neighbor
-  cdef int n_patches = len(nodes_at_patch)
-  cdef int *tri_done = <int *>malloc(n_patches * sizeof(int))
-  cdef int *links_per_patch = <int *>malloc(n_patches * sizeof(int))
-
-  if not tri_done or not links_per_patch:
-    raise MemoryError(
-      'unable to allocate {bytes} bytes'.format(bytes=n_patches * sizeof(int)))
-
-  try:
-    for tri in range(n_patches):
-      tri_done[tri] = 0
-      links_per_patch[tri] = 0
-
-    link = 0
-    for tri in range(n_patches):
-      for i in (0, 1, 2):
-        neighbor = tri_neighbors[tri, i]
-
-        if neighbor == -1 or not tri_done[neighbor]:
-          nodes_at_link[link, 0] = nodes_at_patch[tri, (i + 1) % 3]
-          nodes_at_link[link, 1] = nodes_at_patch[tri, (i + 2) % 3]
-
-          links_at_patch[tri, links_per_patch[tri]] = link
-          links_per_patch[tri] += 1
-
-          if neighbor >= 0:
-            links_at_patch[neighbor, links_per_patch[neighbor]] = link
-            links_per_patch[neighbor] += 1
-            tri_done[tri] = True
-
-          link += 1
-  finally:
-    free(links_per_patch)
-    free(tri_done)
+def _setup_links_at_patch(
+    np.ndarray[DTYPE_t, ndim=2] nodes_at_patch,
+    np.ndarray[DTYPE_t, ndim=2] tri_neighbors,
+    np.ndarray[DTYPE_t, ndim=2] nodes_at_link,
+    np.ndarray[DTYPE_t, ndim=2] links_at_patch,
+):
+    cdef int i
+    cdef int link
+    cdef int neighbor
+    cdef int n_patches = len(nodes_at_patch)
+    cdef int *tri_done = <int *>malloc(n_patches * sizeof(int))
+    cdef int *links_per_patch = <int *>malloc(n_patches * sizeof(int))
+
+    if not tri_done or not links_per_patch:
+        raise MemoryError(
+            "unable to allocate {bytes} bytes".format(bytes=n_patches * sizeof(int))
+        )
+
+    try:
+        for tri in range(n_patches):
+            tri_done[tri] = 0
+            links_per_patch[tri] = 0
+
+        link = 0
+        for tri in range(n_patches):
+            for i in (0, 1, 2):
+                neighbor = tri_neighbors[tri, i]
+
+                if neighbor == -1 or not tri_done[neighbor]:
+                    nodes_at_link[link, 0] = nodes_at_patch[tri, (i + 1) % 3]
+                    nodes_at_link[link, 1] = nodes_at_patch[tri, (i + 2) % 3]
+
+                    links_at_patch[tri, links_per_patch[tri]] = link
+                    links_per_patch[tri] += 1
+
+                    if neighbor >= 0:
+                        links_at_patch[neighbor, links_per_patch[neighbor]] = link
+                        links_per_patch[neighbor] += 1
+                        tri_done[tri] = True
+
+                    link += 1
+    finally:
+        free(links_per_patch)
+        free(tri_done)
```

### Comparing `landlab-2.7.0/landlab/graph/voronoi/ext/voronoi.pyx` & `landlab-2.8.0/landlab/graph/voronoi/ext/voronoi.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -32,18 +32,20 @@
         out[cell] = _id_array_contains(
             &corners_at_cell[cell, 0],
             n_corners_at_cell[cell],
             bad_val,
         )
 
 
-def _is_finite_region(np.ndarray[DTYPE_t, ndim=1] vertices_at_region,
-                      np.ndarray[DTYPE_t, ndim=1] vertices_per_region,
-                      np.ndarray[DTYPE_t, ndim=1] is_finite_region,
-                      DTYPE_t min_patch_size):
+def _is_finite_region(
+    np.ndarray[DTYPE_t, ndim=1] vertices_at_region,
+    np.ndarray[DTYPE_t, ndim=1] vertices_per_region,
+    np.ndarray[DTYPE_t, ndim=1] is_finite_region,
+    DTYPE_t min_patch_size,
+):
     """Test if each region if finite.
 
     Parameters
     ----------
     vertices_at_region : ndarray of int
         Indices of the Voronoi vertices forming each Voronoi region.
     vertices_per_region : ndarray of int, shape `(n_regions, )`
@@ -68,18 +70,20 @@
                 vertex = vertices_at_region[offset + i]
                 if vertex == -1:
                     is_finite_region[region] = 0
                     break
         offset += n_vertices
 
 
-def _get_neighbor_regions(np.ndarray[DTYPE_t, ndim=2] ridge_points,
-                          np.ndarray[DTYPE_t, ndim=1] point_region,
-                          np.ndarray[DTYPE_t, ndim=1] is_finite_region,
-                          np.ndarray[DTYPE_t, ndim=2] regions_at_ridge):
+def _get_neighbor_regions(
+    np.ndarray[DTYPE_t, ndim=2] ridge_points,
+    np.ndarray[DTYPE_t, ndim=1] point_region,
+    np.ndarray[DTYPE_t, ndim=1] is_finite_region,
+    np.ndarray[DTYPE_t, ndim=2] regions_at_ridge,
+):
     """Get voronoi regions on either side of ridges.
 
     Parameters
     ----------
     ridge_points : ndarray of int, shape `(n_points, 2)`
         Indices of the points between which each Voronoi ridge lies (as
         provided by the `scipy.spatial.Voronoi` class).
@@ -102,17 +106,19 @@
             if is_finite_region[region]:
                 regions_at_ridge[ridge, i] = region
             else:
                 regions_at_ridge[ridge, i] = -1
 
 
 @cython.boundscheck(False)
-def _get_cell_at_region(np.ndarray[DTYPE_t, ndim=2] regions_at_ridge,
-                        np.ndarray[DTYPE_t, ndim=2] ridges_at_cell,
-                        np.ndarray[DTYPE_t, ndim=1] cell_at_region):
+def _get_cell_at_region(
+    np.ndarray[DTYPE_t, ndim=2] regions_at_ridge,
+    np.ndarray[DTYPE_t, ndim=2] ridges_at_cell,
+    np.ndarray[DTYPE_t, ndim=1] cell_at_region,
+):
     """Get cell corresponding to each voronoi region.
 
     Parameters
     ----------
     regions_at_ridge : ndarray of int, shape `(n_regions, 2)`
         Indices of the voronoi regions on either side of each ridge.
     ridges_at_cell : ndarray of int, shape `(n_cells, 2)`
@@ -126,15 +132,15 @@
     cdef int cell
     cdef int region
     cdef int n_cells = 0
     cdef int n_ridges = len(regions_at_ridge)
     cdef int *ridges_per_cell = <int *>malloc(n_ridges * sizeof(int))
 
     if not ridges_per_cell:
-        raise MemoryError('unable to allocate {bytes} bytes'.format(
+        raise MemoryError("unable to allocate {bytes} bytes".format(
             bytes=n_ridges * sizeof(int)))
 
     try:
         for ridge in range(n_ridges):
             ridges_per_cell[ridge] = 0
 
         for region in range(cell_at_region.shape[0]):
@@ -159,17 +165,19 @@
     finally:
         free(ridges_per_cell)
 
     return n_cells
 
 
 @cython.boundscheck(False)
-def _get_faces_at_cell(np.ndarray[DTYPE_t, ndim=2] ridges_at_cell,
-                       np.ndarray[DTYPE_t, ndim=2] faces_at_cell,
-                       np.ndarray[DTYPE_t, ndim=1] face_at_ridge):
+def _get_faces_at_cell(
+    np.ndarray[DTYPE_t, ndim=2] ridges_at_cell,
+    np.ndarray[DTYPE_t, ndim=2] faces_at_cell,
+    np.ndarray[DTYPE_t, ndim=1] face_at_ridge,
+):
     """Get faces that define each cell.
 
     Parameters
     ----------
     ridges_at_cell : ndarray of int, shape `(n_cells, max_ridges)`
         Indices of the voronoi ridges that define each cell. Cells with less
         than `max_ridges` ridges are padded with -1.
@@ -197,29 +205,31 @@
     for cell in range(n_cells):
         for i in range(max_faces_per_cell):
             ridge = ridges_at_cell[cell, i]
             if ridge >= 0:
                 face = face_at_ridge[ridge]
 
                 if face == -1:
-                  face_at_ridge[ridge] = n_faces
-                  n_faces += 1
+                    face_at_ridge[ridge] = n_faces
+                    n_faces += 1
                 face = face_at_ridge[ridge]
 
                 faces_at_cell[cell, i] = face
                 face_at_ridge[ridge] = face
             else:
                 faces_at_cell[cell, i] = -1
 
 
 @cython.boundscheck(False)
-def _get_corners_at_face(np.ndarray[DTYPE_t, ndim=1] face_at_ridge,
-                         np.ndarray[DTYPE_t, ndim=2] vertices_at_ridge,
-                         np.ndarray[DTYPE_t, ndim=1] corner_at_vertex,
-                         np.ndarray[DTYPE_t, ndim=2] corners_at_face):
+def _get_corners_at_face(
+    np.ndarray[DTYPE_t, ndim=1] face_at_ridge,
+    np.ndarray[DTYPE_t, ndim=2] vertices_at_ridge,
+    np.ndarray[DTYPE_t, ndim=1] corner_at_vertex,
+    np.ndarray[DTYPE_t, ndim=2] corners_at_face,
+):
     """Get corners for each face.
 
     Parameters
     ----------
     face_at_ridge : ndarray of int, shape `(n_ridges, )`
         ID of the face corresponding to each ridge (-1 for ridges without
         a face). A ridge will not have a face if it is appears only in infinite
@@ -230,38 +240,37 @@
     corner_at_vertex : ndarray of int, shape `(n_vertices, )`
         Output buffer. ID of corner corresponding to each voronoi vertex.
     corners_at_face : ndarray of int, shape `(n_vertices, 2)`
         Output buffer. IDs of two corners that define each face.
     """
     cdef int i
     cdef int ridge
-    cdef int corner
     cdef int vertex
     cdef int face
     cdef int n_ridges = len(face_at_ridge)
     cdef int n_vertices = len(corner_at_vertex)
     cdef int n_faces = len(corners_at_face)
     cdef int n_corners = 0
 
     for vertex in range(n_vertices):
-      corner_at_vertex[vertex] = -1
+        corner_at_vertex[vertex] = -1
 
     for face in range(n_faces):
-      for i in range(2):
-        corners_at_face[face, i] = -1
+        for i in range(2):
+            corners_at_face[face, i] = -1
 
     for ridge in range(n_ridges):
         for i in range(2):
             vertex = vertices_at_ridge[ridge, i]
             if vertex >= 0 and face_at_ridge[ridge] >= 0:
-              if corner_at_vertex[vertex] == -1:
-                  corner_at_vertex[vertex] = n_corners
-                  n_corners += 1
+                if corner_at_vertex[vertex] == -1:
+                    corner_at_vertex[vertex] = n_corners
+                    n_corners += 1
 
-              corners_at_face[face_at_ridge[ridge], i] = corner_at_vertex[vertex]
+                corners_at_face[face_at_ridge[ridge], i] = corner_at_vertex[vertex]
 
 
 @cython.boundscheck(False)
 def _get_xy_at_corners(np.ndarray[np.double_t, ndim=2] vertices,
                        np.ndarray[DTYPE_t, ndim=1] corner_at_vertex,
                        np.ndarray[np.double_t, ndim=2] xy_at_corner):
     """Get x and y coordinates for each corner.
@@ -281,23 +290,25 @@
     cdef int corner
     cdef int n_vertices = len(vertices)
 
     for vertex in range(n_vertices):
         corner = corner_at_vertex[vertex]
 
         if corner >= 0:
-          xy_at_corner[corner, 0] = vertices[vertex, 0]
-          xy_at_corner[corner, 1] = vertices[vertex, 1]
+            xy_at_corner[corner, 0] = vertices[vertex, 0]
+            xy_at_corner[corner, 1] = vertices[vertex, 1]
 
 
 @cython.boundscheck(False)
-def _get_node_at_cell(np.ndarray[DTYPE_t, ndim=2] ridge_points,
-                      np.ndarray[DTYPE_t, ndim=1] point_region,
-                      np.ndarray[DTYPE_t, ndim=1] cell_at_region,
-                      np.ndarray[DTYPE_t, ndim=1] node_at_cell):
+def _get_node_at_cell(
+    np.ndarray[DTYPE_t, ndim=2] ridge_points,
+    np.ndarray[DTYPE_t, ndim=1] point_region,
+    np.ndarray[DTYPE_t, ndim=1] cell_at_region,
+    np.ndarray[DTYPE_t, ndim=1] node_at_cell,
+):
     """Get node-to-cell connectivity.
 
     Parameters
     ----------
     ridge_points : ndarray of int, shape `(n_ridges, 2)`
         Indices of the points between which each Voronoi ridge lies (as
         provided by the `scipy.spatial.Voronoi` class).
```

### Comparing `landlab-2.7.0/landlab/graph/voronoi/voronoi.py` & `landlab-2.8.0/landlab/graph/voronoi/voronoi.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 import numpy as np
 
 from ..graph import Graph
 from .voronoi_to_graph import VoronoiDelaunayToGraph
 
 
 class DelaunayGraph(Graph):
-
     """Graph of a voronoi grid.
 
     Examples
     --------
     >>> from landlab.graph import DelaunayGraph
     """
 
@@ -26,17 +25,17 @@
         Examples
         --------
         >>> from landlab.graph import DelaunayGraph
         >>> node_x = [0.0, 1.0, 2.0, 0.9, 1.9, 2.9]
         >>> node_y = [0, 0, 0, 2, 2, 2]
         >>> graph = DelaunayGraph((node_y, node_x), sort=True)
         >>> graph.x_of_node
-        array([ 0. ,  1. ,  2. ,  0.9,  1.9,  2.9])
+        array([0. ,  1. ,  2. ,  0.9,  1.9,  2.9])
         >>> graph.y_of_node
-        array([ 0.,  0.,  0.,  2.,  2.,  2.])
+        array([0.,  0.,  0.,  2.,  2.,  2.])
         >>> graph.nodes_at_link
         array([[0, 1], [1, 2],
                [0, 3], [1, 3], [1, 4], [2, 4], [2, 5],
                [3, 4], [4, 5]])
         >>> graph.links_at_node
         array([[ 0,  2, -1, -1], [ 1,  4,  3,  0], [ 6,  5,  1, -1],
                [ 7,  2,  3, -1], [ 8,  7,  4,  5], [ 8,  6, -1, -1]])
```

### Comparing `landlab-2.7.0/landlab/graph/voronoi/voronoi_to_graph.py` & `landlab-2.8.0/landlab/graph/voronoi/voronoi_to_graph.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 import re
 
 import numpy as np
 import xarray as xr
-from scipy.spatial import Delaunay, Voronoi
+from scipy.spatial import Delaunay
+from scipy.spatial import Voronoi
 
 from ...core.utils import as_id_array
 from ...utils import jaggedarray
 from ..sort.intpair import pair_isin
 from ..sort.sort import reverse_one_to_one
 
 
@@ -122,35 +123,35 @@
             for region in empty_regions[::-1]:
                 regions.pop(region)
                 point_region[point_region >= region] -= 1
         return regions, point_region
 
     @property
     def number_of_nodes(self):
-        return self._mesh.dims["node"]
+        return self._mesh.sizes["node"]
 
     @property
     def number_of_links(self):
-        return self._mesh.dims["link"]
+        return self._mesh.sizes["link"]
 
     @property
     def number_of_patches(self):
-        return self._mesh.dims["patch"]
+        return self._mesh.sizes["patch"]
 
     @property
     def number_of_corners(self):
-        return self._mesh.dims["corner"]
+        return self._mesh.sizes["corner"]
 
     @property
     def number_of_faces(self):
-        return self._mesh.dims["face"]
+        return self._mesh.sizes["face"]
 
     @property
     def number_of_cells(self):
-        return self._mesh.dims["cell"]
+        return self._mesh.sizes["cell"]
 
     @property
     def x_of_node(self):
         return self._mesh["x_of_node"].values
 
     @property
     def y_of_node(self):
@@ -271,15 +272,15 @@
         faces_to_drop = np.where(self.is_perimeter_face() & ~self.is_perimeter_link())
 
         unbound_corners = self.corners_at_face[faces_to_drop].reshape((-1,))
 
         return np.unique(unbound_corners[unbound_corners >= 0])
 
     def is_bound_corner(self):
-        corners = np.full(self._mesh.dims["corner"], True)
+        corners = np.full(self._mesh.sizes["corner"], True)
         corners[self.unbound_corners()] = False
 
         return corners
 
     def drop_corners(self, corners):
         if len(corners) == 0:
             return
@@ -320,15 +321,15 @@
             if suffix.search(name):
                 matches.add(name)
         return matches
 
     def drop_element(self, ids, at="node"):
         dropped_ids = np.asarray(ids, dtype=int)
         dropped_ids.sort()
-        is_a_keeper = np.full(self._mesh.dims[at], True)
+        is_a_keeper = np.full(self._mesh.sizes[at], True)
         is_a_keeper[dropped_ids] = False
 
         at_ = {}
         if at in self._mesh.coords:
             x = self._mesh[f"x_of_{at}"].values[is_a_keeper]
             y = self._mesh[f"y_of_{at}"].values[is_a_keeper]
             data = np.arange(len(x))
@@ -341,15 +342,15 @@
                 },
                 dims=(at,),
             )
             self._mesh = self._mesh.drop_vars([f"x_of_{at}", f"y_of_{at}"])
 
         for name in self.ids_with_suffix(at):
             var = self._mesh[name]
-            at_[name] = xr.DataArray(var.values[is_a_keeper], dims=var.dims)
+            at_[name] = xr.DataArray(var.values[is_a_keeper], dims=var.sizes)
 
         self._mesh = self._mesh.drop_vars(list(at_))
         self._mesh.update(at_)
 
         for name in self.ids_with_prefix(at):
             var = self._mesh[name]
             array = var.values.reshape((-1,))
```

### Comparing `landlab-2.7.0/landlab/grid/base.py` & `landlab-2.8.0/landlab/grid/base.py`

 * *Files 3% similar despite different names*

```diff
@@ -19,20 +19,19 @@
 from ..core.utils import add_module_functions_to_class
 from ..field.graph_field import GraphFields
 from ..layers.eventlayers import EventLayersMixIn
 from ..layers.materiallayers import MaterialLayersMixIn
 from ..plot.imshow import ModelGridPlotterMixIn
 from ..utils.decorators import cache_result_in_object
 from . import grid_funcs as gfuncs
-from .decorators import (
-    override_array_setitem_and_reset,
-    return_id_array,
-    return_readonly_id_array,
-)
-from .linkstatus import LinkStatus, set_status_at_link
+from .decorators import override_array_setitem_and_reset
+from .decorators import return_id_array
+from .decorators import return_readonly_id_array
+from .linkstatus import LinkStatus
+from .linkstatus import set_status_at_link
 from .nodestatus import NodeStatus
 
 #: Indicates an index is, in some way, *bad*.
 BAD_INDEX_VALUE = -1
 # DEJH thinks the user should be able to override this value if they want
 
 # Map names grid elements to the ModelGrid attribute that contains the count
@@ -260,15 +259,14 @@
 
     return ax, ay
 
 
 class ModelGrid(
     GraphFields, EventLayersMixIn, MaterialLayersMixIn, ModelGridPlotterMixIn
 ):
-
     """Base class for 2D structured or unstructured grids for numerical models.
 
     The idea is to have at least two inherited
     classes, RasterModelGrid and DelaunayModelGrid, that can create and
     manage grids. To this might be added a GenericModelGrid, which would
     be an unstructured polygonal grid that doesn't necessarily obey or
     understand the Delaunay triangulation, but rather simply accepts
@@ -337,17 +335,17 @@
         ...     - 3
         ...     - 4
         ... xy_spacing: 2
         ... '''
         ... )
         >>> grid = RasterModelGrid.from_file(filelike)
         >>> grid.x_of_node
-        array([ 0.,  2.,  4.,  6.,  0.,  2.,  4.,  6.,  0.,  2.,  4.,  6.])
+        array([0.,  2.,  4.,  6.,  0.,  2.,  4.,  6.,  0.,  2.,  4.,  6.])
         >>> grid.y_of_node
-        array([ 0.,  0.,  0.,  0.,  2.,  2.,  2.,  2.,  4.,  4.,  4.,  4.])
+        array([0.,  0.,  0.,  0.,  2.,  2.,  2.,  2.,  4.,  4.,  4.,  4.])
         """
         params = load_params(file_like)
         return cls.from_dict(params)
 
     @classmethod
     def from_dict(cls, params):
         """Create grid from dictionary.
@@ -359,17 +357,17 @@
 
         Examples
         --------
         >>> from landlab import RasterModelGrid
         >>> params = {"shape": (3, 4), "xy_spacing": 2}
         >>> grid = RasterModelGrid.from_dict(params)
         >>> grid.x_of_node
-        array([ 0.,  2.,  4.,  6.,  0.,  2.,  4.,  6.,  0.,  2.,  4.,  6.])
+        array([0.,  2.,  4.,  6.,  0.,  2.,  4.,  6.,  0.,  2.,  4.,  6.])
         >>> grid.y_of_node
-        array([ 0.,  0.,  0.,  0.,  2.,  2.,  2.,  2.,  4.,  4.,  4.,  4.])
+        array([0.,  0.,  0.,  0.,  2.,  2.,  2.,  2.,  4.,  4.,  4.,  4.])
         """
         return cls(**params)
 
     def __init__(self, **kwds):
         axis_units = kwds.pop("xy_axis_units", "-")
         axis_name = kwds.pop("xy_axis_name", ("x", "y"))
 
@@ -499,15 +497,15 @@
         --------
         >>> from landlab import RasterModelGrid
         >>> grid = RasterModelGrid((3, 4))
         >>> _ = grid.add_full("elevation", 3.0, at="node")
 
         >>> grid.as_dataarray("at_node:elevation")
         <xarray.DataArray 'at_node:elevation' (node: 12)>
-        array([ 3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.])
+        array([3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.,  3.])
         Dimensions without coordinates: node
 
         >>> all(
         ...     grid.as_dataarray("at_node:elevation")
         ...     == grid.as_dataarray("elevation", at="node")
         ... )
         True
@@ -562,23 +560,23 @@
         named "elevation" at both *nodes* and *links*.
 
         >>> _ = grid.add_full("elevation", 3.0, at="node")
         >>> _ = grid.add_full("elevation", 4.0, at="link")
         >>> _ = grid.add_full("temperature", 5.0, at="node")
 
         >>> ds = grid.as_dataset()
-        >>> sorted(ds.dims.items())
+        >>> sorted(ds.sizes.items())
         [('dim', 2), ('link', 17), ('node', 12)]
         >>> sorted([var for var in ds.data_vars if var.startswith("at_")])
         ['at_link:elevation', 'at_node:elevation', 'at_node:temperature']
 
         >>> grid.event_layers.add(1.0, rho=0.5)
 
         >>> ds = grid.as_dataset()
-        >>> sorted(ds.dims.items())
+        >>> sorted(ds.sizes.items())
         [('cell', 2), ('dim', 2), ('layer', 1), ('link', 17), ('node', 12)]
         >>> sorted([var for var in ds.data_vars if var.startswith("at_")])
         ['at_layer_cell:rho', 'at_layer_cell:thickness', 'at_link:elevation',
          'at_node:elevation', 'at_node:temperature']
         """
         names = self.fields(include=include, exclude=exclude)
 
@@ -1424,23 +1422,23 @@
             Coordinates of nodes for a given axis.
 
         Examples
         --------
         >>> from landlab import RasterModelGrid
         >>> grid = RasterModelGrid((4, 5))
         >>> grid.node_axis_coordinates(0).reshape(grid.shape)
-        array([[ 0.,  0.,  0.,  0.,  0.],
-               [ 1.,  1.,  1.,  1.,  1.],
-               [ 2.,  2.,  2.,  2.,  2.],
-               [ 3.,  3.,  3.,  3.,  3.]])
+        array([[0.,  0.,  0.,  0.,  0.],
+               [1.,  1.,  1.,  1.,  1.],
+               [2.,  2.,  2.,  2.,  2.],
+               [3.,  3.,  3.,  3.,  3.]])
         >>> grid.node_axis_coordinates(1).reshape(grid.shape)
-        array([[ 0.,  1.,  2.,  3.,  4.],
-               [ 0.,  1.,  2.,  3.,  4.],
-               [ 0.,  1.,  2.,  3.,  4.],
-               [ 0.,  1.,  2.,  3.,  4.]])
+        array([[0.,  1.,  2.,  3.,  4.],
+               [0.,  1.,  2.,  3.,  4.],
+               [0.,  1.,  2.,  3.,  4.],
+               [0.,  1.,  2.,  3.,  4.]])
 
         :meta landlab: info-grid, info-node, quantity
         """
         AXES = ("node_y", "node_x")
         try:
             return getattr(self, AXES[axis])
         except IndexError as exc:
@@ -1560,17 +1558,17 @@
         Examples
         --------
         >>> from landlab import HexModelGrid
         >>> import numpy as np
 
         >>> grid = HexModelGrid((3, 2), node_layout="hex")
         >>> np.round(grid.angle_of_link[:3] / np.pi * 3.0)
-        array([ 0., 2.,  1.])
+        array([0., 2.,  1.])
         >>> np.round(grid.angle_of_link_about_head[:3] / np.pi * 3.0)  # 60 deg segments
-        array([ 3.,  5.,  4.])
+        array([3.,  5.,  4.])
 
         :meta landlab: info-link, quantity
         """
         angles = np.arctan2(-np.sin(self.angle_of_link), -np.cos(self.angle_of_link))
         return np.mod(angles, 2.0 * np.pi, out=angles)
 
     def resolve_values_on_links(self, link_values, out=None):
@@ -1642,15 +1640,15 @@
                [False, False, False,  True],
                [False, False,  True,  True],
                [False, False,  True,  True],
                [False, False,  True,  True],
                [False, False, False,  True],
                [False, False,  True,  True],
                [False, False,  True,  True],
-               [False, False,  True,  True]], dtype=bool)
+               [False, False,  True,  True]])
 
         :meta landlab: info-link, info-node, connectivity
         """
         if out is None:
             out = np.empty_like(self.links_at_node, dtype=bool)
         else:
             assert out.shape is self.links_at_node.shape
@@ -1724,15 +1722,15 @@
                [ True,  True, False, False],
                [ True,  True, False, False],
                [ True,  True, False, False],
                [False,  True, False, False],
                [ True, False, False, False],
                [ True, False, False, False],
                [ True, False, False, False],
-               [False, False, False, False]], dtype=bool)
+               [False, False, False, False]])
 
         :meta landlab: info-link, info-node, connectivity
         """
         if out is None:
             out = np.empty_like(self.links_at_node, dtype=bool)
         else:
             assert out.shape is self.links_at_node.shape
@@ -1951,15 +1949,15 @@
                [ True,  True, False, False],
                [False,  True, False, False],
                [False, False, False,  True],
                [False, False,  True,  True],
                [False, False,  True, False],
                [False, False, False, False],
                [False, False, False, False],
-               [False, False, False, False]], dtype=bool)
+               [False, False, False, False]])
         >>> 1 in mg.patches_at_node * mg.patches_present_at_node
         True
         >>> 2 in mg.patches_at_node * mg.patches_present_at_node
         False
 
         :meta landlab: info-patch, info-node
         """
@@ -2005,15 +2003,15 @@
                [False,  True],
                [ True, False],
                [ True, False],
                [False, False],
                [False, False],
                [False, False],
                [False, False],
-               [False, False]], dtype=bool)
+               [False, False]])
         >>> 1 in mg.patches_at_link * mg.patches_present_at_link
         True
         >>> 2 in mg.patches_at_link * mg.patches_present_at_link
         False
 
         :meta landlab: info-patch, info-link
         """
@@ -2039,15 +2037,15 @@
                [ True,  True, False, False],
                [False,  True, False, False],
                [False, False, False,  True],
                [False, False,  True,  True],
                [False, False,  True, False],
                [False, False, False, False],
                [False, False, False, False],
-               [False, False, False, False]], dtype=bool)
+               [False, False, False, False]])
         >>> mg.number_of_patches_present_at_node
         array([1, 2, 1, 1, 2, 1, 0, 0, 0])
 
         :meta landlab: info-patch, info-node, boundary-condition
         """
         try:
             return self._number_of_patches_present_at_node
@@ -2074,15 +2072,15 @@
                [False,  True],
                [ True, False],
                [ True, False],
                [False, False],
                [False, False],
                [False, False],
                [False, False],
-               [False, False]], dtype=bool)
+               [False, False]])
         >>> mg.number_of_patches_present_at_link
         array([1, 1, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0])
 
         :meta landlab: info-patch, info-link, boundary-condition
         """
         try:
             return self._number_of_patches_present_at_link
@@ -2092,15 +2090,16 @@
             return self._number_of_patches_present_at_link
 
     def _reset_patch_status(self):
         """Creates the array which stores patches_present_at_node.
 
         Call whenever boundary conditions are updated on the grid.
         """
-        from landlab import RasterModelGrid, VoronoiDelaunayGrid
+        from landlab import RasterModelGrid
+        from landlab import VoronoiDelaunayGrid
 
         node_status_at_patch = self.status_at_node[self.nodes_at_patch]
         if isinstance(self, RasterModelGrid):
             max_nodes_at_patch = 4
         elif isinstance(self, VoronoiDelaunayGrid):
             max_nodes_at_patch = 3
         else:
@@ -2174,18 +2173,18 @@
         --------
         >>> import numpy as np
         >>> from landlab import RasterModelGrid
 
         >>> mg = RasterModelGrid((5, 5), xy_spacing=1.0)
         >>> z = mg.x_of_node * np.tan(60.0 * np.pi / 180.0)
         >>> mg.calc_hillshade_at_node(elevs=z, alt=30.0, az=210.0)
-        array([ 0.625,  0.625,  0.625,  0.625,  0.625,  0.625,  0.625,  0.625,
-                0.625,  0.625,  0.625,  0.625,  0.625,  0.625,  0.625,  0.625,
-                0.625,  0.625,  0.625,  0.625,  0.625,  0.625,  0.625,  0.625,
-                0.625])
+        array([0.625,  0.625,  0.625,  0.625,  0.625,  0.625,  0.625,  0.625,
+               0.625,  0.625,  0.625,  0.625,  0.625,  0.625,  0.625,  0.625,
+               0.625,  0.625,  0.625,  0.625,  0.625,  0.625,  0.625,  0.625,
+               0.625])
 
         :meta landlab: info-node, surface
         """
         if slp is not None and asp is not None:
             if unit == "degrees":
                 (alt, az, slp, asp) = (
                     np.radians(alt),
@@ -2450,15 +2449,15 @@
         Examples
         --------
         >>> from landlab import RasterModelGrid
         >>> grid = RasterModelGrid((3, 3))
         >>> len(grid.unit_vector_sum_xcomponent_at_node) == grid.number_of_nodes
         True
         >>> grid.unit_vector_sum_xcomponent_at_node
-        array([ 1.,  2.,  1.,  1.,  2.,  1.,  1.,  2.,  1.])
+        array([1.,  2.,  1.,  1.,  2.,  1.,  1.,  2.,  1.])
 
         :meta landlab: info-node, quantity
         """
         return self.unit_vector_at_node[:, 0]
 
     @property
     def unit_vector_sum_ycomponent_at_node(self):
@@ -2467,253 +2466,20 @@
         Examples
         --------
         >>> from landlab import RasterModelGrid
         >>> grid = RasterModelGrid((3, 3))
         >>> len(grid.unit_vector_sum_ycomponent_at_node) == grid.number_of_nodes
         True
         >>> grid.unit_vector_sum_ycomponent_at_node
-        array([ 1.,  1.,  1.,  2.,  2.,  2.,  1.,  1.,  1.])
+        array([1.,  1.,  1.,  2.,  2.,  2.,  1.,  1.,  1.])
 
         :meta landlab: info-node, quantity
         """
         return self.unit_vector_at_node[:, 1]
 
-    def map_link_vector_to_nodes(self, q):
-        r"""Map data defined on links to nodes.
-
-        .. danger::
-
-            THIS ALGORITHM IS NOT CORRECT AND NEEDS TO BE CHANGED!
-
-        Given a variable defined on links, breaks it into x and y components
-        and assigns values to nodes by averaging each node's attached links.
-
-        Parameters
-        ----------
-        q : ndarray of floats (1D, length = number of links in grid)
-            Variable defined on links
-
-        Returns
-        -------
-        ndarray, ndarray
-            x and y components of variable mapped to nodes (1D,
-            length = number of nodes)
-
-        See Also
-        --------
-        _create_link_unit_vectors : sets up unit vectors at links and unit-vector
-                                  sums at nodes
-
-        Notes
-        -----
-
-        The concept here is that q contains a vector variable that is defined
-        at each link. The magnitude is given by the value of q, and the
-        direction is given by the orientation of the link, as described by
-        its unit vector.
-
-        To map the link-vector values to the nodes, we break the values into
-        x- and y-components according to each link's unit vector. The
-        x-component of q at a node is a weighted sum of the x-components of the
-        links that are attached to that node. A good way to appreciate this
-        is by example. Consider a 3x4 raster grid::
-
-            8--14---9--15--10--16--11
-            |       |       |       |
-            4       5       6       7
-            |       |       |       |
-            4--11---5---12--6---13--7
-            |       |       |       |
-            0       1       2       3
-            |       |       |       |
-            0---8---1---9---2--10---3
-
-        Imagine that for each node, we were to add up the unit vector
-        components for each connected link; in other words, add up all the x
-        components of the unit vectors associated with each link, and add up
-        all the y components. Here's what that would look like for the above
-        grid ("vsx" and "vsy" stand for "vector sum x" and "vector sum y"):
-
-        *  Corner nodes (0, 3, 8, 11): vsx = 1, vsy = 1
-        *  Bottom and top nodes (1-2, 9-10): vsx = 2, vsy = 1
-        *  Left and right nodes (4, 7): vsx = 1, vsy = 2
-        *  All others: vsx = 2, vsy = 2
-
-        The process of creating unit-vector sums at nodes is handled by
-        ModelGrid._create_link_unit_vectors() (and, for raster grids, by the
-        overriding method RasterModelGrid._create_link_unit_vectors()). The node
-        unit-vector sums are then stored in self.node_unit_vector_sum_x and
-        self.node_unit_vector_sum_y.
-
-        How would you use this? Suppose you have a vector variable q defined at
-        links. What's the average at the nodes? We'll define the average as
-        follows.  The terminology here is: :math:`q = (u,v)` represents the
-        vector quantity defined at links, :math:`Q = (U,V)` represents its
-        definition at nodes, :math:`(m,n)` represents the unit vector
-        components at a link, and :math:`(S_x,S_y)` represents the unit-vector
-        sum at a given node.
-
-        .. math::
-
-            U_i = \sum_{j=1}^{L_i} q_j m_j / S_{xi}
-            V_i = \sum_{j=1}^{L_i} q_j n_j / S_{yi}
-
-        Suppose that the vector q is uniform and equal to one.
-        Then, at node 0 in the above grid, this works out to::
-
-            U_0 = (q_0 m_0) / 1 + (q_8 m_8) / 1 = (1 0)/ 1 + (1 1)/1 = 1
-            V_0 = (q_0 n_0) / 1 + (q_8 n_8) / 1 = (1 1) / 1 + (1 0) / 1 = 1
-
-        At node 1, in the bottom row but not a corner, we add up the values
-        of **q** associated with THREE links. The x-vector sum of these links
-        is 2 because there are two horizontal links, each with an x- unit
-        vector value of unity.  The y-vector sum is 1 because only one of the
-        three (link #1) has a non-zero y component (equal to one). Here is
-        how the numbers work out::
-
-            U_1 = (q_1 m_1) / 2 + (q_8 m_8) / 2 + (q_9 m_9) / 2
-                = (1 0) / 2 + (1 1) / 2 + (1 1) / 2 = 1
-            V_1 = (q_1 n_1) / 1 + (q_8 n_8) / 1 + (q_9 n_9) / 1
-                = (1 1) / 1 + (1 0) / 1 + (1 0) / 1 = 1
-
-        At node 5, in the interior, there are four connected links (two
-        in-links and two out-links; two horizontal and two vertical). So, we
-        add up the q values associated with all four::
-
-            U_5 = (q_1 m_1) / 2 + (q_5 m_5) / 2 + (q_11 m_11) / 2 + (q_12 m_12) / 2
-                = (1 0) / 2 + (1 0) / 2 + (1 1) / 2 + (1 1) / 2 = 1
-
-            V_5 = (q_1 n_1) / 2 + (q_5 n_5) / 2 + (q_11 n_11) / 2 + (q_12 n_12) / 2
-                = (1 1) / 2 + (1 1) / 2 + (1 0) / 2 + (1 0) / 2 = 1
-
-        To do this calculation efficiently, we use the following algorithm::
-
-            FOR each row in _node_inlink_matrix (representing one inlink @ each
-            node)
-                Multiply the link's q value by its unit x component ...
-                ... divide by node's unit vector sum in x ...
-                ... and add it to the node's total q_x
-                Multiply the link's q value by its unit y component ...
-                ... divide by node's unit vector sum in y ...
-                ... and add it to the node's total q_y
-
-        Examples
-        --------
-
-        **Example 1**
-
-        q[:] = 1. Vector magnitude is :math:`\sqrt{2}`, direction is
-        :math:`(1,1)`.
-
-        >>> from landlab import RasterModelGrid
-        >>> grid = RasterModelGrid((3, 4), xy_spacing=(2.0, 2.0))
-        >>> grid.unit_vector_at_node
-        array([[ 1.,  1.],
-               [ 2.,  1.],
-               [ 2.,  1.],
-               [ 1.,  1.],
-               [ 1.,  2.],
-               [ 2.,  2.],
-               [ 2.,  2.],
-               [ 1.,  2.],
-               [ 1.,  1.],
-               [ 2.,  1.],
-               [ 2.,  1.],
-               [ 1.,  1.]])
-        >>> q = grid.ones(at="link")
-        >>> grid.map_link_vector_to_nodes(q)
-        array([[ 1.,  1.],
-               [ 1.,  1.],
-               [ 1.,  1.],
-               [ 1.,  1.],
-               [ 1.,  1.],
-               [ 1.,  1.],
-               [ 1.,  1.],
-               [ 1.,  1.],
-               [ 1.,  1.],
-               [ 1.,  1.],
-               [ 1.,  1.],
-               [ 1.,  1.]])
-
-        **Example 2**
-
-        Vector magnitude is 5, angle is 30 degrees from horizontal,
-        forming a 3-4-5 triangle.
-
-        >>> import numpy as np
-        >>> q = np.array(
-        ...     [
-        ...         4.0,
-        ...         4.0,
-        ...         4.0,
-        ...         3.0,
-        ...         3.0,
-        ...         3.0,
-        ...         3.0,
-        ...         4.0,
-        ...         4.0,
-        ...         4.0,
-        ...         3.0,
-        ...         3.0,
-        ...         3.0,
-        ...         3.0,
-        ...         4.0,
-        ...         4.0,
-        ...         4,
-        ...     ]
-        ... )
-        >>> grid.map_link_vector_to_nodes(q)
-        array([[ 4.,  3.],
-               [ 4.,  3.],
-               [ 4.,  3.],
-               [ 4.,  3.],
-               [ 4.,  3.],
-               [ 4.,  3.],
-               [ 4.,  3.],
-               [ 4.,  3.],
-               [ 4.,  3.],
-               [ 4.,  3.],
-               [ 4.,  3.],
-               [ 4.,  3.]])
-
-        ..todo::
-
-            Fix and finish example 3 below.
-
-        Example 3: Hexagonal grid with vector as above. Here, q is
-        pre-calculated to have the right values to represent a uniform
-        vector with magnitude 5 and orientation 30 degrees counter-clockwise
-        from horizontal.
-        """
-        # Break the link-based vector input variable, q, into x- and
-        # y-components.
-        # Notes:
-        #   1) We make the arrays 1 element longer than the number of links,
-        #       so that references to -1 in the node-link matrices will refer
-        #       to the last element of these two arrays, which will contain
-        #       zeros. (Same trick as in the flux divergence functions)
-        #   2) This requires memory allocation. Because this function might be
-        #       called repeatedly, it would be good to find a way to
-        #       pre-allocate to improve speed.
-        qx = q * self.unit_vector_at_link[:, 0]
-        qy = q * self.unit_vector_at_link[:, 1]
-
-        active_links_at_node = self.link_dirs_at_node != 0
-        unit_vec_at_node = np.empty((self.number_of_nodes, 2), dtype=float)
-        unit_vec_at_node[:, 0] = (qx[self.links_at_node] * active_links_at_node).sum(
-            axis=1
-        )
-        unit_vec_at_node[:, 1] = (qy[self.links_at_node] * active_links_at_node).sum(
-            axis=1
-        )
-
-        return np.divide(
-            unit_vec_at_node, self.unit_vector_at_node, out=unit_vec_at_node
-        )
-
     def node_is_boundary(self, ids, boundary_flag=None):
         """Check if nodes are boundary nodes.
 
         Check if nodes at given *ids* are boundary nodes. Use the
         *boundary_flag* to specify a particular boundary type status flag.
 
         Parameters
@@ -2729,17 +2495,17 @@
             Array of booleans indicating if nodes are boundary nodes.
 
         Examples
         --------
         >>> from landlab import RasterModelGrid
         >>> mg = RasterModelGrid((4, 5))
         >>> mg.node_is_boundary([0, 6])
-        array([ True, False], dtype=bool)
+        array([ True, False])
         >>> mg.node_is_boundary([0, 6], boundary_flag=mg.BC_NODE_IS_CLOSED)
-        array([False, False], dtype=bool)
+        array([False, False])
 
         :meta landlab: info-node, boundary-condition
         """
         if boundary_flag is None:
             return ~(self._node_status[ids] == NodeStatus.CORE)
         else:
             return self._node_status[ids] == boundary_flag
@@ -2812,44 +2578,44 @@
         >>> from landlab import RasterModelGrid
         >>> grid = RasterModelGrid((4, 5))
 
         Calculate distances from point at (2., 1.) to a subset of nodes on
         the grid.
 
         >>> grid.calc_distances_of_nodes_to_point((2, 1), node_subset=(2, 6, 7, 8, 12))
-        array([ 1.,  1.,  0.,  1.,  1.])
+        array([1.,  1.,  0.,  1.,  1.])
 
         Calculate distances from a point to all nodes on the grid.
 
         >>> dist = grid.calc_distances_of_nodes_to_point((2, 1))
         >>> dist.shape == (grid.number_of_nodes,)
         True
         >>> dist.take((2, 6, 7, 8, 12))
-        array([ 1.,  1.,  0.,  1.,  1.])
+        array([1.,  1.,  0.,  1.,  1.])
 
         Put the distances into a buffer.
 
         >>> out = np.empty(grid.number_of_nodes, dtype=float)
         >>> dist = grid.calc_distances_of_nodes_to_point((2, 1), out_distance=out)
         >>> out is dist
         True
         >>> out.take((2, 6, 7, 8, 12))
-        array([ 1.,  1.,  0.,  1.,  1.])
+        array([1.,  1.,  0.,  1.,  1.])
 
         Calculate azimuths along with distances. The azimuths are calculated
         in radians but measured clockwise from north.
 
         >>> (_, azim) = grid.calc_distances_of_nodes_to_point((2, 1), get_az="angles")
         >>> azim.take((2, 6, 7, 8, 12)) * 180.0 / np.pi
-        array([ 180.,  270.,    0.,   90.,    0.])
+        array([180.,  270.,    0.,   90.,    0.])
         >>> (_, azim) = grid.calc_distances_of_nodes_to_point(
         ...     (2, 1), get_az="angles", node_subset=(1, 3, 11, 13)
         ... )
         >>> azim * 180.0 / np.pi
-        array([ 225.,  135.,  315.,   45.])
+        array([225.,  135.,  315.,   45.])
 
         When calculating displacements, the first row contains displacements
         in x and the second displacements in y.
 
         >>> (_, azim) = grid.calc_distances_of_nodes_to_point(
         ...     (2, 1), get_az="displacements", node_subset=(2, 6, 7, 8, 12)
         ... )
@@ -2950,23 +2716,23 @@
 
         The shape of the array is ``number_of_nodes`` by ``number_of_nodes``
         and distance from a node to itself is zero.
 
         >>> distances.shape == (grid.number_of_nodes, grid.number_of_nodes)
         True
         >>> distances.diagonal()
-        array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
+        array([0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
 
         The distances from the first node to all nodes in its row and all the
         nodes in its column.
 
         >>> distances[0, :4]
-        array([ 0.,  1.,  2.,  3.])
+        array([0.,  1.,  2.,  3.])
         >>> distances[0, ::4]
-        array([ 0.,  1.,  2.])
+        array([0.,  1.,  2.])
 
         :meta landlab: info-node, quantity
         """
         if self._all_node_distances_map is None:
             self._create_all_node_distances_azimuths_maps()
         return self._all_node_distances_map
 
@@ -2983,26 +2749,26 @@
 
         The shape of the array is ``number_of_nodes`` by ``number_of_nodes``
         and azimuth from a node to itself is zero.
 
         >>> angles.shape == (grid.number_of_nodes, grid.number_of_nodes)
         True
         >>> angles.diagonal()
-        array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
+        array([0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
 
         Angles are measured in radians and increase clockwise starting at
         north.
 
         >>> angles *= 180.0 / np.pi
         >>> angles[0, :4]
-        array([  0.,  90.,  90.,  90.])
+        array([ 0.,  90.,  90.,  90.])
         >>> angles[0, ::4]
-        array([ 0.,  0.,  0.])
+        array([0.,  0.,  0.])
         >>> angles[0, ::5]
-        array([  0.,  45.,  45.])
+        array([ 0.,  45.,  45.])
 
         :meta landlab: info-node, quantity
         """
         if self._all_node_azimuths_map is None:
             self._create_all_node_distances_azimuths_maps()
         return self._all_node_azimuths_map
 
@@ -3083,22 +2849,22 @@
                 20, 21, 22, 23
 
         >>> from landlab import HexModelGrid
         >>> grid = HexModelGrid((5, 4))
         >>> grid.node_has_boundary_neighbor()
         array([ True,  True,  True,  True,  True,  True,  True,  True,  True,
                 True,  True, False, False,  True,  True,  True,  True,  True,
-                True,  True,  True,  True,  True,  True], dtype=bool)
+                True,  True,  True,  True,  True,  True])
 
         >>> grid.node_has_boundary_neighbor()[6]
         True
         >>> grid.node_has_boundary_neighbor()[12]
         False
         >>> grid.node_has_boundary_neighbor()[((12, 0),)]
-        array([False,  True], dtype=bool)
+        array([False,  True])
 
         :meta landlab: info-node, connectivity, boundary-condition
         """
         status_of_neighbor = self._node_status[self.adjacent_nodes_at_node]
         neighbor_not_core = status_of_neighbor != NodeStatus.CORE
         bad_neighbor = self.adjacent_nodes_at_node == self.BAD_INDEX
         neighbor_not_core[bad_neighbor] = False
```

### Comparing `landlab-2.7.0/landlab/grid/cfuncs.pyx` & `landlab-2.8.0/landlab/grid/cfuncs.pyx`

 * *Files 3% similar despite different names*

```diff
@@ -83,16 +83,16 @@
 @cython.boundscheck(False)
 def _argsort_points_by_x_then_y(np.ndarray[DTYPE_INT_t, ndim=1] pts,
                                 np.ndarray[DTYPE_INT_t, ndim=1] out):
 
     cdef np.ndarray[DTYPE_INT_t, ndim=1] a
     cdef np.ndarray[DTYPE_INT_t, ndim=1] b
 
-    a = pts[:, 0].argsort(kind='mergesort')
-    b = pts[a, 1].argsort(kind='mergesort')
+    a = pts[:, 0].argsort(kind="mergesort")
+    b = pts[a, 1].argsort(kind="mergesort")
     out[:] = a[b]
 
 
 @cython.boundscheck(False)
 def _anticlockwise_argsort_points(np.ndarray[DTYPE_INT_t, ndim=2] pts,
                                   np.ndarray[DTYPE_INT_t, ndim=1] out):
```

### Comparing `landlab-2.7.0/landlab/grid/create.py` & `landlab-2.8.0/landlab/grid/create.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,18 @@
 #! /usr/bin/env python
 """Create landlab model grids."""
 
 from ..core import load_params
 from ..io import read_esri_ascii
 from ..io.netcdf import read_netcdf
-from ..values import constant, plane, random, sine, units
+from ..values import constant
+from ..values import plane
+from ..values import random
+from ..values import sine
+from ..values import units
 from .hex import HexModelGrid
 from .network import NetworkModelGrid
 from .radial import RadialModelGrid
 from .raster import RasterModelGrid
 from .voronoi import VoronoiDelaunayGrid
 
 _MODEL_GRIDS = {
@@ -25,22 +29,20 @@
     "sine": sine,
     "constant": constant,
     "units": units,
 }
 
 
 class Error(Exception):
-
     """Base class for exceptions from this module."""
 
     pass
 
 
 class BadGridTypeError(Error):
-
     """Raise this error for a bad grid type."""
 
     def __init__(self, grid_type):
         self._type = str(grid_type)  # TODO: not tested.
 
     def __str__(self):
         return self._type  # TODO: not tested.
@@ -368,18 +370,18 @@
              0.,   3.,   6.,   9.,  12.])
     >>> mg.status_at_node
     array([4, 4, 4, 4, 4,
            4, 0, 0, 0, 4,
            4, 0, 0, 0, 4,
            4, 4, 4, 4, 4], dtype=uint8)
     >>> np.round(mg.at_node["spam"].reshape(mg.shape), decimals=2)
-    array([[  0.12,   7.85,  13.2 ,  18.8 ,  23.47],
-           [  3.47,   9.17,  17.6 ,  22.8 ,  29.12],
-           [  7.06,  15.91,  21.5 ,  25.64,  31.55],
-           [ 11.55,  17.91,  24.57,  30.3 ,  35.87]])
+    array([[ 0.12,   7.85,  13.2 ,  18.8 ,  23.47],
+           [ 3.47,   9.17,  17.6 ,  22.8 ,  29.12],
+           [ 7.06,  15.91,  21.5 ,  25.64,  31.55],
+           [11.55,  17.91,  24.57,  30.3 ,  35.87]])
     """
     if isinstance(file_like, dict):
         params = file_like
     else:
         params = load_params(file_like)
 
     if section:
```

### Comparing `landlab-2.7.0/landlab/grid/create_network.py` & `landlab-2.8.0/landlab/grid/create_network.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,19 +1,21 @@
 """
 Created on Tue Feb  2 17:50:09 2021
 
 @author: sahrendt
 """
+
 from dataclasses import dataclass
 from itertools import tee
 
 import numpy as np
 import numpy.typing as npt
 
-from ..components import ChannelProfiler, FlowAccumulator
+from ..components import ChannelProfiler
+from ..components import FlowAccumulator
 from .network import NetworkModelGrid
 
 try:
     from itertools import pairwise
 except ImportError:
     # Not available before Python 3.10
     def pairwise(iterable):
@@ -405,15 +407,14 @@
     if nodes[-1] != n_nodes - 1:
         nodes.append(n_nodes - 1)
 
     return nodes
 
 
 class SegmentLinkCollector:
-
     """Collect links between nodes of segments."""
 
     def __init__(self, links=None):
         if links is None:
             self._links = []
         else:
             self._links = list(links)
@@ -431,15 +432,14 @@
     @property
     def links(self):
         """Head and tail nodes of all collected links."""
         return self._links
 
 
 class ChannelSegment:
-
     """A channel segment.
 
     Parameters
     ----------
     nodes : iterable of int
         The nodes of the channel, listed from downstream to upstream.
     """
@@ -524,22 +524,20 @@
 
     @nodes.setter
     def nodes(self, nodes):
         self._nodes = np.array(nodes, copy=True)
 
 
 class DisconnectedSegmentError(Exception):
-
     """Raise this exception if a channel segment cannot be connected to a network."""
 
     pass
 
 
 class ChannelSegmentConnector:
-
     """Connect channel segments to form a network."""
 
     def __init__(self, *args):
         """ChannelSegmentConnector(channel1, channel2, ...)"""
         self._root = None
         self._orphans = []
         for segment in args:
@@ -619,15 +617,14 @@
     """Create an array of coordinates for each node of a channel network."""
     xy_of_node_collector = SegmentNodeCoordinateCollector(grid)
     network.for_each(xy_of_node_collector)
     return np.asarray(xy_of_node_collector.xy_of_node)
 
 
 class SegmentNodeCoordinateCollector:
-
     """Collect xy coordinates for each node along segments."""
 
     def __init__(self, grid):
         self._grid = grid
         self._xy_of_node = []
 
     def __call__(self, segment):
@@ -684,15 +681,14 @@
         network.for_each(field_value_collector)
         at_node[name] = np.asarray(field_value_collector.values)
 
     return at_node
 
 
 class SegmentFieldCollector:
-
     """Collect field values for each node along segments."""
 
     def __init__(self, field):
         self._field = field
         self._values = []
 
     def __call__(self, segment):
@@ -715,15 +711,14 @@
     node_reindexer = SegmentNodeReindexer()
     network.for_each(node_reindexer)
 
     return network
 
 
 class SegmentNodeReindexer:
-
     """Reindex nodes along segments."""
 
     def __init__(self, nodes=None):
         if nodes is None:
             self._nodes = []
         else:
             self._nodes = list(nodes)
```

### Comparing `landlab-2.7.0/landlab/grid/decorators.py` & `landlab-2.8.0/landlab/grid/decorators.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,23 +5,23 @@
 
 .. autosummary::
 
     ~landlab.grid.decorators.override_array_setitem_and_reset
     ~landlab.grid.decorators.return_id_array
     ~landlab.grid.decorators.return_readonly_id_array
 """
+
 from functools import wraps
 
 import numpy as np
 
 from ..core.utils import as_id_array
 
 
 class override_array_setitem_and_reset:
-
     """Decorator that calls a grid method after setting array values.
 
     This decorator wraps `ModelGrid` methods that return a numpy array
     so that it returns a wrapped array that overrides the numpy array
     `__setitem__`, `__setslice__`, and `itemset` methods. The wrapped methods
     set values in the array but then also call a grid method that resets some
     state variables of the grid.
@@ -59,15 +59,14 @@
         """
         reset = self._reset
 
         def _wrapped(grid):
             """Embed a grid into a numpy array and override set methods."""
 
             class array(np.ndarray):
-
                 """Override numpy setters and reset grid topology."""
 
                 def __new__(cls, arr):
                     """Instantiate the class with a view of the base array."""
                     obj = np.asarray(arr).view(cls)
                     obj.grid = grid
                     return obj
```

### Comparing `landlab-2.7.0/landlab/grid/diagonals.py` & `landlab-2.8.0/landlab/grid/diagonals.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 #! /usr/bin/env python
 import contextlib
 
 import numpy as np
 
-from ..utils.decorators import cache_result_in_object, make_return_array_immutable
+from ..utils.decorators import cache_result_in_object
+from ..utils.decorators import make_return_array_immutable
 from .decorators import return_readonly_id_array
-from .linkstatus import LinkStatus, set_status_at_link
+from .linkstatus import LinkStatus
+from .linkstatus import set_status_at_link
 
 
 def create_nodes_at_diagonal(shape, out=None):
     """Create array of tail and head nodes for diagonals.
 
     Parameters
     ----------
@@ -98,15 +100,14 @@
     out[:, 1] = diagonals[1:, :-1].flat
     out[:, 3] = diagonals[:-1, 1:].flat
 
     return out
 
 
 class DiagonalsMixIn:
-
     """Add diagonals to a structured quad grid."""
 
     @property
     @cache_result_in_object()
     def number_of_diagonals(self):
         """Number of diagonals in the grid.
 
@@ -363,21 +364,21 @@
 
         Examples
         --------
         >>> from landlab import RasterModelGrid
         >>> grid = RasterModelGrid((3, 3), xy_spacing=(4, 3))
 
         >>> grid.length_of_link
-        array([ 4.,  4.,  3.,  3.,  3.,  4.,  4.,  3.,  3.,  3.,  4.,  4.])
+        array([4.,  4.,  3.,  3.,  3.,  4.,  4.,  3.,  3.,  3.,  4.,  4.])
 
         >>> grid.length_of_d8
-        array([ 4.,  4.,  3.,  3.,  3.,
-                4.,  4.,  3.,  3.,  3.,
-                4.,  4.,  5.,  5.,  5.,
-                5.,  5.,  5.,  5.,  5.])
+        array([4.,  4.,  3.,  3.,  3.,
+               4.,  4.,  3.,  3.,  3.,
+               4.,  4.,  5.,  5.,  5.,
+               5.,  5.,  5.,  5.,  5.])
 
         :meta landlab: info-link, quantity
         """
         return np.hstack((super().length_of_link, self.length_of_diagonal))
 
     def reset_status_at_node(self):
         super().reset_status_at_node()
```

### Comparing `landlab-2.7.0/landlab/grid/divergence.py` & `landlab-2.8.0/landlab/grid/divergence.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,27 +34,27 @@
     >>> z[5] = 50.0
     >>> z[6] = 36.0
     >>> lg = rg.calc_grad_at_link(z)  # there are 17 links
     >>> lg
     array([ 0. ,  0. ,  0. ,  0. ,  5. ,  3.6,  0. ,  5. , -1.4, -3.6,  0. ,
            -5. , -3.6,  0. ,  0. ,  0. ,  0. ])
     >>> calc_flux_div_at_node(rg, -lg)
-    array([ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.64,  0.94,  0.  ,  0.  ,
-            0.  ,  0.  ,  0.  ])
+    array([0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.64,  0.94,  0.  ,  0.  ,
+           0.  ,  0.  ,  0.  ])
     >>> rg.set_status_at_node_on_edges(right=rg.BC_NODE_IS_CLOSED)
     >>> rg.set_status_at_node_on_edges(top=rg.BC_NODE_IS_CLOSED)
     >>> unit_flux_at_links = np.zeros(rg.number_of_links)
     >>> unit_flux_at_links[rg.active_links] = -lg[rg.active_links]
     >>> calc_flux_div_at_node(rg, unit_flux_at_links)
-    array([ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.14,  0.22,  0.  ,  0.  ,
-            0.  ,  0.  ,  0.  ])
+    array([0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.14,  0.22,  0.  ,  0.  ,
+           0.  ,  0.  ,  0.  ])
     >>> _ = rg.add_field("neg_grad_at_link", -lg, at="link")
     >>> calc_flux_div_at_node(rg, "neg_grad_at_link")
-    array([ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.64,  0.94,  0.  ,  0.  ,
-            0.  ,  0.  ,  0.  ])
+    array([0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.64,  0.94,  0.  ,  0.  ,
+           0.  ,  0.  ,  0.  ])
 
 
     Notes
     -----
     Performs a numerical flux divergence operation on nodes.
 
     :meta landlab: info-node, gradient
@@ -110,24 +110,24 @@
     >>> lg
     array([ 0. ,  0. ,  0. ,  0. ,  5. ,  3.6,  0. ,  5. , -1.4, -3.6,  0. ,
            -5. , -3.6,  0. ,  0. ,  0. ,  0. ])
     >>> fg = lg[rg.link_at_face]  # there are 7 faces
     >>> fg
     array([ 5. ,  3.6,  5. , -1.4, -3.6, -5. , -3.6])
     >>> calc_flux_div_at_cell(rg, -fg)
-    array([ 1.64,  0.94])
+    array([1.64,  0.94])
     >>> rg.set_status_at_node_on_edges(right=rg.BC_NODE_IS_CLOSED)
     >>> rg.set_status_at_node_on_edges(top=rg.BC_NODE_IS_CLOSED)
     >>> unit_flux_at_faces = np.zeros(rg.number_of_faces)
     >>> unit_flux_at_faces[rg.active_faces] = -fg[rg.active_faces]
     >>> calc_flux_div_at_cell(rg, unit_flux_at_faces)
-    array([ 1.14,  0.22])
+    array([1.14,  0.22])
     >>> _ = rg.add_field("neg_grad_at_link", -lg, at="link")
     >>> calc_flux_div_at_cell(rg, "neg_grad_at_link")
-    array([ 1.64,  0.94])
+    array([1.64,  0.94])
 
     Notes
     -----
     Performs a numerical flux divergence operation at cells.
 
     :meta landlab: info-node, gradient
     """
@@ -261,34 +261,34 @@
     >>> z[5] = 50.0
     >>> z[6] = 36.0
     >>> lg = rg.calc_grad_at_link(z)
     >>> fg = lg[rg.link_at_face]  # there are 7 faces
     >>> fg
     array([ 5. ,  3.6,  5. , -1.4, -3.6, -5. , -3.6])
     >>> _calc_net_face_flux_at_cell(rg, -fg)
-    array([ 164.,   94.])
+    array([164.,   94.])
     >>> rg.set_status_at_node_on_edges(right=rg.BC_NODE_IS_CLOSED)
     >>> rg.set_status_at_node_on_edges(top=rg.BC_NODE_IS_CLOSED)
     >>> unit_flux_at_faces = np.zeros(rg.number_of_faces)
     >>> unit_flux_at_faces[rg.active_faces] = -fg[rg.active_faces]
     >>> _calc_net_face_flux_at_cell(rg, unit_flux_at_faces)
-    array([ 114.,   22.])
+    array([114.,   22.])
 
     >>> from landlab import HexModelGrid
     >>> hg = HexModelGrid((3, 3), spacing=10.0)
     >>> z = hg.add_zeros("topographic__elevation", at="node", clobber=True)
     >>> z[4] = 50.0
     >>> z[5] = 36.0
     >>> lg = hg.calc_grad_at_link(z)
     >>> fg = lg[hg.link_at_face]  # there are 11 faces
     >>> fg
     array([ 5. ,  5. ,  3.6,  3.6,  5. , -1.4, -3.6, -5. , -5. , -3.6, -3.6])
     >>> nffc = _calc_net_face_flux_at_cell(hg, -fg)
     >>> np.round(nffc)
-    array([ 152.,   96.])
+    array([152.,   96.])
 
     Notes
     -----
     This is essentially a line integral for the fluxes along the boundaries of
     each cell. Hence, the resulting output has dimensions of total flux (so,
     if the unit flux happens to be mass per time per face width, the output
     will be in mass per unit time).
@@ -329,22 +329,22 @@
     >>> z = rg.add_zeros("topographic__elevation", at="node")
     >>> z[5] = 50.0
     >>> z[6] = 36.0
     >>> lg = rg.calc_grad_at_link(z)
     >>> lg[rg.link_at_face]
     array([ 5. ,  3.6,  5. , -1.4, -3.6, -5. , -3.6])
     >>> _calc_face_flux_divergence_at_cell(rg, -lg[rg.link_at_face])
-    array([ 1.64,  0.94])
+    array([1.64,  0.94])
     >>> rg.set_status_at_node_on_edges(right=rg.BC_NODE_IS_CLOSED)
     >>> rg.set_status_at_node_on_edges(top=rg.BC_NODE_IS_CLOSED)
     >>> unit_flux_at_faces = np.zeros(rg.number_of_faces)
     >>> fg = lg[rg.link_at_face]
     >>> unit_flux_at_faces[rg.active_faces] = -fg[rg.active_faces]
     >>> _calc_face_flux_divergence_at_cell(rg, unit_flux_at_faces)
-    array([ 1.14,  0.22])
+    array([1.14,  0.22])
 
     Notes
     -----
     Performs a numerical flux divergence operation on cells.
     """
     return _calc_net_face_flux_at_cell(grid, unit_flux_at_faces) / grid.area_of_cell
 
@@ -379,31 +379,31 @@
     >>> z = rg.add_zeros("topographic__elevation", at="node")
     >>> z[5] = 50.0
     >>> z[6] = 36.0
     >>> fg = rg.calc_grad_at_link(z)[rg.link_at_face]  # there are 7 faces
     >>> fg
     array([ 5. ,  3.6,  5. , -1.4, -3.6, -5. , -3.6])
     >>> _calc_net_active_face_flux_at_cell(rg, -fg)
-    array([ 164.,   94.])
+    array([164.,   94.])
     >>> rg.set_status_at_node_on_edges(right=rg.BC_NODE_IS_CLOSED)
     >>> rg.set_status_at_node_on_edges(top=rg.BC_NODE_IS_CLOSED)
     >>> _calc_net_active_face_flux_at_cell(rg, -fg)
-    array([ 114.,   22.])
+    array([114.,   22.])
 
     >>> from landlab import HexModelGrid
     >>> hg = HexModelGrid((3, 3), spacing=10.0)
     >>> z = hg.add_zeros("topographic__elevation", at="node", clobber=True)
     >>> z[4] = 50.0
     >>> z[5] = 36.0
     >>> fg = hg.calc_grad_at_link(z)[hg.link_at_face]  # there are 11 faces
     >>> fg
     array([ 5. ,  5. ,  3.6,  3.6,  5. , -1.4, -3.6, -5. , -5. , -3.6, -3.6])
     >>> nffc = _calc_net_active_face_flux_at_cell(hg, -fg)
     >>> np.round(nffc)
-    array([ 152.,   96.])
+    array([152.,   96.])
 
     Notes
     -----
     This is essentially a line integral for the fluxes along the boundaries of
     each cell. Hence, the resulting output has dimensions of total flux (so,
     if the unit flux happens to be mass per time per face width, the output
     will be in mass per unit time).
@@ -449,19 +449,19 @@
     >>> z = rg.add_zeros("topographic__elevation", at="node")
     >>> z[5] = 50.0
     >>> z[6] = 36.0
     >>> fg = rg.calc_grad_at_link(z)[rg.link_at_face]  # there are 7 faces
     >>> fg
     array([ 5. ,  3.6,  5. , -1.4, -3.6, -5. , -3.6])
     >>> _calc_active_face_flux_divergence_at_cell(rg, -fg)
-    array([ 1.64,  0.94])
+    array([1.64,  0.94])
     >>> rg.set_status_at_node_on_edges(right=rg.BC_NODE_IS_CLOSED)
     >>> rg.set_status_at_node_on_edges(top=rg.BC_NODE_IS_CLOSED)
     >>> _calc_active_face_flux_divergence_at_cell(rg, -fg)
-    array([ 1.14,  0.22])
+    array([1.14,  0.22])
 
     Notes
     -----
     Performs a numerical flux divergence operation on cells.
     """
     return (
         _calc_net_active_face_flux_at_cell(grid, unit_flux_at_faces) / grid.area_of_cell
@@ -574,21 +574,21 @@
     >>> z[5] = 50.0
     >>> z[6] = 36.0
     >>> lg = rg.calc_grad_at_link(z)  # there are 17 links
     >>> lg
     array([ 0. ,  0. ,  0. ,  0. ,  5. ,  3.6,  0. ,  5. , -1.4, -3.6,  0. ,
            -5. , -3.6,  0. ,  0. ,  0. ,  0. ])
     >>> _calc_active_link_flux_divergence_at_node(rg, -lg)
-    array([ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.64,  0.94,  0.  ,  0.  ,
-            0.  ,  0.  ,  0.  ])
+    array([0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.64,  0.94,  0.  ,  0.  ,
+           0.  ,  0.  ,  0.  ])
     >>> rg.set_status_at_node_on_edges(right=rg.BC_NODE_IS_CLOSED)
     >>> rg.set_status_at_node_on_edges(top=rg.BC_NODE_IS_CLOSED)
     >>> _calc_active_link_flux_divergence_at_node(rg, -lg)
-    array([ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.14,  0.22,  0.  ,  0.  ,
-            0.  ,  0.  ,  0.  ])
+    array([0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.14,  0.22,  0.  ,  0.  ,
+           0.  ,  0.  ,  0.  ])
 
     Notes
     -----
     Performs a numerical flux divergence operation on nodes.
     """
     if out is None:
         out = grid.zeros(at="node")
@@ -768,21 +768,21 @@
     >>> z = rg.add_zeros("topographic__elevation", at="node")
     >>> z[5] = 50.0
     >>> z[6] = 36.0
     >>> fg = rg.calc_grad_at_link(z)[rg.link_at_face]  # there are 7 faces
     >>> fg
     array([ 5. ,  3.6,  5. , -1.4, -3.6, -5. , -3.6])
     >>> _calc_active_face_flux_divergence_at_node(rg, -fg)
-    array([ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.64,  0.94,  0.  ,  0.  ,
-            0.  ,  0.  ,  0.  ])
+    array([0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.64,  0.94,  0.  ,  0.  ,
+           0.  ,  0.  ,  0.  ])
     >>> rg.set_status_at_node_on_edges(right=rg.BC_NODE_IS_CLOSED)
     >>> rg.set_status_at_node_on_edges(top=rg.BC_NODE_IS_CLOSED)
     >>> _calc_active_face_flux_divergence_at_node(rg, -fg)
-    array([ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.14,  0.22,  0.  ,  0.  ,
-            0.  ,  0.  ,  0.  ])
+    array([0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  1.14,  0.22,  0.  ,  0.  ,
+           0.  ,  0.  ,  0.  ])
 
     Notes
     -----
     Performs a numerical flux divergence operation on cells, and returns the
     result in an array of length equal to the number of nodes. Nodes without
     cells (those on the grid perimeter) are not affected (i.e., their value
     is either zero, or if `out` is given, whatever the prior value in `out`
```

### Comparing `landlab-2.7.0/landlab/grid/ext/raster_gradient.pyx` & `landlab-2.8.0/landlab/grid/ext/raster_gradient.pyx`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,8 @@
-import numpy as np
-
 cimport cython
-cimport numpy as cnp
 from cython.parallel cimport prange
 
 ctypedef fused float_or_int:
     cython.integral
     cython.floating
 
 
@@ -71,15 +68,17 @@
         for col in range(n_cols - 1):
             out[link + col] = (value_at_node[node + 1] - value_at_node[node]) * inv_dx
             node = node + 1
 
         # Vertical links
         node = row * n_cols
         for col in range(n_cols - 1, links_per_row):
-            out[link + col] = (value_at_node[node + n_cols] - value_at_node[node]) * inv_dy
+            out[link + col] = inv_dy * (
+                value_at_node[node + n_cols] - value_at_node[node]
+            )
             node = node + 1
 
     # The last row of horizontal links
     node = (n_rows - 1) * n_cols
     for link in range((n_rows - 1) * links_per_row, n_links):
         out[link] = (value_at_node[node + 1] - value_at_node[node]) * inv_dx
         node = node + 1
```

### Comparing `landlab-2.7.0/landlab/grid/framed_voronoi.py` & `landlab-2.8.0/landlab/grid/framed_voronoi.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/grid/gradients.py` & `landlab-2.8.0/landlab/grid/gradients.py`

 * *Files 2% similar despite different names*

```diff
@@ -371,20 +371,20 @@
     >>> z = mg.radius_at_node
     >>> slope_at_node = np.round(mg.calc_slope_at_node(elevs=z), decimals=5)
 
     >>> nodes_at_ring = [
     ...     np.where(np.isclose(mg.radius_at_node, radius)) for radius in range(3)
     ... ]
     >>> slope_at_node[nodes_at_ring[0]]
-    array([ 0.85707])
+    array([0.85707])
     >>> slope_at_node[nodes_at_ring[1]]
-    array([ 0.79417,  0.79417,  0.79417,  0.79417,  0.79417,  0.79417])
+    array([0.79417,  0.79417,  0.79417,  0.79417,  0.79417,  0.79417])
     >>> slope_at_node[nodes_at_ring[2]]
-    array([ 0.77542,  0.78453,  0.78453,  0.77542,  0.77542,  0.78453,
-            0.78453,  0.77542,  0.77542,  0.78453,  0.78453,  0.77542])
+    array([0.77542,  0.78453,  0.78453,  0.77542,  0.77542,  0.78453,
+           0.78453,  0.77542,  0.77542,  0.78453,  0.78453,  0.77542])
 
     :meta landlab: info-node, gradient, surface
     """
     if method not in ("patch_mean", "Horn"):
         raise ValueError("method name not understood")
 
     if not ignore_closed_nodes:
@@ -480,32 +480,32 @@
 
     Examples
     --------
     >>> from landlab import RasterModelGrid
     >>> mg = RasterModelGrid((4, 4))
     >>> z = mg.node_x**2 + mg.node_y**2
     >>> mg.calc_aspect_at_node(elevs=z)
-    array([ 225.        ,  240.16585039,  255.2796318 ,  258.69006753,
-            209.83414961,  225.        ,  243.54632481,  248.77808974,
-            194.7203682 ,  206.45367519,  225.        ,  231.94498651,
-            191.30993247,  201.22191026,  218.05501349,  225.        ])
+    array([225.        ,  240.16585039,  255.2796318 ,  258.69006753,
+           209.83414961,  225.        ,  243.54632481,  248.77808974,
+           194.7203682 ,  206.45367519,  225.        ,  231.94498651,
+           191.30993247,  201.22191026,  218.05501349,  225.        ])
     >>> z = z.max() - z
     >>> mg.calc_aspect_at_node(elevs=z)
-    array([ 45.        ,  60.16585039,  75.2796318 ,  78.69006753,
-            29.83414961,  45.        ,  63.54632481,  68.77808974,
-            14.7203682 ,  26.45367519,  45.        ,  51.94498651,
-            11.30993247,  21.22191026,  38.05501349,  45.        ])
+    array([45.        ,  60.16585039,  75.2796318 ,  78.69006753,
+           29.83414961,  45.        ,  63.54632481,  68.77808974,
+           14.7203682 ,  26.45367519,  45.        ,  51.94498651,
+           11.30993247,  21.22191026,  38.05501349,  45.        ])
 
     >>> mg = RasterModelGrid((4, 4), xy_spacing=(3.0, 2.0))
     >>> z = mg.node_x**2 + mg.node_y**2
     >>> mg.calc_aspect_at_node(elevs=z)
-    array([ 236.30993247,  247.52001262,  259.97326008,  262.40535663,
-            220.75264634,  234.41577266,  251.13402374,  255.29210302,
-            201.54258265,  215.47930877,  235.73541937,  242.24162456,
-            196.69924423,  209.43534223,  229.19345757,  236.30993247])
+    array([236.30993247,  247.52001262,  259.97326008,  262.40535663,
+           220.75264634,  234.41577266,  251.13402374,  255.29210302,
+           201.54258265,  215.47930877,  235.73541937,  242.24162456,
+           196.69924423,  209.43534223,  229.19345757,  236.30993247])
 
     Note that a small amount of asymmetry arises at the grid edges due
     to the "missing" nodes beyond the edge of the grid.
 
     :meta landlab: info-node, surface
     """
     if slope_component_tuple:
```

### Comparing `landlab-2.7.0/landlab/grid/grid_funcs.py` & `landlab-2.8.0/landlab/grid/grid_funcs.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """
 Utility functions that operate on landlab grids.
 ------------------------------------------------
 
 """
+
 import numpy as np
 
 
 def resolve_values_on_links(grid, link_values):
     """Resolve link values into x and y directions.
 
     Takes a set of values defined on active links, and returns those values
```

### Comparing `landlab-2.7.0/landlab/grid/hex.py` & `landlab-2.8.0/landlab/grid/hex.py`

 * *Files 2% similar despite different names*

```diff
@@ -267,15 +267,17 @@
         Creates and stores a PatchCollection representing the hexagons. Also
         stores a handle to the current plotting axis. Both of these are then
         used by hexplot().
         """
         import matplotlib
         from matplotlib.collections import PatchCollection
         from matplotlib.patches import Polygon
-        from numpy import array, sqrt, zeros
+        from numpy import array
+        from numpy import sqrt
+        from numpy import zeros
 
         # color
         if color_map is None:
             color_map = matplotlib.cm.jet
 
         # geometry
         apothem = self.spacing / 2.0
@@ -348,15 +350,17 @@
 
 
         :meta landlab: info-grid
         """
         import copy
 
         import matplotlib.pyplot as plt
-        from numpy import amax, amin, array
+        from numpy import amax
+        from numpy import amin
+        from numpy import array
 
         try:
             self._hexplot_configured
         except AttributeError:
             self._configure_hexplot(data, data_label, color_map)
         else:
             if self._hexplot_pc.cmap != color_map:
```

### Comparing `landlab-2.7.0/landlab/grid/hex_mappers.py` & `landlab-2.8.0/landlab/grid/hex_mappers.py`

 * *Files 2% similar despite different names*

```diff
@@ -55,47 +55,47 @@
 
     >>> grid = HexModelGrid((3, 3))
     >>> link_data = np.full(grid.number_of_links, 0.5 * 3.0**0.5)
     >>> link_data[np.isclose(grid.angle_of_link, 0.0)] = 0.0
 
     >>> vx, vy = map_link_vector_components_to_node(grid, link_data)
     >>> vx
-    array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
+    array([0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
     >>> vy
-    array([ 0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  0.,  0.])
+    array([0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  0.,  0.])
 
     >>> link_data = np.arange(grid.number_of_links)
     >>> vx, vy = map_link_vector_components_to_node(grid, link_data)
     >>> vx
-    array([ 0. ,  0. ,  0. ,  0. ,  8.5,  9.5,  0. ,  0. ,  0. ,  0. ])
+    array([0. ,  0. ,  0. ,  0. ,  8.5,  9.5,  0. ,  0. ,  0. ,  0. ])
 
     >>> link_data = np.full(grid.number_of_links, 0.5 * 3.0**0.5)
     >>> link_data[np.isclose(grid.angle_of_link, 2.0 / 3.0 * np.pi)] = 0.0
 
     >>> vx, vy = map_link_vector_components_to_node(grid, link_data)
     >>> np.round(vx, 3)
-    array([ 0. ,  0. ,  0. ,  0. ,  0.866,  0.866,  0. ,  0. ,  0. ,  0. ])
+    array([0. ,  0. ,  0. ,  0. ,  0.866,  0.866,  0. ,  0. ,  0. ,  0. ])
     >>> vy
-    array([ 0. ,  0. ,  0. ,  0. ,  0.5,  0.5,  0. ,  0. ,  0. ,  0. ])
+    array([0. ,  0. ,  0. ,  0. ,  0.5,  0.5,  0. ,  0. ,  0. ,  0. ])
 
     >>> grid = HexModelGrid((3, 3), orientation="vertical")
     >>> link_data = np.arange(grid.number_of_links)
 
     >>> vx, vy = map_link_vector_components_to_node(grid, link_data)
     >>> vy
     array([ 0. , 0. ,  0. ,  5.5,  0. ,  0. , 12.5,  0. ,  0. ,  0. ])
 
     >>> link_data = np.full(grid.number_of_links, 0.5 * 3.0**0.5)
     >>> link_data[np.isclose(grid.angle_of_link, np.pi / 2.0)] = 0.0
 
     >>> vx, vy = map_link_vector_components_to_node(grid, link_data)
     >>> vx
-    array([ 0.,  0.,  0.,  1.,  0.,  0.,  1.,  0.,  0.,  0.])
+    array([0.,  0.,  0.,  1.,  0.,  0.,  1.,  0.,  0.,  0.])
     >>> vy
-    array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
+    array([0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
 
     Notes
     -----
     Calculation is only made for core nodes; boundary nodes receive zeros.
         For a grid with orientation='horizontal', one of the 3 link orientations
     is horizontal. The x component is therefore taken as the average value of
     the links to the east (right) and west (left). For a grid with
```

### Comparing `landlab-2.7.0/landlab/grid/linkstatus.py` & `landlab-2.8.0/landlab/grid/linkstatus.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 #! /usr/bin/env python
-from enum import IntEnum, unique
+from enum import IntEnum
+from enum import unique
 
 import numpy as np
 
 from .nodestatus import NodeStatus
 
 
 @unique
@@ -35,26 +36,26 @@
         True if link is fixed.
 
     Examples
     --------
     >>> from landlab.grid.linkstatus import is_fixed_link
     >>> from landlab import NodeStatus
     >>> is_fixed_link([NodeStatus.CORE, NodeStatus.FIXED_GRADIENT])
-    array([ True], dtype=bool)
+    array([ True])
 
     >>> is_fixed_link([NodeStatus.CORE, NodeStatus.FIXED_VALUE])
-    array([False], dtype=bool)
+    array([False])
 
     >>> is_fixed_link(
     ...     [
     ...         [NodeStatus.FIXED_GRADIENT, NodeStatus.CORE],
     ...         [NodeStatus.CORE, NodeStatus.CORE],
     ...     ]
     ... )
-    array([ True, False], dtype=bool)
+    array([ True, False])
     """
     node_status_at_link = np.asarray(node_status_at_link).reshape((-1, 2))
 
     is_core_node = node_status_at_link == NodeStatus.CORE
     is_fixed_gradient_node = node_status_at_link == NodeStatus.FIXED_GRADIENT
 
     return (is_core_node[:, 0] & is_fixed_gradient_node[:, 1]) | (
@@ -79,26 +80,26 @@
         True if link is isactive.
 
     Examples
     --------
     >>> from landlab.grid.linkstatus import is_inactive_link
     >>> from landlab import NodeStatus
     >>> is_inactive_link([NodeStatus.CORE, NodeStatus.CLOSED])
-    array([ True], dtype=bool)
+    array([ True])
 
     >>> is_inactive_link([NodeStatus.FIXED_GRADIENT, NodeStatus.FIXED_VALUE])
-    array([ True], dtype=bool)
+    array([ True])
 
     >>> is_inactive_link(
     ...     [
     ...         [NodeStatus.FIXED_GRADIENT, NodeStatus.CLOSED],
     ...         [NodeStatus.CORE, NodeStatus.CORE],
     ...     ]
     ... )
-    array([ True, False], dtype=bool)
+    array([ True, False])
     """
     node_status_at_link = np.asarray(node_status_at_link).reshape((-1, 2))
 
     is_core = node_status_at_link == NodeStatus.CORE
     is_fixed_value = node_status_at_link == NodeStatus.FIXED_VALUE
     is_fixed_gradient = node_status_at_link == NodeStatus.FIXED_GRADIENT
     is_closed = node_status_at_link == NodeStatus.CLOSED
@@ -128,26 +129,26 @@
         True if link is isactive.
 
     Examples
     --------
     >>> from landlab.grid.linkstatus import is_active_link
     >>> from landlab import NodeStatus
     >>> is_active_link([NodeStatus.CORE, NodeStatus.FIXED_GRADIENT])
-    array([False], dtype=bool)
+    array([False])
 
     >>> is_active_link([NodeStatus.CORE, NodeStatus.FIXED_VALUE])
-    array([ True], dtype=bool)
+    array([ True])
 
     >>> is_active_link(
     ...     [
     ...         [NodeStatus.FIXED_GRADIENT, NodeStatus.CORE],
     ...         [NodeStatus.CORE, NodeStatus.CORE],
     ...     ]
     ... )
-    array([False, True], dtype=bool)
+    array([False, True])
     """
     node_status_at_link = np.asarray(node_status_at_link).reshape((-1, 2))
 
     is_core_node = node_status_at_link == NodeStatus.CORE
     is_fixed_value_node = node_status_at_link == NodeStatus.FIXED_VALUE
     return (
         (is_core_node[:, 0] & is_core_node[:, 1])
```

### Comparing `landlab-2.7.0/landlab/grid/mappers.py` & `landlab-2.8.0/landlab/grid/mappers.py`

 * *Files 1% similar despite different names*

```diff
@@ -548,20 +548,20 @@
     >>> import numpy as np
     >>> from landlab.grid.mappers import map_node_to_cell
     >>> from landlab import RasterModelGrid
 
     >>> rmg = RasterModelGrid((3, 4))
     >>> _ = rmg.add_field("z", np.arange(12.0), at="node")
     >>> map_node_to_cell(rmg, "z")
-    array([ 5.,  6.])
+    array([5.,  6.])
 
     >>> values_at_cells = rmg.empty(at="cell")
     >>> rtn = map_node_to_cell(rmg, "z", out=values_at_cells)
     >>> values_at_cells
-    array([ 5.,  6.])
+    array([5.,  6.])
     >>> rtn is values_at_cells
     True
 
     :meta landlab: info-cell, info-node, map
     """
     if out is None:
         out = grid.empty(at="cell")
@@ -743,24 +743,24 @@
     ...     -2.3,
     ...     2.4,
     ...     2.5,
     ...     2.6,
     ...     -2.7,
     ... ]
     >>> map_upwind_node_link_max_to_node(rmg, "grad").reshape((3, 4))
-    array([[ 1.4,  1.5,  1.6,  1.3],
-           [ 2.1,  2.2,  2. ,  2.4],
-           [ 2.5,  2.6,  2.3,  2.7]])
+    array([[1.4,  1.5,  1.6,  1.3],
+           [2.1,  2.2,  2. ,  2.4],
+           [2.5,  2.6,  2.3,  2.7]])
 
     >>> values_at_nodes = rmg.add_empty("z", at="node")
     >>> rtn = map_upwind_node_link_max_to_node(rmg, "grad", out=values_at_nodes)
     >>> values_at_nodes.reshape((3, 4))
-    array([[ 1.4,  1.5,  1.6,  1.3],
-           [ 2.1,  2.2,  2. ,  2.4],
-           [ 2.5,  2.6,  2.3,  2.7]])
+    array([[1.4,  1.5,  1.6,  1.3],
+           [2.1,  2.2,  2. ,  2.4],
+           [2.5,  2.6,  2.3,  2.7]])
     >>> rtn is values_at_nodes
     True
 
     :meta landlab: info-node, info-link, map
     """
     if out is None:
         out = grid.empty(at="node")
@@ -822,24 +822,24 @@
     ...     0.0,
     ...     0.0,
     ...     -1.0,
     ...     -2.0,
     ...     -1.0,
     ... ]
     >>> map_downwind_node_link_max_to_node(rmg, "grad")
-    array([ 1.,  2.,  1.,  0.,
-            1.,  2.,  1.,  0.,
-            1.,  2.,  1.,  0.])
+    array([1.,  2.,  1.,  0.,
+           1.,  2.,  1.,  0.,
+           1.,  2.,  1.,  0.])
 
     >>> values_at_nodes = rmg.add_empty("z", at="node")
     >>> rtn = map_downwind_node_link_max_to_node(rmg, "grad", out=values_at_nodes)
     >>> values_at_nodes
-    array([ 1.,  2.,  1.,  0.,
-            1.,  2.,  1.,  0.,
-            1.,  2.,  1.,  0.])
+    array([1.,  2.,  1.,  0.,
+           1.,  2.,  1.,  0.,
+           1.,  2.,  1.,  0.])
     >>> rtn is values_at_nodes
     True
 
     :meta landlab: info-node, info-link, map
     """
     if out is None:
         out = grid.empty(at="node")
@@ -902,24 +902,24 @@
     ...     -3.0,
     ...     -4.0,
     ...     -1.0,
     ...     -2.0,
     ...     -1.0,
     ... ]
     >>> map_upwind_node_link_mean_to_node(rmg, "grad")
-    array([ 0. ,  1. ,  2. ,  1. ,
-            2. ,  2. ,  3. ,  3. ,
-            1. ,  1.5,  2.5,  2.5])
+    array([0. ,  1. ,  2. ,  1. ,
+           2. ,  2. ,  3. ,  3. ,
+           1. ,  1.5,  2.5,  2.5])
 
     >>> values_at_nodes = rmg.add_empty("z", at="node")
     >>> rtn = map_upwind_node_link_mean_to_node(rmg, "grad", out=values_at_nodes)
     >>> values_at_nodes
-    array([ 0. ,  1. ,  2. ,  1. ,
-            2. ,  2. ,  3. ,  3. ,
-            1. ,  1.5,  2.5,  2.5])
+    array([0. ,  1. ,  2. ,  1. ,
+           2. ,  2. ,  3. ,  3. ,
+           1. ,  1.5,  2.5,  2.5])
     >>> rtn is values_at_nodes
     True
 
     :meta landlab: info-node, info-link, map
     """
     if out is None:
         out = grid.empty(at="node")
@@ -987,24 +987,24 @@
     ...     -3.0,
     ...     -4.0,
     ...     -1.0,
     ...     -2.0,
     ...     -1.0,
     ... ]
     >>> map_downwind_node_link_mean_to_node(rmg, "grad")
-    array([ 1.5,  2.5,  2.5,  5. ,
-            1. ,  2. ,  2. ,  4. ,
-            1. ,  2. ,  1. ,  0. ])
+    array([1.5,  2.5,  2.5,  5. ,
+           1. ,  2. ,  2. ,  4. ,
+           1. ,  2. ,  1. ,  0. ])
 
     >>> values_at_nodes = rmg.add_empty("z", at="node")
     >>> rtn = map_downwind_node_link_mean_to_node(rmg, "grad", out=values_at_nodes)
     >>> values_at_nodes
-    array([ 1.5,  2.5,  2.5,  5. ,
-            1. ,  2. ,  2. ,  4. ,
-            1. ,  2. ,  1. ,  0. ])
+    array([1.5,  2.5,  2.5,  5. ,
+           1. ,  2. ,  2. ,  4. ,
+           1. ,  2. ,  1. ,  0. ])
     >>> rtn is values_at_nodes
     True
 
     :meta landlab: info-node, info-link, map
     """
     if out is None:
         out = grid.empty(at="node")
@@ -1243,28 +1243,28 @@
     >>> rmg = RasterModelGrid((3, 4))
     >>> rmg.at_node["vals"] = [
     ...     [5.0, 4.0, 3.0, 2.0],
     ...     [5.0, 4.0, 3.0, 2.0],
     ...     [3.0, 2.0, 1.0, 0.0],
     ... ]
     >>> map_mean_of_patch_nodes_to_patch(rmg, "vals")
-    array([ 4.5, 3.5, 2.5,
-            3.5, 2.5, 1.5])
+    array([4.5, 3.5, 2.5,
+           3.5, 2.5, 1.5])
 
     >>> rmg.at_node["vals"] = [
     ...     [5.0, 4.0, 3.0, 2.0],
     ...     [5.0, 4.0, 3.0, 2.0],
     ...     [3.0, 2.0, 1.0, 0.0],
     ... ]
     >>> rmg.status_at_node[rmg.node_x > 1.5] = rmg.BC_NODE_IS_CLOSED
     >>> ans = np.zeros(6, dtype=float)
     >>> _ = map_mean_of_patch_nodes_to_patch(rmg, "vals", out=ans)
     >>> ans
-    array([ 4.5, 4. , 0. ,
-            3.5, 3. , 0. ])
+    array([4.5, 4. , 0. ,
+           3.5, 3. , 0. ])
 
     :meta landlab: info-patch, info-node, map
     """
     if out is None:
         out = np.zeros(grid.number_of_patches, dtype=float)
 
     if type(var_name) is str:
@@ -1319,28 +1319,28 @@
     >>> rmg = RasterModelGrid((3, 4))
     >>> rmg.at_node["vals"] = [
     ...     [5.0, 4.0, 3.0, 2.0],
     ...     [3.0, 4.0, 3.0, 2.0],
     ...     [3.0, 2.0, 1.0, 0.0],
     ... ]
     >>> map_max_of_patch_nodes_to_patch(rmg, "vals")
-    array([ 5., 4., 3.,
-            4., 4., 3.])
+    array([5., 4., 3.,
+           4., 4., 3.])
 
     >>> rmg.at_node["vals"] = [
     ...     [5.0, 4.0, 3.0, 2.0],
     ...     [3.0, 4.0, 3.0, 2.0],
     ...     [3.0, 2.0, 1.0, 0.0],
     ... ]
     >>> rmg.status_at_node[rmg.node_x > 1.5] = rmg.BC_NODE_IS_CLOSED
     >>> ans = np.zeros(6, dtype=float)
     >>> _ = map_max_of_patch_nodes_to_patch(rmg, "vals", out=ans)
     >>> ans
-    array([ 5., 4., 0.,
-            4., 4., 0.])
+    array([5., 4., 0.,
+           4., 4., 0.])
 
     :meta landlab: info-patch, info-node, map
     """
     if out is None:
         out = np.zeros(grid.number_of_patches, dtype=float)
 
     if type(var_name) is str:
@@ -1395,28 +1395,28 @@
     >>> rmg = RasterModelGrid((3, 4))
     >>> rmg.at_node["vals"] = [
     ...     [5.0, 4.0, 3.0, 2.0],
     ...     [5.0, 4.0, 3.0, 2.0],
     ...     [3.0, 2.0, 1.0, 0.0],
     ... ]
     >>> map_min_of_patch_nodes_to_patch(rmg, "vals")
-    array([ 4., 3., 2.,
-            2., 1., 0.])
+    array([4., 3., 2.,
+           2., 1., 0.])
 
     >>> rmg.at_node["vals"] = [
     ...     [5.0, 4.0, 3.0, 2.0],
     ...     [5.0, 4.0, 3.0, 2.0],
     ...     [3.0, 2.0, 1.0, 0.0],
     ... ]
     >>> rmg.status_at_node[rmg.node_x > 1.5] = rmg.BC_NODE_IS_CLOSED
     >>> ans = np.zeros(6, dtype=float)
     >>> _ = map_min_of_patch_nodes_to_patch(rmg, "vals", out=ans)
     >>> ans
-    array([ 4., 4., 0.,
-            2., 2., 0.])
+    array([4., 4., 0.,
+           2., 2., 0.])
 
     :meta landlab: info-patch, info-node, map
     """
     if out is None:
         out = np.zeros(grid.number_of_patches, dtype=float)
 
     if type(var_name) is str:
@@ -1572,24 +1572,25 @@
     >>> from landlab import RasterModelGrid, HexModelGrid
 
     >>> grid = RasterModelGrid((3, 4))
     >>> link_data = np.arange(grid.number_of_links)
 
     >>> vx, vy = map_link_vector_components_to_node(grid, link_data)
     >>> vx[5:7]
-    array([ 7.5, 8.5])
+    array([7.5, 8.5])
 
     >>> grid = HexModelGrid((3, 3))
     >>> link_data = np.zeros(grid.number_of_links) + 0.5 * 3.0**0.5
     >>> link_data[np.isclose(grid.angle_of_link, 0.0)] = 0.0
     >>> vx, vy = map_link_vector_components_to_node(grid, link_data)
     >>> vy
-    array([ 0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  0.,  0.])
+    array([0.,  0.,  0.,  0.,  1.,  1.,  0.,  0.,  0.,  0.])
     """
-    from landlab import HexModelGrid, RasterModelGrid
+    from landlab import HexModelGrid
+    from landlab import RasterModelGrid
 
     if isinstance(grid, HexModelGrid):
         from .hex_mappers import map_link_vector_components_to_node_hex
 
         return map_link_vector_components_to_node_hex(grid, data_at_link)
     elif isinstance(grid, RasterModelGrid):
         from .raster_mappers import map_link_vector_components_to_node_raster
@@ -1653,18 +1654,18 @@
     >>> u = grid.add_zeros("advection_speed", at="link")
     >>> u[grid.horizontal_links] = 1.0
 
     Set values for the middle row of horizontal links.
 
     >>> val_at_link = map_node_to_link_linear_upwind(grid, v, u)
     >>> val_at_link[9:13]
-    array([ 0.,  1.,  2.,  3.])
+    array([0.,  1.,  2.,  3.])
     >>> val_at_link = map_node_to_link_linear_upwind(grid, v, -u)
     >>> val_at_link[9:13]
-    array([ 1.,  2.,  3.,  4.])
+    array([1.,  2.,  3.,  4.])
     """
     if out is None:
         out = np.empty_like(v, shape=(grid.number_of_links,))
 
     u_is_positive = u > 0.0
     out[u_is_positive] = v[grid.node_at_link_tail[u_is_positive]]
     out[~u_is_positive] = v[grid.node_at_link_head[~u_is_positive]]
@@ -1723,18 +1724,18 @@
     >>> c = grid.add_zeros("courant_number", at="link")
     >>> c[grid.horizontal_links] = 0.2
 
     Set values for the middle row of horizontal links.
 
     >>> val_at_link = map_node_to_link_lax_wendroff(grid, v, c)
     >>> val_at_link[9:13]
-    array([ 0.4,  1.4,  2.4,  3.4])
+    array([0.4,  1.4,  2.4,  3.4])
     >>> val_at_link = map_node_to_link_lax_wendroff(grid, v, -c)
     >>> val_at_link[9:13]
-    array([ 0.6,  1.6,  2.6,  3.6])
+    array([0.6,  1.6,  2.6,  3.6])
     """
     if out is None:
         out = np.empty_like(v, shape=(grid.number_of_links,))
 
     out[:] = 0.5 * (
         (1 + c) * v[grid.node_at_link_tail] + (1 - c) * v[grid.node_at_link_head]
     )
```

### Comparing `landlab-2.7.0/landlab/grid/network.py` & `landlab-2.8.0/landlab/grid/network.py`

 * *Files 0% similar despite different names*

```diff
@@ -8,16 +8,18 @@
 
 from ..core import load_params
 from ..core.utils import add_module_functions_to_class
 from ..field import GraphFields
 from ..graph import NetworkGraph
 from ..utils.decorators import cache_result_in_object
 from .base import BAD_INDEX_VALUE
-from .decorators import override_array_setitem_and_reset, return_readonly_id_array
-from .linkstatus import LinkStatus, set_status_at_link
+from .decorators import override_array_setitem_and_reset
+from .decorators import return_readonly_id_array
+from .linkstatus import LinkStatus
+from .linkstatus import set_status_at_link
 from .nodestatus import NodeStatus
 
 
 class NetworkModelGrid(NetworkGraph, GraphFields):
     """Create a ModelGrid of just nodes and links.
 
     Parameters
@@ -36,15 +38,15 @@
     >>> y_of_node = (0, 1, 2, 2)
     >>> x_of_node = (0, 0, -1, 1)
     >>> nodes_at_link = ((1, 0), (2, 1), (3, 1))
     >>> grid = NetworkModelGrid((y_of_node, x_of_node), nodes_at_link)
     >>> grid.x_of_node
     array([ 0.,  0., -1.,  1.])
     >>> grid.y_of_node
-    array([ 0.,  1.,  2.,  2.])
+    array([0.,  1.,  2.,  2.])
     >>> grid.nodes_at_link
     array([[0, 1],
            [2, 1],
            [1, 3]])
     """
 
     #: Indicates a node is *bad index*.
@@ -364,15 +366,15 @@
         --------
         >>> from landlab import NetworkModelGrid
         >>> y_of_node = (0, 1, 2, 2)
         >>> x_of_node = (0, 0, -1, 1)
         >>> nodes_at_link = ((1, 0), (2, 1), (3, 1))
         >>> grid = NetworkModelGrid((y_of_node, x_of_node), nodes_at_link)
         >>> grid.y_of_link
-        array([ 0.5,  1.5,  1.5])
+        array([0.5,  1.5,  1.5])
 
         :meta landlab: info-link, quantity
         """
         return np.mean(self.y_of_node[self.nodes_at_link], axis=1)
 
 
 # add only the correct functions
```

### Comparing `landlab-2.7.0/landlab/grid/radial.py` & `landlab-2.8.0/landlab/grid/radial.py`

 * *Files 0% similar despite different names*

```diff
@@ -11,15 +11,14 @@
 import xarray as xr
 
 from ..graph import DualRadialGraph
 from .base import ModelGrid
 
 
 class RadialModelGrid(DualRadialGraph, ModelGrid):
-
     """Grid of concentric circles.
 
     This inherited class implements a circular grid in which grid nodes are
     placed at regular radial and semi-regular arc-wise intervals. That is,
     if the radial spacing between *shells* is *dr*, the nodes are placed around
     the circular shell at regular intervals that get as close as possible to
     *dr*. The points are then arranged in a Delaunay triangulation with Voronoi
@@ -87,16 +86,16 @@
         A second rings will have 16 nodes (1 + 8 + 16 = 25).
 
         >>> omg = RadialModelGrid(2, nodes_in_first_ring=8)
         >>> omg.number_of_nodes
         25
 
         >>> np.round(omg.radius_at_node)
-        array([ 2.,  2.,  2.,  2.,  2.,  1.,  2.,  2.,  1.,  1.,  2.,  1.,  0.,
-                1.,  2.,  1.,  1.,  2.,  2.,  1.,  2.,  2.,  2.,  2.,  2.])
+        array([2.,  2.,  2.,  2.,  2.,  1.,  2.,  2.,  1.,  1.,  2.,  1.,  0.,
+               1.,  2.,  1.,  1.,  2.,  2.,  1.,  2.,  2.,  2.,  2.,  2.])
         """
         xy_of_center = tuple(xy_of_center)
 
         DualRadialGraph.__init__(
             self,
             (n_rings, nodes_in_first_ring),
             spacing=spacing,
```

### Comparing `landlab-2.7.0/landlab/grid/raster.py` & `landlab-2.8.0/landlab/grid/raster.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,15 +10,16 @@
 
 import numpy as np
 import xarray as xr
 
 from landlab.utils import structured_grid as sgrid
 from landlab.utils.decorators import make_return_array_immutable
 
-from ..core.utils import add_module_functions_to_class, as_id_array
+from ..core.utils import add_module_functions_to_class
+from ..core.utils import as_id_array
 from ..field import FieldError
 from ..graph import DualUniformRectilinearGraph
 from . import raster_funcs as rfuncs
 from .base import ModelGrid
 from .decorators import return_id_array
 from .diagonals import DiagonalsMixIn
 from .nodestatus import NodeStatus
@@ -99,15 +100,14 @@
     return [
         boundary_conditions.get(loc, "open") == "closed"
         for loc in ["right", "top", "left", "bottom"]
     ]
 
 
 class RasterModelGrid(DiagonalsMixIn, DualUniformRectilinearGraph, ModelGrid):
-
     """A 2D uniform rectilinear grid.
 
     Examples
     --------
     Create a uniform rectilinear grid that has 4 rows and 5 columns of nodes.
     Nodes along the edges will be *open*. That is, links connecting these
     nodes to core nodes are *active*.
@@ -131,23 +131,23 @@
     A `RasterModelGrid` can have different node spacings in the *x* and *y*
     directions.
 
     >>> grid = RasterModelGrid((4, 5), xy_spacing=(2, 1))
     >>> grid.dx, grid.dy
     (2.0, 1.0)
     >>> grid.node_y.reshape(grid.shape)
-    array([[ 0.,  0.,  0.,  0.,  0.],
-           [ 1.,  1.,  1.,  1.,  1.],
-           [ 2.,  2.,  2.,  2.,  2.],
-           [ 3.,  3.,  3.,  3.,  3.]])
+    array([[0.,  0.,  0.,  0.,  0.],
+           [1.,  1.,  1.,  1.,  1.],
+           [2.,  2.,  2.,  2.,  2.],
+           [3.,  3.,  3.,  3.,  3.]])
     >>> grid.node_x.reshape(grid.shape)
-    array([[ 0.,  2.,  4.,  6.,  8.],
-           [ 0.,  2.,  4.,  6.,  8.],
-           [ 0.,  2.,  4.,  6.,  8.],
-           [ 0.,  2.,  4.,  6.,  8.]])
+    array([[0.,  2.,  4.,  6.,  8.],
+           [0.,  2.,  4.,  6.,  8.],
+           [0.,  2.,  4.,  6.,  8.],
+           [0.,  2.,  4.,  6.,  8.]])
     """
 
     def __init__(
         self,
         shape,
         xy_spacing=1.0,
         xy_of_lower_left=(0.0, 0.0),
@@ -428,26 +428,26 @@
         left and right columns (only one horizontal link) and top and bottom
         rows (only one vertical link).
 
         >>> from landlab import RasterModelGrid
         >>> mg = RasterModelGrid((3, 4), xy_spacing=(2.0, 2.0))
 
         >>> mg.unit_vector_at_link[:, 0]
-        array([ 1.,  1.,  1.,  0.,  0.,  0.,  0.,
-                1.,  1.,  1.,  0.,  0.,  0.,  0.,
-                1.,  1.,  1.])
+        array([1.,  1.,  1.,  0.,  0.,  0.,  0.,
+               1.,  1.,  1.,  0.,  0.,  0.,  0.,
+               1.,  1.,  1.])
         >>> mg.unit_vector_at_link[:, 1]
-        array([ 0.,  0.,  0.,  1.,  1.,  1.,  1.,
-                0.,  0.,  0.,  1.,  1.,  1.,  1.,
-                0.,  0.,  0.])
+        array([0.,  0.,  0.,  1.,  1.,  1.,  1.,
+               0.,  0.,  0.,  1.,  1.,  1.,  1.,
+               0.,  0.,  0.])
 
         >>> mg.unit_vector_at_node[:, 0]
-        array([ 1.,  2.,  2.,  1.,  1.,  2.,  2.,  1.,  1.,  2.,  2.,  1.])
+        array([1.,  2.,  2.,  1.,  1.,  2.,  2.,  1.,  1.,  2.,  2.,  1.])
         >>> mg.unit_vector_at_node[:, 1]
-        array([ 1.,  1.,  1.,  1.,  2.,  2.,  2.,  2.,  1.,  1.,  1.,  1.])
+        array([1.,  1.,  1.,  1.,  2.,  2.,  2.,  2.,  1.,  1.,  1.,  1.])
         """
         unit_vec_at_link = np.zeros((self.number_of_links + 1, 2), dtype=float)
         unit_vec_at_link[self.horizontal_links, 0] = 1.0
         unit_vec_at_link[self.vertical_links, 1] = 1.0
 
         self._unit_vec_at_node = unit_vec_at_link[self.links_at_node].sum(axis=1)
         self._unit_vec_at_link = unit_vec_at_link[:-1, :]
@@ -592,17 +592,17 @@
         >>> grid = RasterModelGrid((4, 5), xy_spacing=(1, 2))
         >>> grid.is_point_on_grid(1, 1)
         True
         >>> grid.is_point_on_grid(
         ...     (1, 1, 1),
         ...     (1, 3.1, 6.1),
         ... )
-        array([ True,  True, False], dtype=bool)
+        array([ True,  True, False])
         >>> grid.is_point_on_grid((-0.1, 0.1, 3.9, 4.1), (1, 1, 1, 1))
-        array([False,  True,  True, False], dtype=bool)
+        array([False,  True,  True, False])
 
         :meta landlab: info-grid, quantity, subset
         """
         xcoord, ycoord = np.asarray(xcoord), np.asarray(ycoord)
 
         x_condition = (xcoord > 0.0) & (xcoord < (self.shape[1] - 1) * self.dx)
         y_condition = (ycoord > 0.0) & (ycoord < (self.shape[0] - 1) * self.dy)
@@ -1032,16 +1032,16 @@
         17
         >>> rmg.status_at_node.reshape(rmg.shape)
         array([[1, 1, 1, 1, 1],
                [1, 0, 0, 0, 1],
                [1, 0, 0, 0, 1],
                [1, 1, 1, 1, 1]], dtype=uint8)
         >>> rmg.add_zeros("topographic__elevation", at="node")
-        array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,
-                0.,  0.,  0.,  0.,  0.,  0.,  0.])
+        array([0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,
+               0.,  0.,  0.,  0.,  0.,  0.,  0.])
         >>> rmg.set_looped_boundaries(True, True)
         >>> rmg.looped_node_properties["boundary_node_IDs"]
         array([ 0,  1,  2,  3,  4,  5,  9, 10, 14, 15, 16, 17, 18, 19])
         >>> rmg.looped_node_properties["linked_node_IDs"]
         array([10, 11, 12, 13, 14,  8,  6, 13, 11,  5,  6,  7,  8,  9])
 
         :meta landlab: boundary-condition, subset
@@ -1160,24 +1160,24 @@
         >>> u = rmg.zeros(centering="node")
         >>> u = u + range(0, len(u))
         >>> u
         array([ 0.,   1.,   2.,   3.,   4.,   5.,   6.,   7.,   8.,   9.,  10.,
                11.,  12.,  13.,  14.,  15.,  16.,  17.,  18.,  19.])
         >>> ur = rmg.node_vector_to_raster(u)
         >>> ur
-        array([[  0.,   1.,   2.,   3.,   4.],
-               [  5.,   6.,   7.,   8.,   9.],
-               [ 10.,  11.,  12.,  13.,  14.],
-               [ 15.,  16.,  17.,  18.,  19.]])
+        array([[ 0.,   1.,   2.,   3.,   4.],
+               [ 5.,   6.,   7.,   8.,   9.],
+               [10.,  11.,  12.,  13.,  14.],
+               [15.,  16.,  17.,  18.,  19.]])
         >>> ur = rmg.node_vector_to_raster(u, flip_vertically=True)
         >>> ur
-        array([[ 15.,  16.,  17.,  18.,  19.],
-               [ 10.,  11.,  12.,  13.,  14.],
-               [  5.,   6.,   7.,   8.,   9.],
-               [  0.,   1.,   2.,   3.,   4.]])
+        array([[15.,  16.,  17.,  18.,  19.],
+               [10.,  11.,  12.,  13.,  14.],
+               [ 5.,   6.,   7.,   8.,   9.],
+               [ 0.,   1.,   2.,   3.,   4.]])
 
         :meta landlab: info-grid, info-node
         """
         return sgrid.reshape_array(self.shape, u, flip_vertically=flip_vertically)
 
     def cell_vector_to_raster(self, u, flip_vertically=False):
         """Unravel a 1D array.
@@ -1193,23 +1193,23 @@
         Examples
         --------
         >>> from landlab import RasterModelGrid
         >>> rmg = RasterModelGrid((4, 5))
         >>> u = rmg.zeros(centering="cell")
         >>> u = u + range(0, len(u))
         >>> u
-        array([ 0.,  1.,  2.,  3.,  4.,  5.])
+        array([0.,  1.,  2.,  3.,  4.,  5.])
         >>> ur = rmg.cell_vector_to_raster(u)
         >>> ur
-        array([[ 0.,  1.,  2.],
-               [ 3.,  4.,  5.]])
+        array([[0.,  1.,  2.],
+               [3.,  4.,  5.]])
         >>> ur = rmg.cell_vector_to_raster(u, flip_vertically=True)
         >>> ur
-        array([[ 3.,  4.,  5.],
-               [ 0.,  1.,  2.]])
+        array([[3.,  4.,  5.],
+               [0.,  1.,  2.]])
 
         :meta landlab: info-grid, info-cell
         """
         return sgrid.reshape_array(
             (self.shape[0] - 2, self.shape[1] - 2), u, flip_vertically=flip_vertically
         )
 
@@ -1306,19 +1306,19 @@
         >>> from landlab import RasterModelGrid
         >>> mg = RasterModelGrid((5, 5))
         >>> mg.node_has_boundary_neighbor(6)
         True
         >>> mg.node_has_boundary_neighbor(12)
         False
         >>> mg.node_has_boundary_neighbor([12, -1])
-        array([False,  True], dtype=bool)
+        array([False,  True])
 
         >>> mg.node_has_boundary_neighbor(25)
         Traceback (most recent call last):
-            ...
+        ...
         IndexError: index 25 is out of bounds for axis 0 with size 25
 
         :meta landlab: info-node, connectivity, boundary-condition
         """
         ans = _node_has_boundary_neighbor(self, ids, method=method)
 
         if ans.ndim == 0:
@@ -1417,31 +1417,31 @@
         >>> import pytest
         >>> import numpy as np
         >>> from landlab import RasterModelGrid
         >>> grid = RasterModelGrid((3, 4), xy_spacing=(4, 4))
         >>> z = np.array([0.0, 0.0, 0.0, 0.0, 3.0, 3.0, 3.0, 3, 6.0, 6.0, 6.0, 6.0])
         >>> slope, aspect = grid.calculate_slope_aspect_at_nodes_burrough(vals=z)
         >>> np.tan(slope)
-        array([ 0.75,  0.75])
+        array([0.75,  0.75])
         >>> np.degrees(aspect)
-        array([ 180.,  180.])
+        array([180.,  180.])
 
         We recommend using the following functions instead of this one:
         - :py:meth:`~landlab.grid.RasterModelGrid.calc_slope_at_node`
         - :py:meth:`~landlab.grid.RasterModelGrid.calc_aspect_at_node`
         Notice that :py:meth:`~landlab.grid.RasterModelGrid.calc_slope_at_node`
         and `:py:meth:`~landlab.grid.RasterModelGrid.calc_aspect_at_node` return
         values for all nodes, not just core nodes. In addition,
         `:py:meth:`~landlab.grid.RasterModelGrid.calc_aspect_at_node` returns
         compass-style angles in degrees.
 
         >>> np.tan(grid.calc_slope_at_node(elevs=z)[grid.core_nodes])
-        array([ 0.75,  0.75])
+        array([0.75,  0.75])
         >>> grid.calc_aspect_at_node(elevs=z)[grid.core_nodes]
-        array([ 180.,  180.])
+        array([180.,  180.])
 
         :meta landlab: info-node, surface, gradient
         """
         if ids is None:
             ids = self.node_at_cell
         if not isinstance(ids, np.ndarray):
             ids = np.array([ids])
```

### Comparing `landlab-2.7.0/landlab/grid/raster_aspect.py` & `landlab-2.8.0/landlab/grid/raster_aspect.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/grid/raster_divergence.py` & `landlab-2.8.0/landlab/grid/raster_divergence.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 #! /usr/bin/env python
 """Calculate flux divergence on a raster grid."""
-from landlab.utils.decorators import use_field_name_or_array
+import numpy as np
 
-from .ext.raster_divergence import calc_flux_div_at_node as _calc_flux_div_at_node_c
+from landlab.grid.ext.raster_divergence import _calc_flux_div_at_node
+from landlab.grid.ext.raster_divergence import _calc_net_face_flux_at_cell
+from landlab.utils.decorators import use_field_name_or_array
 
 
 @use_field_name_or_array("link")
 def calc_flux_div_at_node(grid, unit_flux, out=None):
     """Calculate divergence of link-based fluxes at nodes.
 
     Given a flux per unit width across each face in the grid, calculate the net
@@ -43,31 +45,31 @@
     array([[ 0. ,  0. ,  0. ],
            [ 5. , -1.4, -3.6],
            [ 0. ,  0. ,  0. ]])
     >>> grads[grid.vertical_links].reshape((2, 4))
     array([[ 0. ,  5. ,  3.6,  0. ],
            [ 0. , -5. , -3.6,  0. ]])
     >>> calc_flux_div_at_node(grid, -grads).reshape(grid.shape)
-    array([[ 0.  ,  0.  ,  0.  ,  0.  ],
-           [ 0.  ,  1.64,  0.94,  0.  ],
-           [ 0.  ,  0.  ,  0.  ,  0.  ]])
+    array([[0.  ,  0.  ,  0.  ,  0.  ],
+           [0.  ,  1.64,  0.94,  0.  ],
+           [0.  ,  0.  ,  0.  ,  0.  ]])
 
     >>> grid.set_status_at_node_on_edges(right=grid.BC_NODE_IS_CLOSED)
     >>> grid.set_status_at_node_on_edges(top=grid.BC_NODE_IS_CLOSED)
     >>> unit_flux_at_links = grid.zeros(at="link")
     >>> unit_flux_at_links[grid.active_links] = -grads[grid.active_links]
     >>> calc_flux_div_at_node(grid, unit_flux_at_links).reshape(grid.shape)
-    array([[ 0.  ,  0.  ,  0.  ,  0.  ],
-           [ 0.  ,  1.14,  0.22,  0.  ],
-           [ 0.  ,  0.  ,  0.  ,  0.  ]])
+    array([[0.  ,  0.  ,  0.  ,  0.  ],
+           [0.  ,  1.14,  0.22,  0.  ],
+           [0.  ,  0.  ,  0.  ,  0.  ]])
     >>> _ = grid.add_field("neg_grad_at_link", -grads, at="link")
     >>> calc_flux_div_at_node(grid, "neg_grad_at_link").reshape(grid.shape)
-    array([[ 0.  ,  0.  ,  0.  ,  0.  ],
-           [ 0.  ,  1.64,  0.94,  0.  ],
-           [ 0.  ,  0.  ,  0.  ,  0.  ]])
+    array([[0.  ,  0.  ,  0.  ,  0.  ],
+           [0.  ,  1.64,  0.94,  0.  ],
+           [0.  ,  0.  ,  0.  ,  0.  ]])
 
     Notes
     -----
     Performs a numerical flux divergence operation on nodes.
 
     :meta landlab: info-node, gradient
     """
@@ -77,10 +79,24 @@
         out = grid.zeros(at="node")
     elif out.size != grid.number_of_nodes:
         raise ValueError("output buffer length mismatch with number of nodes")
 
     out.reshape(grid.shape)[:, (0, -1)] = 0.0
     out.reshape(grid.shape)[(0, -1), :] = 0.0
 
-    _calc_flux_div_at_node_c(grid.shape, (grid.dx, grid.dy), unit_flux, out)
+    _calc_flux_div_at_node(grid.shape, (grid.dx, grid.dy), unit_flux, out)
+
+    return out
+
+
+def calc_net_face_flux_at_cell(grid, unit_flux_at_face, out=None):
+    if len(unit_flux_at_face) != grid.number_of_faces:
+        raise ValueError("Parameter unit_flux_at_face must be num faces long")
+
+    if out is None:
+        out = grid.empty(at="cell")
+
+    _calc_net_face_flux_at_cell(
+        grid.shape, (grid.dx, grid.dy), np.asarray(unit_flux_at_face), out
+    )
 
     return out
```

### Comparing `landlab-2.7.0/landlab/grid/raster_funcs.py` & `landlab-2.8.0/landlab/grid/raster_funcs.py`

 * *Files 2% similar despite different names*

```diff
@@ -228,15 +228,15 @@
     >>> _value_is_in_bounds(0.5, (0, 1))
     True
     >>> _value_is_in_bounds(1, (0, 1))
     False
     >>> _value_is_in_bounds(0, (0, 1))
     True
     >>> _value_is_in_bounds(np.array((0, 1)), (0, 1))
-    array([ True, False], dtype=bool)
+    array([ True, False])
     """
     dummy = value >= bounds[0]
     dummy &= value < bounds[1]
     return dummy
 
 
 def _value_is_within_axis_bounds(rmg, value, axis):
@@ -296,18 +296,18 @@
     >>> is_coord_on_grid(grid, (3.999, 2.999))
     True
 
     Check two points with one call. Numpy broadcasting rules apply for the
     point coordinates.
 
     >>> is_coord_on_grid(grid, ([3.9, 4.1], 2.9))
-    array([ True, False], dtype=bool)
+    array([ True, False])
 
     >>> is_coord_on_grid(grid, ([3.9, 4.1], 2.9), axes=(0,))
-    array([ True,  True], dtype=bool)
+    array([ True,  True])
     """
     coords = np.broadcast_arrays(*coords)
 
     is_in_bounds = _value_is_within_axis_bounds(rmg, coords[1 - axes[0]], axes[0])
     for axis in axes[1:]:
         is_in_bounds &= _value_is_within_axis_bounds(rmg, coords[1 - axis], axis)
```

### Comparing `landlab-2.7.0/landlab/grid/raster_gradients.py` & `landlab-2.8.0/landlab/grid/raster_gradients.py`

 * *Files 5% similar despite different names*

```diff
@@ -10,21 +10,20 @@
     ~landlab.grid.raster_gradients.calc_grad_across_cell_faces
     ~landlab.grid.raster_gradients.calc_grad_across_cell_corners
 """
 from collections import deque
 
 import numpy as np
 
-from landlab.core.utils import make_optional_arg_into_id_array, radians_to_degrees
+from landlab.core.utils import make_optional_arg_into_id_array
+from landlab.core.utils import radians_to_degrees
 from landlab.utils.decorators import use_field_name_or_array
 
-from .ext.raster_gradient import (
-    calc_diff_at_link as _calc_diff_at_link_c,
-    calc_grad_at_link as _calc_grad_at_link_c,
-)
+from .ext.raster_gradient import calc_diff_at_link as _calc_diff_at_link_c
+from .ext.raster_gradient import calc_grad_at_link as _calc_grad_at_link_c
 
 
 @use_field_name_or_array("node")
 def calc_diff_at_d8(grid, node_values, out=None):
     """Calculate differences of node values over links and diagonals.
 
     Calculates the difference in quantity *node_values* at each link in the
@@ -327,29 +326,27 @@
     >>> from landlab import RasterModelGrid
     >>> grid = RasterModelGrid((3, 4))
     >>> x = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 3.0, 3.0, 3.0, 3.0])
 
     A decrease in quantity across a face is a negative gradient.
 
     >>> grid.calc_grad_across_cell_faces(x)
-    masked_array(data =
-     [[ 1.  3.  0.  0.]
-     [ 0.  2. -1. -1.]],
-                 mask =
-     False,
-           fill_value = 1e+20)
+    masked_array(
+      data=[[ 1.,  3.,  0.,  0.],
+            [ 0.,  2., -1., -1.]],
+      mask=False,
+      fill_value=1e+20)
 
     >>> grid = RasterModelGrid((3, 4), xy_spacing=(1, 2))
     >>> grid.calc_grad_across_cell_faces(x)
-    masked_array(data =
-     [[ 1.   1.5  0.   0. ]
-     [ 0.   1.  -1.  -0.5]],
-                  mask =
-     False,
-           fill_value = 1e+20)
+    masked_array(
+      data=[[ 1. , 1.5,  0. ,  0. ],
+            [ 0. , 1. , -1. , -0.5]],
+      mask=False,
+      fill_value=1e+20)
 
     :meta landlab: info-face, gradient
     """
     padded_node_values = np.empty(node_values.size + 1, dtype=float)
     padded_node_values[-1] = grid.BAD_INDEX
     padded_node_values[:-1] = node_values
     cell_ids = make_optional_arg_into_id_array(grid.number_of_cells, *args)
@@ -475,59 +472,57 @@
     >>> from landlab import RasterModelGrid
     >>> grid = RasterModelGrid((3, 3))
     >>> x = np.array([0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 2.0, 2.0, 2.0])
 
     A decrease in quantity across a face is a negative gradient.
 
     >>> grid.calc_grad_along_node_links(x)
-    masked_array(data =
-     [[-- -- -- --]
-     [-- 1.0 -- --]
-     [-- -- -- --]
-     [1.0 -- -- --]
-     [1.0 1.0 1.0 1.0]
-     [-- -- 1.0 --]
-     [-- -- -- --]
-     [-- -- -- 1.0]
-     [-- -- -- --]],
-                 mask =
-     [[ True  True  True  True]
-     [ True False  True  True]
-     [ True  True  True  True]
-     [False  True  True  True]
-     [False False False False]
-     [ True  True False  True]
-     [ True  True  True  True]
-     [ True  True  True False]
-     [ True  True  True  True]],
-           fill_value = 1e+20)
+    masked_array(
+      data=[[--, --, --, --],
+            [--, 1.0, --, --],
+            [--, --, --, --],
+            [1.0, --, --, --],
+            [1.0, 1.0, 1.0, 1.0],
+            [--, --, 1.0, --],
+            [--, --, --, --],
+            [--, --, --, 1.0],
+            [--, --, --, --]],
+      mask=[[ True,  True,  True,  True],
+            [ True, False,  True,  True],
+            [ True,  True,  True,  True],
+            [False,  True,  True,  True],
+            [False, False, False, False],
+            [ True,  True, False,  True],
+            [ True,  True,  True,  True],
+            [ True,  True,  True, False],
+            [ True,  True,  True,  True]],
+      fill_value=1e+20)
 
     >>> grid = RasterModelGrid((3, 3), xy_spacing=(4, 2))
     >>> grid.calc_grad_along_node_links(x)
-    masked_array(data =
-     [[-- -- -- --]
-     [-- 0.5 -- --]
-     [-- -- -- --]
-     [0.25 -- -- --]
-     [0.25 0.5 0.25 0.5]
-     [-- -- 0.25 --]
-     [-- -- -- --]
-     [-- -- -- 0.5]
-     [-- -- -- --]],
-                 mask =
-     [[ True  True  True  True]
-     [ True False  True  True]
-     [ True  True  True  True]
-     [False  True  True  True]
-     [False False False False]
-     [ True  True False  True]
-     [ True  True  True  True]
-     [ True  True  True False]
-     [ True  True  True  True]],
-           fill_value = 1e+20)
+    masked_array(
+      data=[[--, --, --, --],
+            [--, 0.5, --, --],
+            [--, --, --, --],
+            [0.25, --, --, --],
+            [0.25, 0.5, 0.25, 0.5],
+            [--, --, 0.25, --],
+            [--, --, --, --],
+            [--, --, --, 0.5],
+            [--, --, --, --]],
+      mask=[[ True,  True,  True,  True],
+            [ True, False,  True,  True],
+            [ True,  True,  True,  True],
+            [False,  True,  True,  True],
+            [False, False, False, False],
+            [ True,  True, False,  True],
+            [ True,  True,  True,  True],
+            [ True,  True,  True, False],
+            [ True,  True,  True,  True]],
+      fill_value=1e+20)
 
     :meta landlab: info-node, info-link, gradient
     """
     padded_node_values = np.empty(node_values.size + 1, dtype=float)
     padded_node_values[-1] = grid.BAD_INDEX
     padded_node_values[:-1] = node_values
     node_ids = make_optional_arg_into_id_array(grid.number_of_nodes, *args)
@@ -1178,16 +1173,16 @@
     >>> type(A) is tuple
     True
     >>> len(A)
     8
     >>> len(A[0]) == mg.number_of_cells
     True
     >>> A0
-    (array([ 180.]), array([ 270.]), array([ 90.]), array([ 180.]),
-     array([ 0.]), array([ 90.]), array([ 270.]), array([ 0.]))
+    (array([180.]), array([270.]), array([90.]), array([180.]),
+     array([0.]), array([90.]), array([270.]), array([0.]))
 
     :meta landlab: info-cell, surface
     """
 
     # calculate all subtriangle slopes
     (
         angle_ENE,
@@ -1579,30 +1574,30 @@
     >>> S = mg.calc_slope_at_patch(elevs=z)
     >>> S.size == mg.number_of_patches
     True
     >>> np.allclose(S, np.pi / 4.0)
     True
     >>> z = mg.node_y**2
     >>> mg.calc_slope_at_patch(elevs=z).reshape((3, 4))
-    array([[ 0.78539816,  0.78539816,  0.78539816,  0.78539816],
-           [ 1.24904577,  1.24904577,  1.24904577,  1.24904577],
-           [ 1.37340077,  1.37340077,  1.37340077,  1.37340077]])
+    array([[0.78539816,  0.78539816,  0.78539816,  0.78539816],
+           [1.24904577,  1.24904577,  1.24904577,  1.24904577],
+           [1.37340077,  1.37340077,  1.37340077,  1.37340077]])
 
     >>> z = mg.node_x.copy()
     >>> mg.set_closed_boundaries_at_grid_edges(True, True, True, True)
     >>> mg.status_at_node[11] = mg.BC_NODE_IS_CLOSED
     >>> mg.status_at_node[9] = mg.BC_NODE_IS_FIXED_VALUE
     >>> z[11] = 100.0  # this should get ignored now
     >>> z[9] = 2.0  # this should be felt by patch 7 only
     >>> mg.calc_slope_at_patch(elevs=z, ignore_closed_nodes=True).reshape(
     ...     (3, 4)
     ... ) * 4.0 / np.pi
-    array([[ 0.,  0.,  0.,  0.],
-           [ 0.,  1.,  1.,  1.],
-           [ 0.,  0.,  0.,  0.]])
+    array([[0.,  0.,  0.,  0.],
+           [0.,  1.,  1.,  1.],
+           [0.,  0.,  0.,  0.]])
 
     :meta landlab: info-patch, gradient
     """
     if subtriangle_unit_normals is not None:
         assert len(subtriangle_unit_normals) == 4
         assert subtriangle_unit_normals[0].shape[1] == 3
         assert subtriangle_unit_normals[1].shape[1] == 3
@@ -1826,18 +1821,18 @@
     True
     >>> np.allclose(cmp[1], -np.pi / 4.0)
     True
     >>> mg = RasterModelGrid((4, 4))
     >>> z = mg.node_x**2 + mg.node_y**2
     >>> slopes, cmp = mg.calc_slope_at_node(z, return_components=True)
     >>> slopes
-    array([ 0.95531662,  1.10991779,  1.32082849,  1.37713803,  1.10991779,
-            1.20591837,  1.3454815 ,  1.38904403,  1.32082849,  1.3454815 ,
-            1.39288142,  1.41562833,  1.37713803,  1.38904403,  1.41562833,
-            1.43030663])
+    array([0.95531662,  1.10991779,  1.32082849,  1.37713803,  1.10991779,
+           1.20591837,  1.3454815 ,  1.38904403,  1.32082849,  1.3454815 ,
+           1.39288142,  1.41562833,  1.37713803,  1.38904403,  1.41562833,
+           1.43030663])
 
     Check radial symmetry.
 
     >>> np.allclose(cmp[0].reshape((4, 4))[:, 0], cmp[1].reshape((4, 4))[0, :])
     True
 
     :meta landlab: info-node, gradient, surface
```

### Comparing `landlab-2.7.0/landlab/grid/raster_mappers.py` & `landlab-2.8.0/landlab/grid/raster_mappers.py`

 * *Files 0% similar despite different names*

```diff
@@ -554,15 +554,15 @@
     >>> import numpy as np
     >>> from landlab.grid.raster_mappers import map_min_of_outlinks_to_node
     >>> from landlab import RasterModelGrid
 
     >>> rmg = RasterModelGrid((3, 4))
     >>> _ = rmg.add_field("z", np.arange(17.0), at="link")
     >>> map_min_of_outlinks_to_node(rmg, "z")
-    array([ 0.,  1.,  2.,  0.,  7.,  8.,  9.,  0.,  0.,  0.,  0.,  0.])
+    array([0.,  1.,  2.,  0.,  7.,  8.,  9.,  0.,  0.,  0.,  0.,  0.])
 
     :meta landlab: info-node, info-link, map
     """
     if out is None:
         out = grid.empty(centering="node")
 
     if type(var_name) is str:
@@ -884,14 +884,14 @@
     Examples
     --------
     >>> from landlab import RasterModelGrid
     >>> rmg = RasterModelGrid((3, 4))
     >>> link_data = np.arange(rmg.number_of_links)
     >>> x, y = map_link_vector_components_to_node_raster(rmg, link_data)
     >>> x[5:7]
-    array([ 7.5,  8.5])
+    array([7.5,  8.5])
     >>> y[5:7]
-    array([ 7.5,  8.5])
+    array([7.5,  8.5])
     """
     x = grid.map_mean_of_horizontal_links_to_node(data_at_link)
     y = grid.map_mean_of_vertical_links_to_node(data_at_link)
     return x, y
```

### Comparing `landlab-2.7.0/landlab/grid/raster_set_status.py` & `landlab-2.8.0/landlab/grid/raster_set_status.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/grid/unstructured/base.py` & `landlab-2.8.0/landlab/grid/unstructured/base.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,13 @@
 import numpy as np
 
 from .cells import CellGrid
-from .links import LinkGrid, _split_link_ends, find_active_links
+from .links import LinkGrid
+from .links import _split_link_ends
+from .links import find_active_links
 from .nodes import NodeGrid
 from .status import StatusGrid
 
 
 def _default_axis_names(n_dims):
     """Returns a tuple of the default axis names."""
     _DEFAULT_NAMES = ("z", "y", "x")
@@ -37,22 +39,22 @@
     Examples
     --------
     >>> from landlab.grid.unstructured.base import BaseGrid
     >>> ngrid = BaseGrid(([0, 0, 1, 1], [0, 1, 0, 1]))
     >>> ngrid.number_of_nodes
     4
     >>> ngrid.x_at_node
-    array([ 0.,  1.,  0.,  1.])
+    array([0.,  1.,  0.,  1.])
     >>> ngrid.x_at_node[2]
     0.0
     >>> ngrid.point_at_node[2]
-    array([ 1.,  0.])
+    array([1.,  0.])
     >>> ngrid.coord_at_node[:, [2, 3]]
-    array([[ 1.,  1.],
-           [ 0.,  1.]])
+    array([[1.,  1.],
+           [0.,  1.]])
 
     >>> cells = ([0, 1, 2, 1, 3, 2], [3, 3], [0, 1])
     >>> ngrid = BaseGrid(([0, 0, 1, 1], [0, 1, 0, 1]), cells=cells)
     >>> ngrid.number_of_cells
     2
     >>> ngrid.node_at_cell
     array([0, 1])
@@ -106,22 +108,22 @@
         Examples
         --------
         >>> from landlab.grid.unstructured.base import BaseGrid
         >>> ngrid = BaseGrid(([0, 0, 1, 1], [0, 1, 0, 1]))
         >>> ngrid.number_of_nodes
         4
         >>> ngrid.x_at_node
-        array([ 0.,  1.,  0.,  1.])
+        array([0.,  1.,  0.,  1.])
         >>> ngrid.x_at_node[2]
         0.0
         >>> ngrid.point_at_node[2]
-        array([ 1.,  0.])
+        array([1.,  0.])
         >>> ngrid.coord_at_node[:, [2, 3]]
-        array([[ 1.,  1.],
-               [ 0.,  1.]])
+        array([[1.,  1.],
+               [0.,  1.]])
 
         >>> cells = ([0, 1, 2, 1, 3, 2], [3, 3], [0, 1])
         >>> ngrid = BaseGrid(([0, 0, 1, 1], [0, 1, 0, 1]), cells=cells)
         >>> ngrid.number_of_cells
         2
         >>> ngrid.node_at_cell
         array([0, 1])
@@ -339,17 +341,17 @@
 
         Examples
         --------
         >>> from landlab.grid.unstructured.base import BaseGrid
         >>> links = [(0, 2), (1, 3), (0, 1), (2, 3), (0, 3)]
         >>> grid = BaseGrid(([0, 0, 4, 4], [0, 3, 0, 3]), links=links)
         >>> grid.length_of_link()
-        array([ 4.,  4.,  3.,  3.,  5.])
+        array([4.,  4.,  3.,  3.,  5.])
         >>> grid.length_of_link(0)
-        array([ 4.])
+        array([4.])
 
         >>> grid.length_of_link().min()
         3.0
         >>> grid.length_of_link().max()
         5.0
         """
         if link is None:
@@ -375,17 +377,17 @@
             Distances between nodes.
 
         Examples
         --------
         >>> from landlab.grid.unstructured.base import BaseGrid
         >>> grid = BaseGrid(([0, 0, 4, 4], [0, 3, 0, 3]))
         >>> grid.node_to_node_distance(0, 3)
-        array([ 5.])
+        array([5.])
         >>> grid.node_to_node_distance(0, [0, 1, 2, 3])
-        array([ 0.,  3.,  4.,  5.])
+        array([0.,  3.,  4.,  5.])
         """
         return point_to_point_distance(
             self._get_coord_at_node(node0), self._get_coord_at_node(node1), out=out
         )
 
         node0, node1 = np.broadcast_arrays(node0, node1)
         return np.sqrt(
@@ -411,22 +413,22 @@
             Distances from point to node.
 
         Examples
         --------
         >>> from landlab.grid.unstructured.base import BaseGrid
         >>> grid = BaseGrid(([0, 0, 4, 4], [0, 3, 0, 3]))
         >>> grid.point_to_node_distance((0.0, 0.0), [1, 2, 3])
-        array([ 3.,  4.,  5.])
+        array([3.,  4.,  5.])
         >>> grid.point_to_node_distance((0.0, 0.0))
-        array([ 0.,  3.,  4.,  5.])
+        array([0.,  3.,  4.,  5.])
         >>> out = np.empty(4)
         >>> out is grid.point_to_node_distance((0.0, 0.0), out=out)
         True
         >>> out
-        array([ 0.,  3.,  4.,  5.])
+        array([0.,  3.,  4.,  5.])
         """
         return point_to_point_distance(point, self._get_coord_at_node(node), out=out)
 
     def point_to_node_angle(self, point, node=None, out=None):
         """Angle from a point to a node.
 
         Parameters
@@ -442,22 +444,22 @@
             Angles from point to node as radians.
 
         Examples
         --------
         >>> from landlab.grid.unstructured.base import BaseGrid
         >>> grid = BaseGrid(([0, 0, 1, 1], [0, 1, 0, 1]))
         >>> grid.point_to_node_angle((0.0, 0.0), [1, 2, 3]) / np.pi
-        array([ 0.  ,  0.5 ,  0.25])
+        array([0.  ,  0.5 ,  0.25])
         >>> grid.point_to_node_angle((0.0, 0.0)) / np.pi
-        array([ 0.  ,  0.  ,  0.5 ,  0.25])
+        array([0.  ,  0.  ,  0.5 ,  0.25])
         >>> out = np.empty(4)
         >>> out is grid.point_to_node_angle((0.0, 0.0), out=out)
         True
         >>> out / np.pi
-        array([ 0.  ,  0.  ,  0.5 ,  0.25])
+        array([0.  ,  0.  ,  0.5 ,  0.25])
         """
         return point_to_point_angle(point, self._get_coord_at_node(node), out=out)
 
     def point_to_node_azimuth(self, point, node=None, out=None):
         """Azimuth from a point to a node.
 
         Parameters
@@ -473,24 +475,24 @@
             Azimuths from point to node.
 
         Examples
         --------
         >>> from landlab.grid.unstructured.base import BaseGrid
         >>> grid = BaseGrid(([0, 0, 1, 1], [0, 1, 0, 1]))
         >>> grid.point_to_node_azimuth((0.0, 0.0), [1, 2, 3])
-        array([ 90.,   0.,  45.])
+        array([90.,   0.,  45.])
         >>> grid.point_to_node_azimuth((0.0, 0.0))
-        array([ 90.,  90.,   0.,  45.])
+        array([90.,  90.,   0.,  45.])
         >>> grid.point_to_node_azimuth((0.0, 0.0), 1)
-        array([ 90.])
+        array([90.])
         >>> out = np.empty(4)
         >>> out is grid.point_to_node_azimuth((0.0, 0.0), out=out)
         True
         >>> out
-        array([ 90.,  90.,   0.,  45.])
+        array([90.,  90.,   0.,  45.])
         """
         return point_to_point_azimuth(point, self._get_coord_at_node(node), out=out)
 
     def point_to_node_vector(self, point, node=None, out=None):
         """Azimuth from a point to a node.
 
         Parameters
@@ -506,28 +508,28 @@
             Vector from point to node.
 
         Examples
         --------
         >>> from landlab.grid.unstructured.base import BaseGrid
         >>> grid = BaseGrid(([0, 0, 1, 1], [0, 1, 0, 1]))
         >>> grid.point_to_node_vector((0.0, 0.0), [1, 2, 3])
-        array([[ 0.,  1.,  1.],
-               [ 1.,  0.,  1.]])
+        array([[0.,  1.,  1.],
+               [1.,  0.,  1.]])
         >>> grid.point_to_node_vector((0.0, 0.0))
-        array([[ 0.,  0.,  1.,  1.],
-               [ 0.,  1.,  0.,  1.]])
+        array([[0.,  0.,  1.,  1.],
+               [0.,  1.,  0.,  1.]])
         >>> grid.point_to_node_vector((0.0, 0.0), 1)
-        array([[ 0.],
-               [ 1.]])
+        array([[0.],
+               [1.]])
         >>> out = np.empty((2, 1))
         >>> out is grid.point_to_node_vector((0.0, 0.0), 1, out=out)
         True
         >>> out
-        array([[ 0.],
-               [ 1.]])
+        array([[0.],
+               [1.]])
         """
         return point_to_point_vector(point, self._get_coord_at_node(node), out=out)
 
     def _get_coord_at_node(self, node=None):
         if node is None:
             return self.coord_at_node
         else:
@@ -551,17 +553,17 @@
         Length of vector joining points; if *out* is provided, *v* will be
         equal to *out*.
 
     Examples
     --------
     >>> from landlab.grid.unstructured.base import point_to_point_distance
     >>> point_to_point_distance((0, 0), (3, 4))
-    array([ 5.])
+    array([5.])
     >>> point_to_point_distance((0, 0), ([3, 6], [4, 8]))
-    array([  5.,  10.])
+    array([ 5.,  10.])
     """
     point0 = np.reshape(point0, (2, -1))
     point1 = np.reshape(point1, (2, -1))
     if out is None:
         sum_of_squares = np.sum((point1 - point0) ** 2.0, axis=0)
         return np.sqrt(sum_of_squares)
     else:
@@ -611,19 +613,19 @@
         Azimuth of vector joining points; if *out* is provided, *v* will be
         equal to *out*.
 
     Examples
     --------
     >>> from landlab.grid.unstructured.base import point_to_point_azimuth
     >>> point_to_point_azimuth((0, 0), (1, 0))
-    array([ 0.])
+    array([0.])
     >>> point_to_point_azimuth([(0, 1), (0, 1)], (1, 0))
-    array([  0., -90.])
+    array([ 0., -90.])
     >>> point_to_point_azimuth([(0, 1, 0), (0, 1, 2)], [(1, 1, 2), (0, 0, 4)])
-    array([  0., -90.,  45.])
+    array([ 0., -90.,  45.])
     """
     azimuth_in_rads = point_to_point_angle(point0, point1, out=out)
     if out is None:
         return (np.pi * 0.5 - azimuth_in_rads) * 180.0 / np.pi
     else:
         np.subtract(np.pi * 0.5, azimuth_in_rads, out=out)
         return np.multiply(out, 180.0 / np.pi, out=out)
```

### Comparing `landlab-2.7.0/landlab/grid/unstructured/cells.py` & `landlab-2.8.0/landlab/grid/unstructured/cells.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/grid/unstructured/links.py` & `landlab-2.8.0/landlab/grid/unstructured/links.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/grid/unstructured/nodes.py` & `landlab-2.8.0/landlab/grid/unstructured/nodes.py`

 * *Files 4% similar despite different names*

```diff
@@ -19,27 +19,27 @@
     >>> from landlab.grid.unstructured.nodes import NodeGrid
     >>> ngrid = NodeGrid(([0, 0, 1, 1], [0, 1, 0, 1]))
     >>> ngrid.ndim == 2
     True
     >>> ngrid.number_of_nodes == 4
     True
     >>> ngrid.x
-    array([ 0.,  1.,  0.,  1.])
+    array([0.,  1.,  0.,  1.])
     >>> ngrid.y
-    array([ 0.,  0.,  1.,  1.])
+    array([0.,  0.,  1.,  1.])
 
     Create a 1D grid.
 
     >>> ngrid = NodeGrid(((0, 1, 3),))
     >>> ngrid.ndim == 1
     True
     >>> ngrid.number_of_nodes
     3
     >>> ngrid.x
-    array([ 0.,  1.,  3.])
+    array([0.,  1.,  3.])
     >>> ngrid.y
     Traceback (most recent call last):
     AttributeError: Grid has no y-coordinate
     """
 
     def __init__(self, nodes):
         """__init__((coord0, coord1)) Create a grid of nodes.
@@ -59,27 +59,27 @@
         >>> from landlab.grid.unstructured.nodes import NodeGrid
         >>> ngrid = NodeGrid(([0, 0, 1, 1], [0, 1, 0, 1]))
         >>> ngrid.ndim == 2
         True
         >>> ngrid.number_of_nodes == 4
         True
         >>> ngrid.x
-        array([ 0.,  1.,  0.,  1.])
+        array([0.,  1.,  0.,  1.])
         >>> ngrid.y
-        array([ 0.,  0.,  1.,  1.])
+        array([0.,  0.,  1.,  1.])
 
         Create a 1D grid.
 
         >>> ngrid = NodeGrid(((0, 1, 3),))
         >>> ngrid.ndim == 1
         True
         >>> ngrid.number_of_nodes
         3
         >>> ngrid.x
-        array([ 0.,  1.,  3.])
+        array([0.,  1.,  3.])
         >>> ngrid.y
         Traceback (most recent call last):
         AttributeError: Grid has no y-coordinate
         """
         self._coords = np.vstack([np.array(coord, dtype=float) for coord in nodes])
         self._coords.flags["WRITEABLE"] = False
 
@@ -106,28 +106,28 @@
         """Node coordinates of the "fast" dimension.
 
         Examples
         --------
         >>> from landlab.grid.unstructured.nodes import NodeGrid
         >>> ngrid = NodeGrid(([0, 0, 1], [0, 1, 0]))
         >>> ngrid.x
-        array([ 0.,  1.,  0.])
+        array([0.,  1.,  0.])
         """
         return self._coords[-1]
 
     @property
     def y(self):
         """Node y-coordinates.
 
         Examples
         --------
         >>> from landlab.grid.unstructured.nodes import NodeGrid
         >>> ngrid = NodeGrid(([0, 0, 1], [0, 1, 0]))
         >>> ngrid.y
-        array([ 0.,  0.,  1.])
+        array([0.,  0.,  1.])
         """
         try:
             return self._coords[-2]
         except IndexError as exc:
             raise AttributeError("Grid has no y-coordinate") from exc
 
     @property
@@ -135,43 +135,43 @@
         """Node z-coordinates.
 
         Examples
         --------
         >>> from landlab.grid.unstructured.nodes import NodeGrid
         >>> ngrid = NodeGrid(([0, 0, 1], [0, 1, 0]))
         >>> ngrid.y
-        array([ 0.,  0.,  1.])
+        array([0.,  0.,  1.])
         """
         try:
             return self._coords[-2]
         except IndexError as exc:
             raise AttributeError("Grid has no z-coordinate") from exc
 
     @property
     def coord(self):
         """
         Examples
         --------
         >>> from landlab.grid.unstructured.nodes import NodeGrid
         >>> ngrid = NodeGrid(([0, 0, 1], [0, 1, 0]))
         >>> ngrid.coord[0]
-        array([ 0.,  0.,  1.])
+        array([0.,  0.,  1.])
         >>> ngrid.coord[1]
-        array([ 0.,  1.,  0.])
+        array([0.,  1.,  0.])
         """
         return self._coords
 
     @property
     def point(self):
         """
         Examples
         --------
         >>> from landlab.grid.unstructured.nodes import NodeGrid
         >>> ngrid = NodeGrid(([0, 0, 1], [0, 1, 0]))
         >>> ngrid.point
-        array([[ 0.,  0.],
-               [ 0.,  1.],
-               [ 1.,  0.]])
+        array([[0.,  0.],
+               [0.,  1.],
+               [1.,  0.]])
         >>> ngrid.point[1]
-        array([ 0.,  1.])
+        array([0.,  1.])
         """
         return self._coords.T
```

### Comparing `landlab-2.7.0/landlab/grid/unstructured/status.py` & `landlab-2.8.0/landlab/grid/unstructured/status.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/grid/voronoi.py` & `landlab-2.8.0/landlab/grid/voronoi.py`

 * *Files 1% similar despite different names*

```diff
@@ -45,24 +45,23 @@
     If the input coordinate arrays are 2D, calculate the area of each polygon.
     Note that when used in this mode, all polygons must have the same
     number of vertices, and polygon vertices are listed column-by-column.
 
     >>> x = np.array([[3.0, 1.0, 1.0, 3.0], [-2.0, -2.0, -1.0, -1.0]]).T
     >>> y = np.array([[1.5, 1.5, 0.5, 0.5], [0.0, 1.0, 2.0, 0.0]]).T
     >>> simple_poly_area(x, y)
-    array([ 2. ,  1.5])
+    array([2. ,  1.5])
     """
     # For short arrays (less than about 100 elements) it seems that the
     # Python sum is faster than the numpy sum. Likewise for the Python
     # built-in abs.
     return 0.5 * abs(sum(x[:-1] * y[1:] - x[1:] * y[:-1]) + x[-1] * y[0] - x[0] * y[-1])
 
 
 class VoronoiDelaunayGrid(DualVoronoiGraph, ModelGrid):
-
     """This inherited class implements an unstructured grid in which cells are
     Voronoi polygons and nodes are connected by a Delaunay triangulation. Uses
     scipy.spatial module to build the triangulation.
 
     Create an unstructured grid from points whose coordinates are given
     by the arrays *x*, *y*.
 
@@ -95,23 +94,23 @@
     ...         [0.0, 1.0, 2.0, 3.0],
     ...         [0.0, 1.0, 2.0, 3.0],
     ...     ]
     ... ).flatten()
 
     >>> vmg = VoronoiDelaunayGrid(x, y)
     >>> vmg.node_x
-    array([ 0. ,  1. ,  2. ,
-            0.1,  1.1,  2.1,
-            0.2,  1.2,  2.2,
-            0.3,  1.3,  2.3])
+    array([0. ,  1. ,  2. ,
+           0.1,  1.1,  2.1,
+           0.2,  1.2,  2.2,
+           0.3,  1.3,  2.3])
     >>> vmg.node_y
-    array([ 0.,  0.,  0.,
-            1.,  1.,  1.,
-            2.,  2.,  2.,
-            3.,  3.,  3.])
+    array([0.,  0.,  0.,
+           1.,  1.,  1.,
+           2.,  2.,  2.,
+           3.,  3.,  3.])
     >>> vmg.adjacent_nodes_at_node
     array([[ 1,  3, -1, -1, -1, -1],
            [ 2,  4,  3,  0, -1, -1],
            [ 5,  4,  1, -1, -1, -1],
            [ 4,  6,  0,  1, -1, -1],
            [ 5,  7,  6,  3,  1,  2],
            [ 8,  7,  4,  2, -1, -1],
```

### Comparing `landlab-2.7.0/landlab/grid/warnings.py` & `landlab-2.8.0/landlab/grid/warnings.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/io/esri_ascii.py` & `landlab-2.8.0/landlab/io/esri_ascii.py`

 * *Files 1% similar despite different names*

```diff
@@ -40,112 +40,103 @@
     "yllcorner": (float, lambda x: True),
     "yllcenter": (float, lambda x: True),
     "nodata_value": (float, lambda x: True),
 }
 
 
 class Error(Exception):
-
     """Base class for errors in this module."""
 
     pass
 
 
 class BadHeaderLineError(Error):
-
     """Raise this error for a bad header is line."""
 
     def __init__(self, line):
         self._line = line
 
     def __str__(self):
         return self._line  # this line not yet tested
 
 
 class MissingRequiredKeyError(Error):
-
     """Raise this error when a header is missing a required key."""
 
     def __init__(self, key):
         self._key = key
 
     def __str__(self):
         return self._key
 
 
 class KeyTypeError(Error):
-
     """Raise this error when a header's key value is of the wrong type."""
 
     def __init__(self, key, expected_type):
         self._key = key
         self._type = str(expected_type)
 
     def __str__(self):
         return f"Unable to convert {self._key} to {self._type}"
 
 
 class KeyValueError(Error):
-
     """Raise this error when a header's key value has a bad value."""
 
     def __init__(self, key, message):
         self._key = key
         self._msg = message
 
     def __str__(self):
         return f"{self._key}: {self._msg}"  # this line not yet tested
 
 
 class DataSizeError(Error):
-
     """Raise this error if the size of data does not match the header."""
 
     def __init__(self, size, expected_size):
         self._actual = size
         self._expected = expected_size
 
     def __str__(self):
         return "{} != {}".format(
             self._actual, self._expected
         )  # this line not yet tested
 
 
 class MismatchGridDataSizeError(Error):
-
     """Raise this error if the data size does not match the grid size."""
 
     def __init__(self, size, expected_size):
         self._actual = size
         self._expected = expected_size
 
     def __str__(self):
         return "(data size) {} != {} (grid size)".format(
             self._actual,
             self._expected,
         )  # this line not yet tested
 
 
 class MismatchGridXYSpacing(Error):
-
     """Raise this error if the file cell size does not match the grid dx."""
 
     def __init__(self, dx, expected_dx):
         self._actual = dx
         self._expected = expected_dx
 
     def __str__(self):
         return "(data dx) {} != {} (grid dx)".format(
             self._actual,
             self._expected,
         )  # this line not yet tested
 
 
 class MismatchGridXYLowerLeft(Error):
-
     """Raise this error if the file lower left does not match the grid."""
 
     def __init__(self, llc, expected_llc):
         self._actual = llc
         self._expected = expected_llc
 
     def __str__(self):
@@ -446,20 +437,20 @@
     >>> (grid, data) = read_esri_ascii(StringIO(contents), halo=1)
 
     Because of the halo, the returned grid now has two more rows and columns than before.
 
     >>> grid
     RasterModelGrid((6, 5), xy_spacing=(10.0, 10.0), xy_of_lower_left=(-9.0, -8.0))
     >>> data.reshape(grid.shape)
-    array([[ -1.,  -1.,  -1.,  -1.,  -1.],
-           [ -1.,   9.,  10.,  11.,  -1.],
-           [ -1.,   6.,   7.,   8.,  -1.],
-           [ -1.,   3.,   4.,   5.,  -1.],
-           [ -1.,   0.,   1.,   2.,  -1.],
-           [ -1.,  -1.,  -1.,  -1.,  -1.]])
+    array([[-1.,  -1.,  -1.,  -1.,  -1.],
+           [-1.,   9.,  10.,  11.,  -1.],
+           [-1.,   6.,   7.,   8.,  -1.],
+           [-1.,   3.,   4.,   5.,  -1.],
+           [-1.,   0.,   1.,   2.,  -1.],
+           [-1.,  -1.,  -1.,  -1.,  -1.]])
     """  # noqa: B950
     from ..grid import RasterModelGrid
 
     if halo < 0:
         raise ValueError("negative halo")
 
     # if the asc_file is provided as a string, open it and pass the pointer to
```

### Comparing `landlab-2.7.0/landlab/io/native_landlab.py` & `landlab-2.8.0/landlab/io/native_landlab.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/io/netcdf/_constants.py` & `landlab-2.8.0/landlab/io/netcdf/_constants.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/io/netcdf/dump.py` & `landlab-2.8.0/landlab/io/netcdf/dump.py`

 * *Files 2% similar despite different names*

```diff
@@ -99,21 +99,21 @@
         this_dataset["status_at_node"] = (
             ("node",),
             this_dataset["status_at_node"].values.astype(dtype=int),
         )
 
     if mode == "a":
         with xr.open_dataset(path) as that_dataset:
-            if "time" not in that_dataset.dims:
+            if "time" not in that_dataset.sizes:
                 _add_time_dimension_to_dataset(that_dataset, time=np.nan)
 
             new_vars = set(this_dataset.variables) - set(that_dataset.variables)
             for var in new_vars:
                 that_dataset[var] = (
-                    this_dataset[var].dims,
+                    this_dataset[var].sizes,
                     np.full_like(this_dataset[var].values, np.nan),
                 )
 
             for var in list(that_dataset.variables):
                 if var.startswith("at_layer"):
                     del that_dataset[var]
 
@@ -132,9 +132,12 @@
     names = {
         name
         for name in dataset.variables
         if name.startswith("at_") and not name.startswith("at_layer")
     }
 
     for name in names:
-        dataset[name] = (("time",) + dataset[name].dims, dataset[name].values[None])
+        dataset[name] = (
+            ("time",) + tuple(dataset[name].sizes),
+            dataset[name].values[None],
+        )
     dataset["time"] = (("time",), [time])
```

### Comparing `landlab-2.7.0/landlab/io/netcdf/load.py` & `landlab-2.8.0/landlab/io/netcdf/load.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/io/netcdf/read.py` & `landlab-2.8.0/landlab/io/netcdf/read.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,24 +9,20 @@
     ~landlab.io.netcdf.read.read_netcdf
 """
 import contextlib
 
 import numpy as np
 import xarray as xr
 
-from landlab.io import (
-    MismatchGridDataSizeError,
-    MismatchGridXYLowerLeft,
-    MismatchGridXYSpacing,
-)
-from landlab.io.netcdf._constants import (
-    _AXIS_COORDINATE_NAMES,
-    _AXIS_DIMENSION_NAMES,
-    _COORDINATE_NAMES,
-)
+from landlab.io import MismatchGridDataSizeError
+from landlab.io import MismatchGridXYLowerLeft
+from landlab.io import MismatchGridXYSpacing
+from landlab.io.netcdf._constants import _AXIS_COORDINATE_NAMES
+from landlab.io.netcdf._constants import _AXIS_DIMENSION_NAMES
+from landlab.io.netcdf._constants import _COORDINATE_NAMES
 from landlab.io.netcdf.errors import NotRasterGridError
 from landlab.utils import add_halo
 
 
 def _length_of_axis_dimension(root, axis_name):
     """Get the size of an axis by axis name.
```

### Comparing `landlab-2.7.0/landlab/io/netcdf/write.py` & `landlab-2.8.0/landlab/io/netcdf/write.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,19 +9,17 @@
     ~landlab.io.netcdf.write.write_netcdf
 """
 import pathlib
 
 import numpy as np
 import xarray as xr
 
-from landlab.io.netcdf._constants import (
-    _AXIS_COORDINATE_NAMES,
-    _AXIS_DIMENSION_NAMES,
-    _NP_TO_NC_TYPE,
-)
+from landlab.io.netcdf._constants import _AXIS_COORDINATE_NAMES
+from landlab.io.netcdf._constants import _AXIS_DIMENSION_NAMES
+from landlab.io.netcdf._constants import _NP_TO_NC_TYPE
 
 
 def _set_netcdf_attributes(root, attrs):
     """Set attributes of a netcdf file.
 
     Set attributes of the netCDF Database object, *root*. Attributes are
     given as key/value pairs from *attrs*.
@@ -145,19 +143,19 @@
         arrays will be *(rows, cols, 4)*.
 
     Examples
     --------
     >>> from landlab.io.netcdf.write import _get_cell_bounds
     >>> bounds = _get_cell_bounds((3, 4))
     >>> bounds["y_bnds"]
-    array([[[ 0.,  1.,  1.,  0.], [ 0.,  1.,  1.,  0.], [ 0.,  1.,  1.,  0.]],
-           [[ 1.,  2.,  2.,  1.], [ 1.,  2.,  2.,  1.], [ 1.,  2.,  2.,  1.]]])
+    array([[[0.,  1.,  1.,  0.], [0.,  1.,  1.,  0.], [0.,  1.,  1.,  0.]],
+           [[1.,  2.,  2.,  1.], [1.,  2.,  2.,  1.], [1.,  2.,  2.,  1.]]])
     >>> bounds["x_bnds"]
-    array([[[ 1.,  1.,  0.,  0.], [ 2.,  2.,  1.,  1.], [ 3.,  3.,  2.,  2.]],
-           [[ 1.,  1.,  0.,  0.], [ 2.,  2.,  1.,  1.], [ 3.,  3.,  2.,  2.]]])
+    array([[[1.,  1.,  0.,  0.], [2.,  2.,  1.,  1.], [3.,  3.,  2.,  2.]],
+           [[1.,  1.,  0.,  0.], [2.,  2.,  1.,  1.], [3.,  3.,  2.,  2.]]])
     """
     rows = np.arange(shape[0]) * spacing[0] + origin[0]
     cols = np.arange(shape[1]) * spacing[1] + origin[1]
 
     corner_y, corner_x = np.meshgrid(rows, cols, indexing="ij")
 
     y_bnds = np.vstack(
@@ -665,15 +663,15 @@
     if at == "cell":
         shape = shape[0] - 2, shape[1] - 2
 
     data = {}
     if append:
         with xr.open_dataset(path) as dataset:
             time_varying_names = [
-                name for name in dataset.variables if "nt" in dataset[name].dims
+                name for name in dataset.variables if "nt" in dataset[name].sizes
             ]
             for name in set(time_varying_names) & set(names):
                 values = getattr(grid, "at_" + at)[name].reshape((1,) + shape)
                 data[name] = (dims, np.concatenate([dataset[name].values, values]))
 
             if "t" not in dataset.variables:
                 times = np.arange(len(dataset["nt"]) + 1)
@@ -805,31 +803,31 @@
     True
     >>> "topographic__elevation" in fp.variables
     False
     >>> fp.variables["uplift_rate"][:].flatten().astype("=f8")
     array([  0.,   2.,   4.,   6.,   8.,  10.,  12.,  14.,  16.,  18.,  20.,
             22.])
     >>> fp.variables["x"][:].astype("=f8")
-    array([ 0.,  1.,  2.])
+    array([0.,  1.,  2.])
     >>> fp.variables["y"][:].astype("=f8")
-    array([ 0.,  1.,  2.,  3.])
+    array([0.,  1.,  2.,  3.])
 
     Read now with read_netcdf
 
     >>> from landlab.io.netcdf import read_netcdf
     >>> grid = read_netcdf("test.nc")
     >>> grid.shape
     (4, 3)
     >>> grid.x_of_node
-    array([ 0.,  1.,  2.,  0.,  1.,  2.,  0.,  1.,  2.,  0.,  1.,  2.])
+    array([0.,  1.,  2.,  0.,  1.,  2.,  0.,  1.,  2.,  0.,  1.,  2.])
     >>> grid.y_of_node
-    array([ 0.,  0.,  0.,  1.,  1.,  1.,  2.,  2.,  2.,  3.,  3.,  3.])
+    array([0.,  0.,  0.,  1.,  1.,  1.,  2.,  2.,  2.,  3.,  3.,  3.])
     >>> grid.at_node["uplift_rate"]
-    array([  0.,   2.,   4.,   6.,   8.,  10.,  12.,  14.,  16.,  18.,  20.,
-            22.])
+    array([ 0.,   2.,   4.,   6.,   8.,  10.,  12.,  14.,  16.,  18.,  20.,
+           22.])
     """
     return write_netcdf(
         path,
         fields,
         attrs=attrs,
         append=append,
         format=format,
```

### Comparing `landlab-2.7.0/landlab/io/obj.py` & `landlab-2.8.0/landlab/io/obj.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/io/shapefile/read_shapefile.py` & `landlab-2.8.0/landlab/io/shapefile.py`

 * *Files 1% similar despite different names*

```diff
@@ -58,21 +58,21 @@
     Examples
     --------
     >>> import numpy as np
 
     >>> _infer_data_type([1, 2, 3])
     array([1, 2, 3])
     >>> _infer_data_type([1, 2, 3], dtype=float)
-    array([ 1.,  2.,  3.])
+    array([1.,  2.,  3.])
     >>> _infer_data_type(np.array([1.0, 2.0, 3.0], dtype=object))
-    array([ 1.,  2.,  3.])
+    array([1.,  2.,  3.])
     >>> _infer_data_type([[1, 2, 3]])
     array([[1, 2, 3]])
     >>> _infer_data_type([None, 1, 2, 3])
-    array([ nan,   1.,   2.,   3.])
+    array([nan,   1.,   2.,   3.])
     """
     array = np.asarray(array, dtype=dtype)
     if dtype is None and not np.issubdtype(array.dtype, np.number):
         infered_dtype = pd.api.types.infer_dtype(array, skipna=True)
         for dtype in _NUMPY_DTYPE.get(infered_dtype, ()):
             try:
                 _array = np.asarray(array.flatten(), dtype=dtype)
@@ -97,18 +97,19 @@
     link_field_dtype=None,
     node_field_dtype=None,
     threshold=0.0,
 ):
     """Read shapefile and create a NetworkModelGrid.
 
     There are a number of assumptions that are required about the shapefile.
-        * The shapefile must be a polyline shapefile.
-        * All polylines must be their own object (e.g. no multi-part
-          polylines).
-        * Polyline endpoints match perfectly.
+
+    * The shapefile must be a polyline shapefile.
+    * All polylines must be their own object (e.g. no multi-part
+      polylines).
+    * Polyline endpoints match perfectly.
 
     You might notice that there is no ``write_shapefile`` function. If this is
     something you need for your work, please make a GitHub issue to start this
     process.
 
     Parameters
     ----------
@@ -175,15 +176,15 @@
     >>> w.record(100)
     >>> w.line([[[5, 5], [0, 10]]])
     >>> w.record(239)
     >>> w.close()
 
     Now create a NetworkModelGrid with read_shapefile:
 
-    >>> from landlab.io import read_shapefile
+    >>> from landlab.io.shapefile import read_shapefile
     >>> grid = read_shapefile(shp, dbf=dbf)
     >>> grid.nodes
     array([0, 1, 2, 3])
     >>> grid.x_of_node
     array([  5.,   5.,   0.,  10.])
     >>> grid.y_of_node
     array([  0.,   5.,  10.,  10.])
```

### Comparing `landlab-2.7.0/landlab/layers/eventlayers.py` & `landlab-2.8.0/landlab/layers/eventlayers.py`

 * *Files 1% similar despite different names*

```diff
@@ -48,50 +48,50 @@
 
     Next we add a layer with spatially variable thickness. We specify that the
     number of active layers (including the one being added) is 1.
 
     >>> dz = np.array([1.0, 2.0, 3.0])
     >>> _deposit_or_erode(allocated_layers_array, 1, dz)
     >>> allocated_layers_array
-    array([[ 1.,  2.,  3.],
-           [ 0.,  0.,  0.],
-           [ 0.,  0.,  0.],
-           [ 0.,  0.,  0.]])
+    array([[1.,  2.,  3.],
+           [0.,  0.,  0.],
+           [0.,  0.,  0.],
+           [0.,  0.,  0.]])
 
     As you can see, this changes the value of the first row in the array. The
     remainder of the array represents space in the datatastructure that has
     been allocated to contain layers, but does not yet contain active layers.
 
     Next we add a layer of thickness 1. To do this, we now need to specify that
     the number of active layers is 2.
 
     >>> dz = np.array([1.0, 1.0, 1.0])
     >>> _deposit_or_erode(allocated_layers_array, 2, dz)
     >>> allocated_layers_array
-    array([[ 1.,  2.,  3.],
-           [ 1.,  1.,  1.],
-           [ 0.,  0.,  0.],
-           [ 0.,  0.,  0.]])
+    array([[1.,  2.,  3.],
+           [1.,  1.,  1.],
+           [0.,  0.,  0.],
+           [0.,  0.,  0.]])
 
     Finally, we do some erosion. We specify that the number of active layers is
     3 and give a spatially variable field of erosion and deposition.
 
     >>> _deposit_or_erode(allocated_layers_array, 3, [1.0, -1.0, -2.0])
     >>> allocated_layers_array
-    array([[ 1.,  2.,  2.],
-           [ 1.,  0.,  0.],
-           [ 1.,  0.,  0.],
-           [ 0.,  0.,  0.]])
+    array([[1.,  2.,  2.],
+           [1.,  0.,  0.],
+           [1.,  0.,  0.],
+           [0.,  0.,  0.]])
 
     >>> _deposit_or_erode(allocated_layers_array, 3, [1.0, -1.0, -2.0])
     >>> allocated_layers_array
-    array([[ 1.,  1.,  0.],
-           [ 1.,  0.,  0.],
-           [ 2.,  0.,  0.],
-           [ 0.,  0.,  0.]])
+    array([[1.,  1.,  0.],
+           [1.,  0.,  0.],
+           [2.,  0.,  0.],
+           [0.,  0.,  0.]])
     """
     from .ext.eventlayers import deposit_or_erode
 
     layers = layers.reshape((layers.shape[0], -1))
     try:
         dz = dz.reshape((layers.shape[1],))
     except (AttributeError, ValueError):
@@ -123,19 +123,19 @@
     >>> dz = np.array([-1.0, -2.0, -3.0])
 
     Note here, if you are very confused by the use of ``_deposit_or_erode``
     we recommend you read the docstring associated with that function.
 
     >>> _deposit_or_erode(layers, 5, dz)
     >>> layers
-    array([[ 1.,  1.,  1.],
-           [ 1.,  1.,  1.],
-           [ 1.,  1.,  0.],
-           [ 1.,  0.,  0.],
-           [ 0.,  0.,  0.]])
+    array([[1.,  1.,  1.],
+           [1.,  1.,  1.],
+           [1.,  1.,  0.],
+           [1.,  0.,  0.],
+           [0.,  0.,  0.]])
 
     >>> surface_index = np.empty(3, dtype=int)
     >>> _get_surface_index(layers, 5, surface_index)
     >>> surface_index
     array([3, 2, 1])
     """
     from .ext.eventlayers import get_surface_index
@@ -432,15 +432,14 @@
 
     return np.empty(
         (number_of_layers, number_of_stacks) + values_per_stack, dtype=array.dtype
     )
 
 
 class EventLayersMixIn:
-
     """MixIn that adds a EventLayers attribute to a ModelGrid."""
 
     @property
     def event_layers(self):
         """EventLayers for each cell."""
         try:
             self._event_layers
@@ -451,15 +450,14 @@
     @property
     def at_layer(self):
         """EventLayers for each cell."""
         return self.event_layers
 
 
 class EventLayers:
-
     """Track EventLayers where each event is its own layer.
 
     EventLayers are meant to represent a layered object in which each layer
     represents a event. Thus they are likely the most appropriate tool to use
     if the user is interested in chronostratigraphy. If erosion occurs, a new
     layer with zero thickness is created. Thus, EventLayers may not be the most
     memory efficent layers datastructure.
@@ -488,36 +486,36 @@
 
     Add a layer with a uniform thickness.
 
     >>> layers.add(1.5)
     >>> layers.number_of_layers
     1
     >>> layers.dz
-    array([[ 1.5,  1.5,  1.5,  1.5,  1.5]])
+    array([[1.5,  1.5,  1.5,  1.5,  1.5]])
 
     Add a second layer with uneven thickness.
 
     >>> layers.add([1.0, 2.0, 0.5, 5.0, 0.0])
     >>> layers.dz
-    array([[ 1.5,  1.5,  1.5,  1.5,  1.5],
-           [ 1. ,  2. ,  0.5,  5. ,  0. ]])
+    array([[1.5,  1.5,  1.5,  1.5,  1.5],
+           [1. ,  2. ,  0.5,  5. ,  0. ]])
 
     Adding a layer with negative thickness will remove
     existing layers for the top of the stack. Note that
     this will create a new layer with thickness zero
     that represents this 'event'. If instead your
     application would prefer that no new row is added to
     the layers datastructure, you may want to consider
     the MaterialLayers object.
 
     >>> layers.add(-1)
     >>> layers.dz
-    array([[ 1.5,  1.5,  1. ,  1.5,  0.5],
-           [ 0. ,  1. ,  0. ,  4. ,  0. ],
-           [ 0. ,  0. ,  0. ,  0. ,  0. ]])
+    array([[1.5,  1.5,  1. ,  1.5,  0.5],
+           [0. ,  1. ,  0. ,  4. ,  0. ],
+           [0. ,  0. ,  0. ,  0. ,  0. ]])
 
     Get the index value of the layer within each stack
     at the topographic surface.
 
     >>> layers.surface_index
     array([0, 1, 0, 1, 0])
     """
@@ -601,22 +599,22 @@
         --------
         >>> from landlab.layers.eventlayers import EventLayers
 
         Initially there are no layers so the total thickness is 0.
 
         >>> layers = EventLayers(3)
         >>> layers.thickness
-        array([ 0.,  0.,  0.])
+        array([0.,  0.,  0.])
 
         After adding some layers, the stacks have varying thicknesses.
 
         >>> layers.add(15.0)
         >>> layers.add([1.0, -1.0, 2.0])
         >>> layers.thickness
-        array([ 16.,  14.,  17.])
+        array([16.,  14.,  17.])
         """
         return np.sum(self.dz, axis=0)
 
     @property
     def z(self):
         """Thickness to top of each layer.
 
@@ -635,19 +633,19 @@
         True
 
         After adding some layers, elevations are to the top of each layer.
 
         >>> layers.add(15.0)
         >>> layers.add([1.0, -1.0, 2.0])
         >>> layers.dz
-        array([[ 15.,  14.,  15.],
-               [  1.,   0.,   2.]])
+        array([[15.,  14.,  15.],
+               [ 1.,   0.,   2.]])
         >>> layers.z
-        array([[ 15.,  14.,  15.],
-               [ 16.,  14.,  17.]])
+        array([[15.,  14.,  15.],
+               [16.,  14.,  17.]])
         """
         return np.cumsum(self.dz, axis=0)
 
     @property
     def dz(self):
         """Thickness of each layer.
 
@@ -666,16 +664,16 @@
 
         Now add two layers, the first of uniform thickness and the
         second non-uniform and with some erosion.
 
         >>> layers.add(15.0)
         >>> layers.add([1.0, -1.0, 2.0])
         >>> layers.dz
-        array([[ 15.,  14.,  15.],
-               [  1.,   0.,   2.]])
+        array([[15.,  14.,  15.],
+               [ 1.,   0.,   2.]])
         """
         return self._attrs["_dz"][: self.number_of_layers]
 
     @property
     def number_of_layers(self):
         """Total number of layers.
 
@@ -766,65 +764,65 @@
 
         To add a layer of uniform thickness to every stack.
 
         >>> layers.add(1.5)
         >>> layers.number_of_layers
         1
         >>> layers.dz
-        array([[ 1.5,  1.5,  1.5]])
+        array([[1.5,  1.5,  1.5]])
 
         Add a second layer with uneven thickness.
 
         >>> layers.add([1.0, 2.0, 0.5])
         >>> layers.dz
-        array([[ 1.5,  1.5,  1.5],
-               [ 1. ,  2. ,  0.5]])
+        array([[1.5,  1.5,  1.5],
+               [1. ,  2. ,  0.5]])
 
         Adding a layer with negative thickness will remove
         existing layers for the top of the stack.
 
         >>> layers.add(-1)
         >>> layers.dz
-        array([[ 1.5,  1.5,  1. ],
-               [ 0. ,  1. ,  0. ],
-               [ 0. ,  0. ,  0. ]])
+        array([[1.5,  1.5,  1. ],
+               [0. ,  1. ,  0. ],
+               [0. ,  0. ,  0. ]])
 
         Use keywords to track properties of each layer. For instance,
         here we create a new stack and add a layer with a particular
         *age*. You can access the layer properties as if the object
         were a dictionary.
 
         >>> layers = EventLayers(3)
         >>> layers.add(1.0, age=3.0)
         >>> layers.dz
-        array([[ 1.,  1.,  1.]])
+        array([[1.,  1.,  1.]])
         >>> layers["age"]
-        array([[ 3.,  3.,  3.]])
+        array([[3.,  3.,  3.]])
         >>> layers.add(2.0, age=6.0)
         >>> layers["age"]
-        array([[ 3.,  3.,  3.],
-               [ 6.,  6.,  6.]])
+        array([[3.,  3.,  3.],
+               [6.,  6.,  6.]])
 
         Attributes for each layer will exist even if the the layer is
         associated with erosion.
 
         >>> layers.add([-2, -1, 1], age=8.0)
         >>> layers.dz
-        array([[ 1.,  1.,  1.],
-               [ 0.,  1.,  2.],
-               [ 0.,  0.,  1.]])
+        array([[1.,  1.,  1.],
+               [0.,  1.,  2.],
+               [0.,  0.,  1.]])
         >>> layers["age"]
-        array([[ 3.,  3.,  3.],
-               [ 6.,  6.,  6.],
-               [ 8.,  8.,  8.]])
+        array([[3.,  3.,  3.],
+               [6.,  6.,  6.],
+               [8.,  8.,  8.]])
 
         To get the values at the surface of the layer stack:
 
         >>> layers.get_surface_values("age")
-        array([ 3.,  6.,  8.])
+        array([3.,  6.,  8.])
         """
         if self.number_of_layers == 0:
             self._setup_layers(**kwds)
 
         self._add_empty_layer()
 
         _deposit_or_erode(self._attrs["_dz"], self.number_of_layers, dz)
@@ -858,93 +856,93 @@
 
         To add a layer of uniform thickness to every stack.
 
         >>> layers.add(1.5)
         >>> layers.number_of_layers
         1
         >>> layers.dz
-        array([[ 1.5,  1.5,  1.5]])
+        array([[1.5,  1.5,  1.5]])
 
         Add a second layer with uneven thickness.
 
         >>> layers.add([1.0, 2.0, 0.5])
         >>> layers.dz
-        array([[ 1.5,  1.5,  1.5],
-               [ 1. ,  2. ,  0.5]])
+        array([[1.5,  1.5,  1.5],
+               [1. ,  2. ,  0.5]])
 
         Combine all of the layers into a single layer.
 
         >>> layers.reduce()
         >>> layers.dz
-        array([[ 2.5,  3.5,  2. ]])
+        array([[2.5,  3.5,  2. ]])
 
         Add two additional layers to the top. The bottom-most layer is row
         0, and the two new layers are rows 1 and 2.
 
         >>> layers.add([1.0, 2.0, 0.5])
         >>> layers.add([1.0, 2.0, 0.5])
         >>> layers.dz
-        array([[ 2.5,  3.5,  2. ],
-               [ 1. ,  2. ,  0.5],
-               [ 1. ,  2. ,  0.5]])
+        array([[2.5,  3.5,  2. ],
+               [1. ,  2. ,  0.5],
+               [1. ,  2. ,  0.5]])
 
         Combine the two new layers (layers 1 and 2) into a single layer.
 
         >>> layers.reduce(1, 3)
         >>> layers.dz
-        array([[ 2.5,  3.5,  2. ],
-               [ 2. ,  4. ,  1. ]])
+        array([[2.5,  3.5,  2. ],
+               [2. ,  4. ,  1. ]])
 
         >>> layers.add([1.0, 2.0, 0.5])
         >>> layers.add([1.0, 2.0, 0.5])
         >>> layers.dz
-        array([[ 2.5,  3.5,  2. ],
-               [ 2. ,  4. ,  1. ],
-               [ 1. ,  2. ,  0.5],
-               [ 1. ,  2. ,  0.5]])
+        array([[2.5,  3.5,  2. ],
+               [2. ,  4. ,  1. ],
+               [1. ,  2. ,  0.5],
+               [1. ,  2. ,  0.5]])
 
         Combine the middle two layers.
 
         >>> layers.reduce(1, 3)
         >>> layers.dz
-        array([[ 2.5,  3.5,  2. ],
-               [ 3. ,  6. ,  1.5],
-               [ 1. ,  2. ,  0.5]])
+        array([[2.5,  3.5,  2. ],
+               [3. ,  6. ,  1.5],
+               [1. ,  2. ,  0.5]])
         >>> layers.add([1.0, 1.0, 1.0])
         >>> layers.dz
-        array([[ 2.5,  3.5,  2. ],
-               [ 3. ,  6. ,  1.5],
-               [ 1. ,  2. ,  0.5],
-               [ 1. ,  1. ,  1. ]])
+        array([[2.5,  3.5,  2. ],
+               [3. ,  6. ,  1.5],
+               [1. ,  2. ,  0.5],
+               [1. ,  1. ,  1. ]])
 
         Combine every two layers (layers 0 and 1 and combined, and layers
         1 and 2 are combined).
 
         >>> layers.reduce(0, 4, 2)
         >>> layers.dz
-        array([[ 5.5,  9.5,  3.5],
-               [ 2. ,  3. ,  1.5]])
+        array([[5.5,  9.5,  3.5],
+               [2. ,  3. ,  1.5]])
 
         When layers are combined, thicknesses are summed but layer attributes
         can be combined in other ways (e.g. max, or mean)
 
         >>> layers = EventLayers(3)
         >>> layers.add([1, 1, 1], age=0.0)
         >>> layers.add([1, 2, 5], age=1.0)
         >>> layers.add([2, 2, 2], age=2.0)
         >>> layers.reduce(age=np.max)
         >>> layers["age"]
-        array([[ 2.,  2.,  2.]])
+        array([[2.,  2.,  2.]])
 
         >>> layers.add([2, 2, 2], age=3.0)
         >>> layers.add([2, 2, 2], age=4.0)
         >>> layers.reduce(1, 3, age=np.mean)
         >>> layers["age"]
-        array([[ 2. ,  2. ,  2. ],
-               [ 3.5,  3.5,  3.5]])
+        array([[2. ,  2. ,  2. ],
+               [3.5,  3.5,  3.5]])
         """
         _valid_keywords_or_raise(kwds, required=self.tracking, optional=self._attrs)
 
         start, stop, step = _BlockSlice(*args).indices(self._number_of_layers)
 
         if step <= 1:
             return
```

### Comparing `landlab-2.7.0/landlab/layers/ext/eventlayers.pyx` & `landlab-2.8.0/landlab/layers/ext/eventlayers.pyx`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/layers/materiallayers.py` & `landlab-2.8.0/landlab/layers/materiallayers.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,32 +1,28 @@
 import numpy as np
 
-from landlab.layers.eventlayers import (
-    EventLayers,
-    _deposit_or_erode,
-    _get_surface_index,
-)
+from landlab.layers.eventlayers import EventLayers
+from landlab.layers.eventlayers import _deposit_or_erode
+from landlab.layers.eventlayers import _get_surface_index
 
 
 class MaterialLayersMixIn:
-
     """MixIn that adds a MaterialLayers attribute to a ModelGrid."""
 
     @property
     def material_layers(self):
         """MaterialLayers for each cell."""
         try:
             self._material_layers
         except AttributeError:
             self._material_layers = MaterialLayers(self.number_of_cells)
         return self._material_layers
 
 
 class MaterialLayers(EventLayers):
-
     """Track MaterialLayers where each layer has some material in it.
 
     MaterialLayers are meant to represent a layered object in which each layer
     has some material in it. If erosion occurs, no new layer is created. These
     layers stand in contrast to the EventLayers for which each event is
     represented by a layer.
 
@@ -52,33 +48,33 @@
 
     Add a layer with a uniform thickness.
 
     >>> layers.add(1.5)
     >>> layers.number_of_layers
     1
     >>> layers.dz
-    array([[ 1.5,  1.5,  1.5,  1.5,  1.5]])
+    array([[1.5,  1.5,  1.5,  1.5,  1.5]])
 
     MaterialLayers will combine layers if they have the same attributes.
     Adding a second layer with uneven thickness. Will increment the
     first layers thickness. This stands in contrast with EventLayers
     which will track each addition as a separate entry in the layers
     datastructure.
 
     >>> layers.add([1.0, 2.0, 3.0, 5.0, 0.0])
     >>> layers.dz
-    array([[ 2.5,  3.5,  4.5,  6.5,  1.5]])
+    array([[2.5,  3.5,  4.5,  6.5,  1.5]])
 
     Adding a layer with negative thickness will remove
     material from the layers. Unlike EventLayers, it will not add a
     layer of zeros that represent an event with no deposition.
 
     >>> layers.add(-1)
     >>> layers.dz
-    array([[ 1.5,  2.5,  3.5,  5.5,  0.5]])
+    array([[1.5,  2.5,  3.5,  5.5,  0.5]])
 
     Get the index value of the layer within each stack
     at the topographic surface.
 
     >>> layers.surface_index
     array([0, 0, 0, 0, 0])
 
@@ -106,148 +102,148 @@
 
         To add a layer of uniform thickness to every stack.
 
         >>> layers.add(1.5)
         >>> layers.number_of_layers
         1
         >>> layers.dz
-        array([[ 1.5,  1.5,  1.5]])
+        array([[1.5,  1.5,  1.5]])
 
         Add a second layer with uneven thickness.
 
         >>> layers.add([1.0, 2.0, 0.5])
         >>> layers.dz
-        array([[ 2.5,  3.5,  2. ]])
+        array([[2.5,  3.5,  2. ]])
 
         Because the attributes of this layer and the previous layer
         are the same (e.g. they don't exist), MaterialLayer will combine
         them. This is the primary difference between MaterialLayers and
         EventLayers.
 
         Adding a layer with negative thickness will remove material from
         the top of the stack.
 
         >>> layers.add(-1)
         >>> layers.dz
-        array([[ 1.5,  2.5,  1. ]])
+        array([[1.5,  2.5,  1. ]])
         >>> layers.number_of_layers
         1
 
         Use keywords to track properties of each layer. For instance,
         here we create a new stack and add a layer with a particular
         *type* and a particular *size*. You can access the layer properties as
         if the object were a dictionary.
 
         >>> layers = MaterialLayers(3)
         >>> layers.add(1.0, type=3.0, size="sand")
         >>> layers.dz
-        array([[ 1.,  1.,  1.]])
+        array([[1.,  1.,  1.]])
         >>> layers["type"]
-        array([[ 3.,  3.,  3.]])
+        array([[3.,  3.,  3.]])
 
         As you can see, there is no rule that says you can't use a string as
         the value of an attribute.
 
         Adding a layer with the same attributes as the entire surface of the
         MaterialLayers will result in the layers being combined.
 
         >>> layers.add(1.0, type=3.0, size="sand")
         >>> layers.add([2, -1, 0], type=3.0, size="sand")
         >>> layers.dz
-        array([[ 4.,  1.,  2.]])
+        array([[4.,  1.,  2.]])
 
         Adding material with different attributes results in the creation of
         a new layer.
 
         >>> layers.add(2.0, type=6.0, size="sand")
         >>> layers.dz
-        array([[ 4.,  1.,  2.],
-               [ 2.,  2.,  2.]])
+        array([[4.,  1.,  2.],
+               [2.,  2.,  2.]])
         >>> layers["type"]
-        array([[ 3.,  3.,  3.],
-               [ 6.,  6.,  6.]])
+        array([[3.,  3.,  3.],
+               [6.,  6.,  6.]])
         >>> np.all(
         ...     layers["size"] == [["sand", "sand", "sand"], ["sand", "sand", "sand"]]
         ... )
         True
 
         Attributes for each layer will exist even if part the the layer is
         associated with erosion.
 
         >>> layers.add([-2, -1, 1], type=8.0, size="gravel")
         >>> layers.dz
-        array([[ 4.,  1.,  2.],
-               [ 0.,  1.,  2.],
-               [ 0.,  0.,  1.]])
-        >>> layers["type"]
-        array([[ 3.,  3.,  3.],
-               [ 6.,  6.,  6.],
-               [ 8.,  8.,  8.]])
+        array([[4.,  1.,  2.],
+               [0.,  1.,  2.],
+               [0.,  0.,  1.]])
+        >>> layers["type"]
+        array([[3.,  3.,  3.],
+               [6.,  6.,  6.],
+               [8.,  8.,  8.]])
 
         To get the values at the surface of the layer stack:
 
         >>> layers.get_surface_values("type")
-        array([ 3.,  6.,  8.])
+        array([3.,  6.,  8.])
 
         Removing enough material such that an entire layer's
         thickness is no longer present, results in that layer
         no longer being tracked. This is another difference
         between MaterialLayers and EventLayers.
 
         >>> layers.add([0.0, 0.0, -1.0])
         >>> layers.dz
-        array([[ 4.,  1.,  2.],
-               [ 0.,  1.,  2.]])
+        array([[4.,  1.,  2.],
+               [0.,  1.,  2.]])
         >>> layers["type"]
-        array([[ 3.,  3.,  3.],
-               [ 6.,  6.,  6.]])
+        array([[3.,  3.,  3.],
+               [6.,  6.,  6.]])
         >>> np.all(
         ...     layers["size"] == [["sand", "sand", "sand"], ["sand", "sand", "sand"]]
         ... )
         True
         >>> layers.number_of_layers
         2
 
         If attributes (like age and size in this example) are tracked, a layer
         will be combined with the surface layer only if all attributes are the
         same across the entire layer. Right now, the surface values vary.
 
         >>> layers.get_surface_values("type")
-        array([ 3.,  6.,  6.])
+        array([3.,  6.,  6.])
         >>> np.all(layers.get_surface_values("size") == ["sand", "sand", "sand"])
         True
 
         Since the surface has different types, adding material will create a
         new layer.
 
         >>> layers.add(3.0, type=6.0, size="sand")
         >>> layers.dz
-        array([[ 4.,  1.,  2.],
-               [ 0.,  1.,  2.],
-               [ 3.,  3.,  3.]])
-        >>> layers["type"]
-        array([[ 3.,  3.,  3.],
-               [ 6.,  6.,  6.],
-               [ 6.,  6.,  6.]])
+        array([[4.,  1.,  2.],
+               [0.,  1.,  2.],
+               [3.,  3.,  3.]])
+        >>> layers["type"]
+        array([[3.,  3.,  3.],
+               [6.,  6.,  6.],
+               [6.,  6.,  6.]])
         >>> layers.number_of_layers
         3
 
         But now, the entire surface has the qualities of type = 6. and size =
         'sand', so layers will be combined. This even works if the thickness of
         the new layer includes both erosion and deposition.
 
         >>> layers.add([-3.5, 0.0, 2.0], type=6.0, size="sand")
         >>> layers.dz
-        array([[ 3.5,  1. ,  2. ],
-               [ 0. ,  1. ,  2. ],
-               [ 0. ,  3. ,  5. ]])
-        >>> layers["type"]
-        array([[ 3.,  3.,  3.],
-               [ 6.,  6.,  6.],
-               [ 6.,  6.,  6.]])
+        array([[3.5,  1. ,  2. ],
+               [0. ,  1. ,  2. ],
+               [0. ,  3. ,  5. ]])
+        >>> layers["type"]
+        array([[3.,  3.,  3.],
+               [6.,  6.,  6.],
+               [6.,  6.,  6.]])
         >>> layers.number_of_layers
         3
         """
         dz = np.asarray(dz)
 
         if self.number_of_layers == 0:
             self._setup_layers(**kwds)
```

### Comparing `landlab-2.7.0/landlab/plot/colors.py` & `landlab-2.8.0/landlab/plot/colors.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/plot/drainage_plot.py` & `landlab-2.8.0/landlab/plot/drainage_plot.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 """Plot drainage network."""
+
 import matplotlib.pylab as plt
 import numpy as np
 
 from landlab.plot.imshow import imshow_grid
 
 # KRB, FEB 2017.
```

### Comparing `landlab-2.7.0/landlab/plot/event_handler.py` & `landlab-2.8.0/landlab/plot/event_handler.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/plot/graph.py` & `landlab-2.8.0/landlab/plot/graph.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/plot/imshow.py` & `landlab-2.8.0/landlab/plot/imshow.py`

 * *Files 1% similar despite different names*

```diff
@@ -15,24 +15,24 @@
 import numpy as np
 
 from ..field import FieldError
 from .event_handler import query_grid_on_button_press
 
 try:
     import matplotlib.pyplot as plt
-    from matplotlib.collections import LineCollection, PatchCollection
+    from matplotlib.collections import LineCollection
+    from matplotlib.collections import PatchCollection
     from matplotlib.patches import Polygon
 except ImportError:
     import warnings
 
     warnings.warn("matplotlib not found", ImportWarning, stacklevel=2)
 
 
 class ModelGridPlotterMixIn:
-
     """MixIn that provides plotting functionality.
 
     Inhert from this class to provide a ModelDataFields object with the
     method function, ``imshow``, that plots a data field.
     """
 
     def imshow(self, *args, **kwds):
```

### Comparing `landlab-2.7.0/landlab/plot/imshowhs.py` & `landlab-2.8.0/landlab/plot/imshowhs.py`

 * *Files 0% similar despite different names*

```diff
@@ -4,19 +4,21 @@
 ++++++++++++++++++
 
 .. autosummary::
 
     ~landlab.plot.imshow.imshowhs_grid
     ~landlab.plot.imshow.imshowhs_grid_at_node
 """
+
 import warnings
 
 import matplotlib.pyplot as plt
 import numpy as np
-from matplotlib.colors import LightSource, to_rgba
+from matplotlib.colors import LightSource
+from matplotlib.colors import to_rgba
 from mpl_toolkits.axes_grid1.inset_locator import inset_axes
 
 from .event_handler import query_grid_on_button_press
 
 
 def imshowhs_grid(grid, values, **kwds):
     """Prepare a map view of data over all nodes in the grid using a hillshade
```

### Comparing `landlab-2.7.0/landlab/plot/layers.py` & `landlab-2.8.0/landlab/plot/layers.py`

 * *Files 1% similar despite different names*

```diff
@@ -162,15 +162,15 @@
 def _insert_shorelines(x, y, sea_level=0.0):
     """Insert shorelines into x-y arrays.
 
     Examples
     --------
     >>> from landlab.plot.layers import _insert_shorelines
     >>> _insert_shorelines([0, 1, 2], [2, 1, -1])
-    (array([ 0. ,  1. ,  1.5,  2. ]), array([ 2.,  1.,  0., -1.]))
+    (array([0. ,  1. ,  1.5,  2. ]), array([ 2.,  1.,  0., -1.]))
     """
     x, y = np.asarray(x, dtype=float), np.asarray(y, dtype=float)
 
     y_relative_to_sea_level = y - sea_level
     shorelines = _search_zero_crossings(y_relative_to_sea_level)
     x_of_shoreline = _interp_zero_crossings(x, y_relative_to_sea_level, shorelines)
 
@@ -246,17 +246,17 @@
     array of float
         Distances to interpolated shorelines.
 
     Examples
     --------
     >>> from landlab.plot.layers import _interp_zero_crossings
     >>> _interp_zero_crossings([0, 1, 2], [1, -1, -1], [0])
-    array([ 0.5])
+    array([0.5])
     >>> _interp_zero_crossings([0, 1, 2, 3], [1, -1, -1, 4], [0, 2])
-    array([ 0.5, 2.2])
+    array([0.5, 2.2])
     """
     x_of_shoreline = []
     for shoreline in shorelines:
         coast = slice(shoreline, shoreline + 2)
 
         # for scipy<1.10 interp1d requires x and y to have at least two elements,
         # which is not the case if theshoreline is the last element.
```

### Comparing `landlab-2.7.0/landlab/plot/network_sediment_transporter/locate_parcel_xy.py` & `landlab-2.8.0/landlab/plot/network_sediment_transporter/locate_parcel_xy.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 Created on Fri Oct 24 16:28:00 2019
 
 This code converts location in a link to an X, Y
 
 
 @author: Jon Czuba, Katy Barnhart
 """
+
 import numpy as np
 
 
 def locate_parcel_xy(grid, parcels, parcel_time_index, parcel_number):
     # determine the location of that parcel in its link
     parcel_loc = parcels.dataset.location_in_link[
         parcel_number, parcel_time_index
```

### Comparing `landlab-2.7.0/landlab/plot/network_sediment_transporter/plot_network_and_parcels.py` & `landlab-2.8.0/landlab/plot/network_sediment_transporter/plot_network_and_parcels.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 This code plots:
     - the network, with option to color each link according to a link attribute.
     - the parcels, with option to color and size each parcel according to
     parcel attributes.
 
 Authors: Katy Barnhart, Jon Czuba, Allison Pfeiffer
 """
+
 import matplotlib.gridspec as gridspec
 import matplotlib.pyplot as plt
 import numpy as np
 from matplotlib.collections import LineCollection
 from matplotlib.colors import Normalize
 
 from landlab.plot.network_sediment_transporter.locate_parcel_xy import locate_parcel_xy
@@ -331,15 +332,15 @@
     # if a parcel color attribute is provided.
     if parcel_color_attribute is not None:
         # if this is true, then instead of none we need to get the right
         # values from the parcels and scale/normalize them correctly. At present
         # plan to support only continuous values. Can be extended to strs as
         # categorical.
         if parcel_color_attribute in parcels.dataset:
-            if "time" in parcels.dataset[parcel_color_attribute].dims:
+            if "time" in parcels.dataset[parcel_color_attribute].sizes:
                 parcel_color = parcels.dataset[parcel_color_attribute].values[
                     :, parcel_time_index
                 ]
             else:
                 parcel_color = parcels.dataset[parcel_color_attribute].values
         else:
             raise ValueError(
@@ -352,15 +353,15 @@
 
     if parcel_size_attribute is not None:
         # if this is true, then instead of none we need to get the right
         # values from the parcels and scale/normalize them correctly. At present
         # plan to support only continuous values. Can be extended to strs as
         # categorical.
         if parcel_size_attribute in parcels.dataset:
-            if "time" in parcels.dataset[parcel_size_attribute].dims:
+            if "time" in parcels.dataset[parcel_size_attribute].sizes:
                 parcel_size_values = parcels.dataset[parcel_size_attribute].values[
                     :, parcel_time_index
                 ]
             else:
                 parcel_size_values = parcels.dataset[parcel_size_attribute].values
 
             if parcel_size_norm is None:
```

### Comparing `landlab-2.7.0/landlab/plot/video_out.py` & `landlab-2.8.0/landlab/plot/video_out.py`

 * *Files 0% similar despite different names*

```diff
@@ -27,15 +27,14 @@
 import matplotlib.pyplot as plt
 import numpy as np
 
 from landlab.plot import imshow
 
 
 class VideoPlotter:
-
     """Create animations of landlab output.
 
     Create Landlab movies.
 
     Parameters
     ----------
     grid : RasterModelGrid
```

### Comparing `landlab-2.7.0/landlab/utils/__init__.py` & `landlab-2.8.0/landlab/utils/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,26 +1,24 @@
 #! /usr/bin/env
 
 from .add_halo import add_halo
 from .count_repeats import count_repeated_values
-from .matrix import get_core_node_at_node, get_core_node_matrix
-from .return_array import return_array_at_link, return_array_at_node
-from .source_tracking_algorithm import (
-    convert_arc_flow_directions_to_landlab_node_ids,
-    find_unique_upstream_hsd_ids_and_fractions,
-    track_source,
-)
+from .matrix import get_core_node_at_node
+from .matrix import get_core_node_matrix
+from .return_array import return_array_at_link
+from .return_array import return_array_at_node
+from .source_tracking_algorithm import convert_arc_flow_directions_to_landlab_node_ids
+from .source_tracking_algorithm import find_unique_upstream_hsd_ids_and_fractions
+from .source_tracking_algorithm import track_source
 from .stable_priority_queue import StablePriorityQueue
-from .watershed import (
-    get_watershed_mask,
-    get_watershed_masks,
-    get_watershed_masks_with_area_threshold,
-    get_watershed_nodes,
-    get_watershed_outlet,
-)
+from .watershed import get_watershed_mask
+from .watershed import get_watershed_masks
+from .watershed import get_watershed_masks_with_area_threshold
+from .watershed import get_watershed_nodes
+from .watershed import get_watershed_outlet
 from .window_statistic import calculate_window_statistic
 
 __all__ = [
     "add_halo",
     "count_repeated_values",
     "track_source",
     "convert_arc_flow_directions_to_landlab_node_ids",
```

### Comparing `landlab-2.7.0/landlab/utils/_matrix.pyx` & `landlab-2.8.0/landlab/utils/_matrix.pyx`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/utils/add_halo.py` & `landlab-2.8.0/landlab/utils/add_halo.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/utils/count_repeats.py` & `landlab-2.8.0/landlab/utils/count_repeats.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/utils/decorators.py` & `landlab-2.8.0/landlab/utils/decorators.py`

 * *Files 0% similar despite different names*

```diff
@@ -136,15 +136,14 @@
         name=func.__name__,
         argspec=str(inspect.signature(func)),
         body=inspect.getdoc(func),
     )
 
 
 class use_field_name_or_array:
-
     """Decorate a function so that it accepts a field name or array.
 
     Parameters
     ----------
     func : function
         A function that accepts a grid and array as arguments.
     at_element : str
@@ -227,15 +226,14 @@
 
             return func(grid, vals, *args, **kwds)
 
         return _wrapped
 
 
 class use_field_name_array_or_value:
-
     """Decorate a function so that it accepts a field name, array, or value.
 
     Parameters
     ----------
     func : function
         A function that accepts a grid and array as arguments.
     at_element : str
@@ -287,15 +285,15 @@
     >>> _ = grid.add_field("elevation", [0, 1, 2, 3, 4, 5], at="cell")
     >>> my_func(grid, "elevation")
     array([  0.,   2.,   4.,   6.,   8.,  10.])
 
     The array of values can be a value (float, int, etc.).
 
     >>> my_func(grid, 4.0)
-    array([ 8.,  8.,  8.,  8.,  8.,  8.])
+    array([8.,  8.,  8.,  8.,  8.,  8.])
     """
 
     def __init__(self, at_element):
         """Initialize the decorator.
 
         Parameters
         ----------
```

### Comparing `landlab-2.7.0/landlab/utils/depth_dependent_roughness.py` & `landlab-2.8.0/landlab/utils/depth_dependent_roughness.py`

 * *Files 0% similar despite different names*

```diff
@@ -26,20 +26,21 @@
 ...     [4.0, 4.0, 4.0, 4.0, 4.0],
 ...     [3.0, 3.0, 3.0, 3.0, 3.0],
 ...     [2.0, 2.0, 2.0, 2.0, 2.0],
 ...     [1.0, 1.0, 1.0, 1.0, 1.0],
 ... ]
 >>> depth_dependent_mannings_n(grid, index_flow_depth=2.0)
 >>> grid.at_node["mannings_n"]
-array([ 0.06      ,  0.06      ,  0.06      ,  0.06      ,  0.06      ,
-        0.06      ,  0.06      ,  0.06      ,  0.06      ,  0.06      ,
-        0.06      ,  0.06      ,  0.06      ,  0.06      ,  0.06      ,
-        0.06      ,  0.06      ,  0.06      ,  0.06      ,  0.06      ,
-        0.07559526,  0.07559526,  0.07559526,  0.07559526,  0.07559526])
+array([0.06      ,  0.06      ,  0.06      ,  0.06      ,  0.06      ,
+       0.06      ,  0.06      ,  0.06      ,  0.06      ,  0.06      ,
+       0.06      ,  0.06      ,  0.06      ,  0.06      ,  0.06      ,
+       0.06      ,  0.06      ,  0.06      ,  0.06      ,  0.06      ,
+       0.07559526,  0.07559526,  0.07559526,  0.07559526,  0.07559526])
 """
+
 import contextlib
 
 import numpy as np
 
 from landlab import FieldError
```

### Comparing `landlab-2.7.0/landlab/utils/distance_to_divide.py` & `landlab-2.8.0/landlab/utils/distance_to_divide.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 #! /usr/bin/env python
 """Functions to calculate flow distance from divide."""
 import numpy as np
 
-from landlab import FieldError, RasterModelGrid
+from landlab import FieldError
+from landlab import RasterModelGrid
 
 
 def calculate_distance_to_divide(
     grid, longest_path=True, add_to_grid=False, clobber=False
 ):
     """Calculate the along flow distance from drainage divide to point.
 
@@ -57,19 +58,19 @@
     >>> fr.run_one_step()
     >>> distance_to_divide = calculate_distance_to_divide(
     ...     mg,
     ...     add_to_grid=True,
     ...     clobber=True,
     ... )
     >>> mg.at_node["distance_to_divide"]
-    array([ 0.,  3.,  3.,  0.,
-            0.,  2.,  2.,  0.,
-            0.,  1.,  1.,  0.,
-            0.,  0.,  0.,  0.,
-            0.,  0.,  0.,  0.])
+    array([0.,  3.,  3.,  0.,
+           0.,  2.,  2.,  0.,
+           0.,  1.,  1.,  0.,
+           0.,  0.,  0.,  0.,
+           0.,  0.,  0.,  0.])
 
     Now, let's change to MFD the flow_director method, which routes flow to
     multiple nodes.
 
     >>> from landlab import RasterModelGrid
     >>> from landlab.components import FlowAccumulator
     >>> from landlab.utils.distance_to_divide import calculate_distance_to_divide
@@ -91,19 +92,19 @@
     >>> fr.run_one_step()
     >>> distance_to_divide = calculate_distance_to_divide(
     ...     mg,
     ...     add_to_grid=True,
     ...     clobber=True,
     ... )
     >>> mg.at_node["distance_to_divide"]
-    array([ 0.,  3.,  3.,  0.,
-            0.,  2.,  2.,  0.,
-            0.,  1.,  1.,  0.,
-            0.,  0.,  0.,  0.,
-            0.,  0.,  0.,  0.])
+    array([0.,  3.,  3.,  0.,
+           0.,  2.,  2.,  0.,
+           0.,  1.,  1.,  0.,
+           0.,  0.,  0.,  0.,
+           0.,  0.,  0.,  0.])
 
     The distance_to_divide utility can also work on irregular grids. For the
     example we will use a Hexagonal Model Grid, a special type of Voroni Grid
     that has regularly spaced hexagonal cells.
 
     >>> from landlab import HexModelGrid
     >>> from landlab.components import FlowAccumulator
@@ -121,19 +122,19 @@
     >>> fr.run_one_step()
     >>> distance_to_divide = calculate_distance_to_divide(
     ...     hmg,
     ...     add_to_grid=True,
     ...     clobber=True,
     ... )
     >>> hmg.at_node["distance_to_divide"]
-    array([ 3.,  0.,  0.,
-         0.,  2.,  1.,  0.,
-       0.,  1.,  1.,  0.,  0.,
-         0.,   0.,  0.,  0.,
-            0.,  0.,  0.])
+    array([3.,  0.,  0.,
+        0.,  2.,  1.,  0.,
+      0.,  1.,  1.,  0.,  0.,
+        0.,   0.,  0.,  0.,
+           0.,  0.,  0.])
     """
     # check that flow__receiver nodes exists
     if "flow__receiver_node" not in grid.at_node:
         raise FieldError(
             "A 'flow__receiver_node' field is required at the "
             "nodes of the input grid."
         )
```

### Comparing `landlab-2.7.0/landlab/utils/ext/jaggedarray.pyx` & `landlab-2.8.0/landlab/utils/ext/jaggedarray.pyx`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/utils/fault_facet_finder.py` & `landlab-2.8.0/landlab/utils/fault_facet_finder.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,17 @@
 scarp degradation, Tucker, Hobley, McCoy.
 """
 
 
 import sys
 
 import numpy as np
-from pylab import figure, plot, show
+from pylab import figure
+from pylab import plot
+from pylab import show
 
 from landlab.plot import imshow as gridshow
 
 
 def cmp(a, b):
     return (a > b) - (a < b)
```

### Comparing `landlab-2.7.0/landlab/utils/flow__distance.py` & `landlab-2.8.0/landlab/utils/flow__distance.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 #! /usr/bin/env python
 """Functions to calculate flow distance."""
 import numpy as np
 
-from landlab import FieldError, RasterModelGrid
+from landlab import FieldError
+from landlab import RasterModelGrid
 
 
 def calculate_flow__distance(grid, add_to_grid=False, clobber=False):
     """Calculate the along flow distance from node to outlet.
 
     This utility calculates the along flow distance based on the results of
     running flow accumulation on the grid. It will use the connectivity
@@ -47,19 +48,19 @@
     ...     right_is_closed=True,
     ...     top_is_closed=True,
     ... )
     >>> fr = FlowAccumulator(mg, flow_director="D8")
     >>> fr.run_one_step()
     >>> flow__distance = calculate_flow__distance(mg, add_to_grid=True, clobber=True)
     >>> mg.at_node["flow__distance"]
-    array([ 0.        ,  0.        ,  0.        ,  0.        ,
-            0.        ,  1.        ,  0.        ,  0.        ,
-            0.        ,  1.41421356,  1.        ,  0.        ,
-            0.        ,  2.41421356,  2.        ,  0.        ,
-            0.        ,  0.        ,  0.        ,  0.        ])
+    array([0.        ,  0.        ,  0.        ,  0.        ,
+           0.        ,  1.        ,  0.        ,  0.        ,
+           0.        ,  1.41421356,  1.        ,  0.        ,
+           0.        ,  2.41421356,  2.        ,  0.        ,
+           0.        ,  0.        ,  0.        ,  0.        ])
 
     Now, let's change to D4 the flow_director method, which does not
     consider diagonal links bewtween nodes.
 
     >>> from landlab import RasterModelGrid
     >>> from landlab.components import FlowAccumulator
     >>> from landlab.utils.flow__distance import calculate_flow__distance
@@ -77,19 +78,19 @@
     ...     right_is_closed=True,
     ...     top_is_closed=True,
     ... )
     >>> fr = FlowAccumulator(mg, flow_director="D4")
     >>> fr.run_one_step()
     >>> flow__distance = calculate_flow__distance(mg, add_to_grid=True, clobber=True)
     >>> mg.at_node["flow__distance"]
-    array([ 0.,  0.,  0.,  0.,
-            0.,  1.,  0.,  0.,
-            0.,  2.,  1.,  0.,
-            0.,  3.,  2.,  0.,
-            0.,  0.,  0.,  0.])
+    array([0.,  0.,  0.,  0.,
+           0.,  1.,  0.,  0.,
+           0.,  2.,  1.,  0.,
+           0.,  3.,  2.,  0.,
+           0.,  0.,  0.,  0.])
 
     The flow__distance utility can also work on irregular grids. For the example we
     will use a Hexagonal Model Grid, a special type of Voroni Grid that has
     regularly spaced hexagonal cells.
 
     >>> from landlab import HexModelGrid
     >>> from landlab.components import FlowAccumulator
@@ -103,19 +104,19 @@
     ... )
     >>> hmg.status_at_node[hmg.boundary_nodes] = hmg.BC_NODE_IS_CLOSED
     >>> hmg.status_at_node[0] = hmg.BC_NODE_IS_FIXED_VALUE
     >>> fr = FlowAccumulator(hmg, flow_director="D4")
     >>> fr.run_one_step()
     >>> flow__distance = calculate_flow__distance(hmg, add_to_grid=True, clobber=True)
     >>> hmg.at_node["flow__distance"]
-    array([ 0.,  0.,  0.,
-            0.,  1.,  2.,  0.,
-            0.,  2.,  2.,  3.,  0.,
-            0.,  3.,  3.,  0.,
-            0.,  0.,  0.])
+    array([0.,  0.,  0.,
+           0.,  1.,  2.,  0.,
+           0.,  2.,  2.,  3.,  0.,
+           0.,  3.,  3.,  0.,
+           0.,  0.,  0.])
     """
     # check that flow__receiver nodes exists
     if "flow__receiver_node" not in grid.at_node:
         raise FieldError(
             "A 'flow__receiver_node' field is required at the "
             "nodes of the input grid."
         )
```

### Comparing `landlab-2.7.0/landlab/utils/jaggedarray.py` & `landlab-2.8.0/landlab/utils/jaggedarray.py`

 * *Files 1% similar despite different names*

```diff
@@ -32,18 +32,19 @@
 >>> values_at_node.array[:] = value_at_link[links_at_node.array]
 
 Now operate on the link values for each node.
 
 >>> values_at_node.foreach_row(sum)
 array([  6.,   8.,   9.,  17.,  22.,  22.,  11.,  19.,  16.])
 >>> values_at_node.foreach_row(min)
-array([ 0.,  0.,  1.,  2.,  2.,  3.,  4.,  4.,  5.])
+array([0.,  0.,  1.,  2.,  2.,  3.,  4.,  4.,  5.])
 >>> values_at_node.foreach_row(np.ptp)
-array([ 6.,  7.,  7.,  7.,  8.,  8.,  3.,  6.,  6.])
+array([6.,  7.,  7.,  7.,  8.,  8.,  3.,  6.,  6.])
 """
+
 import numpy as np
 
 
 def flatten_jagged_array(jagged, dtype=None):
     """Flatten a list of lists.
 
     Parameters
@@ -113,15 +114,14 @@
 
     unravel(data, offset, out)
 
     return out
 
 
 class JaggedArray:
-
     """A container for an array of variable-length arrays.
 
     JaggedArray([row0, row1, ...])
     JaggedArray(values, values_per_row)
 
     Examples
     --------
```

### Comparing `landlab-2.7.0/landlab/utils/jaggedarray_ma.py` & `landlab-2.8.0/landlab/utils/jaggedarray_ma.py`

 * *Files 1% similar despite different names*

```diff
@@ -32,25 +32,25 @@
 
 >>> values_at_node = MaskedJaggedArray.empty_like(links_at_node, dtype=float)
 >>> values_at_node.array = value_at_link[links_at_node.array]
 
 Now operate on the link values for each node.
 
 >>> values_at_node.foreach_row(np.sum)
-array([  6.,   8.,   9.,  17.,  22.,  22.,  11.,  19.,  16.])
+array([ 6.,   8.,   9.,  17.,  22.,  22.,  11.,  19.,  16.])
 >>> values_at_node.foreach_row(np.min)
-array([ 0.,  0.,  1.,  2.,  2.,  3.,  4.,  4.,  5.])
+array([0.,  0.,  1.,  2.,  2.,  3.,  4.,  4.,  5.])
 >>> values_at_node.foreach_row(np.ptp)
-array([ 6.,  7.,  7.,  7.,  8.,  8.,  3.,  6.,  6.])
+array([6.,  7.,  7.,  7.,  8.,  8.,  3.,  6.,  6.])
 """
+
 import numpy as np
 
 
 class MaskedJaggedArray:
-
     """A container for an array of variable-length arrays.
 
     MaskedJaggedArray([row0, row1, ...])
     MaskedJaggedArray(values, values_per_row)
 
     Examples
     --------
```

### Comparing `landlab-2.7.0/landlab/utils/matrix.py` & `landlab-2.8.0/landlab/utils/matrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,16 @@
 #!/usr/bin/env python3
 """Functions to set up a finite-volume solution matrix for a landlab grid."""
 
 import numpy as np
 from scipy.sparse import csc_matrix
 
-from ._matrix import (
-    fill_right_hand_side,
-    get_matrix_diagonal_elements,
-    get_matrix_diagonal_elements_with_coef,
-)
+from ._matrix import fill_right_hand_side
+from ._matrix import get_matrix_diagonal_elements
+from ._matrix import get_matrix_diagonal_elements_with_coef
 
 
 def get_core_node_at_node(grid):
     """Get node ids as numbered by core nodes.
 
     Get the core node ID for each node of a grid. If a node is not a core
     node, then use -1.
```

### Comparing `landlab-2.7.0/landlab/utils/return_array.py` & `landlab-2.8.0/landlab/utils/return_array.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/utils/source_tracking_algorithm.py` & `landlab-2.8.0/landlab/utils/source_tracking_algorithm.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/utils/stable_priority_queue.py` & `landlab-2.8.0/landlab/utils/stable_priority_queue.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/utils/structured_grid.py` & `landlab-2.8.0/landlab/utils/structured_grid.py`

 * *Files 0% similar despite different names*

```diff
@@ -359,17 +359,17 @@
         Coordinate of lower-left node.
 
     Examples
     --------
     >>> from landlab.utils.structured_grid import node_coords
     >>> (cols, rows) = node_coords((3, 2))
     >>> rows
-    array([ 0.,  0.,  1.,  1.,  2.,  2.])
+    array([0.,  0.,  1.,  1.,  2.,  2.])
     >>> cols
-    array([ 0.,  1.,  0.,  1.,  0.,  1.])
+    array([0.,  1.,  0.,  1.,  0.,  1.])
     """
     try:
         spacing = args[0]
     except IndexError:
         spacing = np.ones(len(shape), dtype=float)
     else:
         assert len(spacing) == len(shape)
@@ -744,23 +744,23 @@
     Examples
     --------
     >>> import numpy as np
     >>> from landlab.utils.structured_grid import vertical_inactive_link_mask
     >>> ns = np.ones(12, dtype=bool)  # case of no closed boundary nodes
     >>> vertical_inactive_link_mask((3, 4), ns)
     array([[False, False],
-           [False, False]], dtype=bool)
+           [False, False]])
     >>> ns[2] = False  # node 2 is a closed boundary
     >>> vertical_inactive_link_mask((3, 4), ns)
     array([[False,  True],
-           [False, False]], dtype=bool)
+           [False, False]])
     >>> ns[9] = False  # node 9 is also a closed boundary
     >>> vertical_inactive_link_mask((3, 4), ns)
     array([[False,  True],
-           [ True, False]], dtype=bool)
+           [ True, False]])
     """
     # Create a 2D boolean matrix indicating whether NODES are closed boundaries
     # GT thinks this should be False, not 0
     is_closed_node = node_status == 0
     is_closed_node.shape = shape
 
     inactive_outlinks = is_closed_node[:-1, 1:-1]  # middle cols, all but top row
```

### Comparing `landlab-2.7.0/landlab/utils/suppress_output.py` & `landlab-2.8.0/landlab/utils/suppress_output.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/landlab/utils/watershed.py` & `landlab-2.8.0/landlab/utils/watershed.py`

 * *Files 0% similar despite different names*

```diff
@@ -53,15 +53,15 @@
     >>> get_watershed_mask(rmg, 2).reshape(rmg.shape)
     array([[False, False,  True, False, False, False, False],
            [False, False,  True, False, False, False, False],
            [False,  True,  True,  True, True,  True,  False],
            [False,  True,  True,  True,  True,  True, False],
            [False,  True,  True,  True,  True,  True, False],
            [False,  True,  True,  True,  True,  True, False],
-           [False, False, False, False, False, False, False]], dtype=bool)
+           [False, False, False, False, False, False, False]])
     """
     if "flow__receiver_node" not in grid.at_node:
         raise FieldError(
             "A 'flow__receiver_node' field is required at the "
             "nodes of the input grid."
         )
```

### Comparing `landlab-2.7.0/landlab/utils/window_statistic.py` & `landlab-2.8.0/landlab/utils/window_statistic.py`

 * *Files 1% similar despite different names*

```diff
@@ -137,19 +137,19 @@
     >>> grid.at_node["topographic__elevation"]
     array([ 0.,   1.,   2.,   3.,   4.,   5.,
             6.,   7.,   8.,   9.,  10.,  11.,
            12.,  13.,  14.,  15.,  16.,  17.,
            18.,  19.,  20.,  21.,  22.,  23.,
            24.,  25.,  26.,  27.,  28.,  29.])
     >>> relief
-    array([ nan,  nan,  nan,  nan,  nan,  nan,
-             7.,   8.,   8.,   8.,   8.,   7.,
-            13.,  14.,  14.,  14.,  14.,  13.,
-             7.,   8.,   8.,   8.,   8.,   7.,
-            nan,  nan,  nan,  nan,  nan,  nan])
+    array([nan,  nan,  nan,  nan,  nan,  nan,
+            7.,   8.,   8.,   8.,   8.,   7.,
+           13.,  14.,  14.,  14.,  14.,  13.,
+            7.,   8.,   8.,   8.,   8.,   7.,
+           nan,  nan,  nan,  nan,  nan,  nan])
 
     Calculate 90th percentile using ``np.percentile`` function and ``kwargs``.
 
     >>> perc_90 = calculate_window_statistic(
     ...     grid,
     ...     "topographic__elevation",
     ...     np.percentile,
@@ -188,19 +188,19 @@
     >>> grid.at_node["topographic__elevation"]
     array([ 0.,   1.,   2.,   3.,   4.,   5.,
             6.,   7.,   8.,   9.,  10.,  11.,
            12.,  13.,  14.,  15.,  16.,  17.,
            18.,  19.,  20.,  21.,  22.,  23.,
            24.,  25.,  26.,  27.,  28.,  29.])
     >>> rel_above_90th_perc
-    array([ nan,  nan,  nan,  nan,  nan,  nan,
-            0.3,  0.5,  0.5,  0.5,  0.5,  0.3,
-            0.5,  0.8,  0.8,  0.8,  0.8,  0.5,
-            0.3,  0.5,  0.5,  0.5,  0.5,  0.3,
-            nan,  nan,  nan,  nan,  nan,  nan])
+    array([nan,  nan,  nan,  nan,  nan,  nan,
+           0.3,  0.5,  0.5,  0.5,  0.5,  0.3,
+           0.5,  0.8,  0.8,  0.8,  0.8,  0.5,
+           0.3,  0.5,  0.5,  0.5,  0.5,  0.3,
+           nan,  nan,  nan,  nan,  nan,  nan])
     """
     if field not in grid.at_node:
         raise FieldError(f"A {field} field is required at the nodes of the input grid.")
 
     # Create output array
     output = np.zeros(grid.number_of_nodes)
```

### Comparing `landlab-2.7.0/landlab/values/synthetic.py` & `landlab-2.8.0/landlab/values/synthetic.py`

 * *Files 0% similar despite different names*

```diff
@@ -51,47 +51,48 @@
 ...     mg,
 ...     "topographic__elevation",
 ...     where=((mg.x_of_node <= 3) & (mg.y_of_node > 3)),
 ...     point=(0, 6, 0),
 ...     normal=(-1, 1, 1),
 ... )
 >>> mg.at_node["topographic__elevation"]
-array([ 0.,  1.,  2.,  3.,  2.,  1.,  0.,
-        1.,  2.,  3.,  4.,  3.,  2.,  1.,
-        2.,  3.,  4.,  5.,  4.,  3.,  2.,
-        3.,  4.,  5.,  6.,  5.,  4.,  3.,
-        2.,  3.,  4.,  5.,  4.,  3.,  2.,
-        1.,  2.,  3.,  4., 3.,   2.,  1.,
-        0.,  1.,  2.,  3.,  2.,  1.,  0.])
+array([0.,  1.,  2.,  3.,  2.,  1.,  0.,
+       1.,  2.,  3.,  4.,  3.,  2.,  1.,
+       2.,  3.,  4.,  5.,  4.,  3.,  2.,
+       3.,  4.,  5.,  6.,  5.,  4.,  3.,
+       2.,  3.,  4.,  5.,  4.,  3.,  2.,
+       1.,  2.,  3.,  4., 3.,   2.,  1.,
+       0.,  1.,  2.,  3.,  2.,  1.,  0.])
 
 Next add uniformly distributed noise.
 
 >>> noise = random(
 ...     mg, "topographic__elevation", where=NodeStatus.CORE, distribution="uniform"
 ... )
 >>> np.round(mg.at_node["topographic__elevation"], decimals=3)
-array([ 0.   ,  1.   ,  2.   ,  3.   ,  2.   ,  1.   ,  0.   ,
-        1.   ,  2.375,  3.951,  4.732,  3.599,  2.156,  1.   ,
-        2.   ,  3.156,  4.058,  5.866,  4.601,  3.708,  2.   ,
-        3.   ,  4.021,  5.97 ,  6.832,  5.212,  4.182,  3.   ,
-        2.   ,  3.183,  4.304,  5.525,  4.432,  3.291,  2.   ,
-        1.   ,  2.612,  3.139,  4.292,  3.366,  2.456,  1.   ,
-        0.   ,  1.   ,  2.   ,  3.   ,  2.   ,  1.   ,  0.   ])
+array([0.   ,  1.   ,  2.   ,  3.   ,  2.   ,  1.   ,  0.   ,
+       1.   ,  2.375,  3.951,  4.732,  3.599,  2.156,  1.   ,
+       2.   ,  3.156,  4.058,  5.866,  4.601,  3.708,  2.   ,
+       3.   ,  4.021,  5.97 ,  6.832,  5.212,  4.182,  3.   ,
+       2.   ,  3.183,  4.304,  5.525,  4.432,  3.291,  2.   ,
+       1.   ,  2.612,  3.139,  4.292,  3.366,  2.456,  1.   ,
+       0.   ,  1.   ,  2.   ,  3.   ,  2.   ,  1.   ,  0.   ])
 
 At present only a small selection of possible synthetic functions exist. If
 your research requires additional functions, consider contributing one back to
 the main landlab repository. If you have questions on how to proceed, please
 create a GitHub issue.
 
 All public functions from this submodule should have a common format. They
 take as the first two arguments a model grid, and the name of the field.
 They all take two keyword arguments: ``at``, which specifies which grid element
 values are placed, and ``where``, which indicates where the values are placed.
 Additional keyword arguments are required as needed by each function.
 """
+
 from collections import defaultdict
 
 import numpy as np
 
 from landlab.grid.linkstatus import LinkStatus
 from landlab.grid.network import NetworkModelGrid
 from landlab.grid.nodestatus import NodeStatus
@@ -224,18 +225,18 @@
     ...     "node",
     ...     where="CORE_NODE",
     ...     distribution="uniform",
     ...     high=3.0,
     ...     low=2.0,
     ... )
     >>> mg.at_node["soil__depth"]
-    array([ 0.        ,  0.        ,  0.        ,  0.        ,
-            0.        ,  2.37454012,  2.95071431,  0.        ,
-            0.        ,  2.73199394,  2.59865848,  0.        ,
-            0.        ,  0.        ,  0.        ,  0.        ])
+    array([0.        ,  0.        ,  0.        ,  0.        ,
+           0.        ,  2.37454012,  2.95071431,  0.        ,
+           0.        ,  2.73199394,  2.59865848,  0.        ,
+           0.        ,  0.        ,  0.        ,  0.        ])
     """
     where = _where_to_add_values(grid, at, where)
     _create_missing_field(grid, name, at)
     values = np.zeros(grid.size(at))
 
     if distribution not in np.random.__dict__:
         raise ValueError("")
@@ -282,18 +283,18 @@
     >>> from landlab import RasterModelGrid
     >>> from landlab.values import plane
     >>> mg = RasterModelGrid((4, 4))
     >>> values = plane(
     ...     mg, "soil__depth", "node", point=(0.0, 0.0, 0.0), normal=(-1.0, -1.0, 1.0)
     ... )
     >>> mg.at_node["soil__depth"]
-    array([ 0.,  1.,  2.,  3.,
-            1.,  2.,  3.,  4.,
-            2.,  3.,  4.,  5.,
-            3.,  4.,  5.,  6.])
+    array([0.,  1.,  2.,  3.,
+           1.,  2.,  3.,  4.,
+           2.,  3.,  4.,  5.,
+           3.,  4.,  5.,  6.])
     """
     x, y = _get_x_and_y(grid, at)
 
     where = _where_to_add_values(grid, at, where)
     _create_missing_field(grid, name, at)
     values = _plane_function(x, y, point, normal)
     grid[at][name][where] += values[where]
```

### Comparing `landlab-2.7.0/landlab.egg-info/PKG-INFO` & `landlab-2.8.0/landlab.egg-info/PKG-INFO`

 * *Files 5% similar despite different names*

```diff
@@ -1,37 +1,16 @@
 Metadata-Version: 2.1
 Name: landlab
-Version: 2.7.0
+Version: 2.8.0
 Summary: Open-source Python package for numerical modeling of Earth surface dynamics.
 Author: The landlab team
 Author-email: mcflugen@gmail.com
 Maintainer: The landlab team
 Maintainer-email: mcflugen@gmail.com
-License: The MIT License (MIT)
-        =====================
-        
-        Copyright (c) `2013` `The Landlab Team`
-        
-        Permission is hereby granted, free of charge, to any person obtaining a copy of
-        this software and associated documentation files (the "Software"), to deal in
-        the Software without restriction, including without limitation the rights to
-        use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-        the Software, and to permit persons to whom the Software is furnished to do so,
-        subject to the following conditions:
-        
-        The above copyright notice and this permission notice shall be included in all
-        copies or substantial portions of the Software.
-        
-        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-        FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-        COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-        IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-        CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-        
+License: MIT
 Project-URL: homepage, https://github.com/landlab
 Project-URL: documentation, https://landlab.readthedocs.io
 Project-URL: repository, https://github.com/landlab
 Project-URL: changelog, https://github.com/landlab/landlab/blob/develop/CHANGES.rst
 Keywords: bmi,component modeling,earth science,gridding engine,model coupling,numerical modeling
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Science/Research
@@ -45,14 +24,15 @@
 Classifier: Programming Language :: Python :: Implementation :: CPython
 Classifier: Topic :: Scientific/Engineering :: Physics
 Requires-Python: >=3.10
 Description-Content-Type: text/x-rst
 License-File: LICENSE.rst
 License-File: AUTHORS.rst
 Requires-Dist: bmipy
+Requires-Dist: importlib-resources; python_version < "3.12"
 Requires-Dist: matplotlib
 Requires-Dist: netcdf4
 Requires-Dist: numpy>=1.20
 Requires-Dist: pyyaml
 Requires-Dist: pyshp!=2.3.0
 Requires-Dist: rich-click
 Requires-Dist: scipy
```

### Comparing `landlab-2.7.0/landlab.egg-info/SOURCES.txt` & `landlab-2.8.0/landlab.egg-info/SOURCES.txt`

 * *Files 3% similar despite different names*

```diff
@@ -50,14 +50,16 @@
 landlab/components/bedrock_landslider/__init__.py
 landlab/components/bedrock_landslider/bedrock_landslider.py
 landlab/components/bedrock_landslider/cfuncs.pyx
 landlab/components/carbonate/__init__.py
 landlab/components/carbonate/carbonate_producer.py
 landlab/components/chi_index/__init__.py
 landlab/components/chi_index/channel_chi.py
+landlab/components/concentration_tracker/__init__.py
+landlab/components/concentration_tracker/concentration_tracker_for_diffusion.py
 landlab/components/depression_finder/__init__.py
 landlab/components/depression_finder/cfuncs.pyx
 landlab/components/depression_finder/floodstatus.py
 landlab/components/depression_finder/lake_mapper.py
 landlab/components/depth_dependent_diffusion/__init__.py
 landlab/components/depth_dependent_diffusion/hillslope_depth_dependent_linear_flux.py
 landlab/components/depth_dependent_taylor_soil_creep/__init__.py
@@ -136,14 +138,17 @@
 landlab/components/lateral_erosion/node_finder.py
 landlab/components/lithology/README.md
 landlab/components/lithology/__init__.py
 landlab/components/lithology/litholayers.py
 landlab/components/lithology/lithology.py
 landlab/components/marine_sediment_transport/__init__.py
 landlab/components/marine_sediment_transport/simple_submarine_diffuser.py
+landlab/components/mass_wasting_runout/__init__.py
+landlab/components/mass_wasting_runout/mass_wasting_runout.py
+landlab/components/mass_wasting_runout/mass_wasting_saver.py
 landlab/components/network_sediment_transporter/README.md
 landlab/components/network_sediment_transporter/__init__.py
 landlab/components/network_sediment_transporter/bed_parcel_initializers.py
 landlab/components/network_sediment_transporter/network_sediment_transporter.py
 landlab/components/network_sediment_transporter/sediment_pulser_at_links.py
 landlab/components/network_sediment_transporter/sediment_pulser_base.py
 landlab/components/network_sediment_transporter/sediment_pulser_each_parcel.py
@@ -283,15 +288,14 @@
 landlab/field/errors.py
 landlab/field/graph_field.py
 landlab/framework/__init__.py
 landlab/framework/component.py
 landlab/framework/decorators.py
 landlab/framework/interfaces.py
 landlab/graph/__init__.py
-landlab/graph/cfuncs.pyx
 landlab/graph/dual.py
 landlab/graph/graph.py
 landlab/graph/graph_convention.py
 landlab/graph/ugrid.py
 landlab/graph/ext/__init__.py
 landlab/graph/framed_voronoi/__init__.py
 landlab/graph/framed_voronoi/dual_framed_voronoi.py
@@ -314,16 +318,20 @@
 landlab/graph/object/ext/__init__.py
 landlab/graph/object/ext/at_node.pyx
 landlab/graph/object/ext/at_patch.pyx
 landlab/graph/quantity/__init__.py
 landlab/graph/quantity/of_link.py
 landlab/graph/quantity/of_patch.py
 landlab/graph/quantity/ext/__init__.py
+landlab/graph/quantity/ext/of_element.pyx
 landlab/graph/quantity/ext/of_link.pyx
 landlab/graph/quantity/ext/of_patch.pyx
+landlab/graph/quasi_spherical/__init__.py
+landlab/graph/quasi_spherical/dual_icosphere.py
+landlab/graph/quasi_spherical/refinable_icosahedron.py
 landlab/graph/radial/__init__.py
 landlab/graph/radial/dual_radial.py
 landlab/graph/radial/radial.py
 landlab/graph/sort/__init__.py
 landlab/graph/sort/intpair.py
 landlab/graph/sort/sort.py
 landlab/graph/sort/ext/__init__.py
@@ -356,14 +364,15 @@
 landlab/grid/diagonals.py
 landlab/grid/divergence.py
 landlab/grid/framed_voronoi.py
 landlab/grid/gradients.py
 landlab/grid/grid_funcs.py
 landlab/grid/hex.py
 landlab/grid/hex_mappers.py
+landlab/grid/icosphere.py
 landlab/grid/linkorientation.py
 landlab/grid/linkstatus.py
 landlab/grid/mappers.py
 landlab/grid/network.py
 landlab/grid/nodestatus.py
 landlab/grid/radial.py
 landlab/grid/raster.py
@@ -381,27 +390,25 @@
 landlab/grid/unstructured/base.py
 landlab/grid/unstructured/cells.py
 landlab/grid/unstructured/links.py
 landlab/grid/unstructured/nodes.py
 landlab/grid/unstructured/status.py
 landlab/io/__init__.py
 landlab/io/esri_ascii.py
+landlab/io/legacy_vtk.py
 landlab/io/native_landlab.py
 landlab/io/obj.py
-landlab/io/legacy_vtk/__init__.py
-landlab/io/legacy_vtk/legacy_vtk.py
+landlab/io/shapefile.py
 landlab/io/netcdf/__init__.py
 landlab/io/netcdf/_constants.py
 landlab/io/netcdf/dump.py
 landlab/io/netcdf/errors.py
 landlab/io/netcdf/load.py
 landlab/io/netcdf/read.py
 landlab/io/netcdf/write.py
-landlab/io/shapefile/__init__.py
-landlab/io/shapefile/read_shapefile.py
 landlab/layers/__init__.py
 landlab/layers/eventlayers.py
 landlab/layers/materiallayers.py
 landlab/layers/ext/__init__.py
 landlab/layers/ext/eventlayers.pyx
 landlab/plot/__init__.py
 landlab/plot/colors.py
@@ -432,14 +439,15 @@
 landlab/utils/stable_priority_queue.py
 landlab/utils/structured_grid.py
 landlab/utils/suppress_output.py
 landlab/utils/watershed.py
 landlab/utils/window_statistic.py
 landlab/utils/ext/__init__.py
 landlab/utils/ext/jaggedarray.pyx
+landlab/utils/geometry/spherical.py
 landlab/values/__init__.py
 landlab/values/synthetic.py
 requirements/README.md
 requirements/docs.txt
 requirements/notebooks.txt
 requirements/required.txt
 requirements/testing.txt
@@ -457,14 +465,16 @@
 tests/components/test_components.py
 tests/components/advection_solver/test_advection_solver.py
 tests/components/advection_solver/test_flux_limiters.py
 tests/components/bedrock_landslider/test_bedrock_landslider.py
 tests/components/carbonate/test_carbonate_producer.py
 tests/components/chi_index/__init__.py
 tests/components/chi_index/test_chi_finder.py
+tests/components/concentration_tracker/__init__.py
+tests/components/concentration_tracker/test_concentration_tracker_for_diffusion.py
 tests/components/depression_finder/conftest.py
 tests/components/depression_finder/test_lake_mapper.py
 tests/components/depth_dependent_diffusion/__init__.py
 tests/components/depth_dependent_diffusion/test_depth_dependent_diffuser.py
 tests/components/depth_dependent_taylor_soil_creep/__init__.py
 tests/components/depth_dependent_taylor_soil_creep/test_depth_dependent_taylor_diffuser.py
 tests/components/diffusion/__init__.py
@@ -511,14 +521,16 @@
 tests/components/landslides/conftest.py
 tests/components/landslides/test_landslide_probability.py
 tests/components/lateral_erosion/test_latero.py
 tests/components/lateral_erosion/test_node_finder.py
 tests/components/lithology/test_litholayers.py
 tests/components/lithology/test_lithology.py
 tests/components/marine_sediment_transport/test_simple_submarine_diffuser.py
+tests/components/mass_wasting_runout/conftest.py
+tests/components/mass_wasting_runout/test_mass_wasting_runout.py
 tests/components/network_sediment_transporter/__init__.py
 tests/components/network_sediment_transporter/conftest.py
 tests/components/network_sediment_transporter/test_abrasion.py
 tests/components/network_sediment_transporter/test_active_layer_methods.py
 tests/components/network_sediment_transporter/test_bed_initializer.py
 tests/components/network_sediment_transporter/test_filo.py
 tests/components/network_sediment_transporter/test_init.py
@@ -624,14 +636,16 @@
 tests/graph/framed_voronoi/test_framed_voronoi.py
 tests/graph/framed_voronoi/test_perimeter_nodes.py
 tests/graph/hex/__init__.py
 tests/graph/hex/conftest.py
 tests/graph/hex/test_dual_hex.py
 tests/graph/hex/test_hex.py
 tests/graph/hex/test_perimeter_nodes.py
+tests/graph/quantity/__init__.py
+tests/graph/quantity/test_of_element.py
 tests/graph/radial/__init__.py
 tests/graph/radial/test_dual_radial.py
 tests/graph/sort/__init__.py
 tests/graph/sort/test_intpair.py
 tests/graph/sort/test_remap.py
 tests/graph/structured_quad/__init__.py
 tests/graph/structured_quad/test_dual_quad.py
@@ -699,14 +713,16 @@
 tests/grid/test_raster_grid/test_save.py
 tests/grid/test_raster_grid/test_status_at_node.py
 tests/grid/unstructured/__init__.py
 tests/grid/unstructured/test_links.py
 tests/io/__init__.py
 tests/io/test_read_esri_ascii.py
 tests/io/test_read_write_native.py
+tests/io/test_shapefile.py
+tests/io/test_shapefile_infer_dtype.py
 tests/io/test_write_esri_ascii.py
 tests/io/test_write_obj.py
 tests/io/legacy_vtk/test_legacy_vtk.py
 tests/io/netcdf/__init__.py
 tests/io/netcdf/conftest.py
 tests/io/netcdf/test_from_netcdf.py
 tests/io/netcdf/test_read_netcdf.py
@@ -714,25 +730,23 @@
 tests/io/netcdf/test_write_netcdf.py
 tests/io/netcdf/test_write_raster_netcdf.py
 tests/io/netcdf/test_from_netcdf/test-HexModelGrid.nc
 tests/io/netcdf/test_from_netcdf/test-RadialModelGrid.nc
 tests/io/netcdf/test_from_netcdf/test-RasterModelGrid.nc
 tests/io/netcdf/test_read_netcdf/test-netcdf3-64bit.nc
 tests/io/netcdf/test_read_netcdf/test-netcdf4.nc
-tests/io/shapefile/test_infer_dtype.py
-tests/io/shapefile/test_read_shapefile.py
-tests/io/shapefile/test_read_shapefile/multipartpolyline.dbf
-tests/io/shapefile/test_read_shapefile/multipartpolyline.shp
-tests/io/shapefile/test_read_shapefile/multipartpolyline.shx
-tests/io/shapefile/test_read_shapefile/points.dbf
-tests/io/shapefile/test_read_shapefile/points.shp
-tests/io/shapefile/test_read_shapefile/points.shx
 tests/io/test_read_esri_ascii/4_x_3.asc
 tests/io/test_read_esri_ascii/4_x_3_no_nodata_value.asc
 tests/io/test_read_esri_ascii/hugo_site.asc
+tests/io/test_shapefile/multipartpolyline.dbf
+tests/io/test_shapefile/multipartpolyline.shp
+tests/io/test_shapefile/multipartpolyline.shx
+tests/io/test_shapefile/points.dbf
+tests/io/test_shapefile/points.shp
+tests/io/test_shapefile/points.shx
 tests/layers/test_event_layers.py
 tests/layers/test_material_layers.py
 tests/plot/__init__.py
 tests/plot/test_drainage_plot.py
 tests/plot/test_event_handler.py
 tests/plot/test_graph.py
 tests/plot/test_imshow_grid.py
```

### Comparing `landlab-2.7.0/notebooks.py` & `landlab-2.8.0/notebooks.py`

 * *Files 0% similar despite different names*

```diff
@@ -11,14 +11,15 @@
     $ python -m notebooks
 
 To get notebooks for a particular version of *landlab*, provide
 a version number as an argument. For example,
 
     $ python -m notebooks 2.5.0
 """
+
 import argparse
 import os
 import pathlib
 import sys
 import tarfile
 from urllib.error import HTTPError
 from urllib.parse import urljoin
```

### Comparing `landlab-2.7.0/noxfile.py` & `landlab-2.8.0/noxfile.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 import json
 import os
 import pathlib
 import shutil
+import sys
 
 import nox
 from packaging.requirements import Requirement
 
 PROJECT = "landlab"
 ROOT = pathlib.Path(__file__).parent
-PYTHON_VERSION = "3.11"
+PYTHON_VERSION = "3.12"
 PATH = {
     "build": ROOT / "build",
     "docs": ROOT / "docs",
     "nox": pathlib.Path(".nox"),
     "requirements": ROOT / "requirements",
     "root": ROOT,
 }
@@ -21,14 +22,18 @@
 @nox.session(python=PYTHON_VERSION, venv_backend="conda")
 def test(session: nox.Session) -> None:
     """Run the tests."""
     os.environ["WITH_OPENMP"] = "1"
 
     session.log(f"CC = {os.environ.get('CC', 'NOT FOUND')}")
 
+    if sys.platform.startswith("darwin") and session.python == "3.12":
+        session.log("installing multidict from conda-forge.")
+        session.conda_install("multidict")
+
     session.install(
         "-r",
         PATH["requirements"] / "required.txt",
         "-r",
         PATH["requirements"] / "testing.txt",
     )
 
@@ -66,14 +71,18 @@
         "-n",
         "auto",
         "-vvv",
     ] + session.posargs
 
     os.environ["WITH_OPENMP"] = "1"
 
+    if sys.platform.startswith("darwin") and session.python == "3.12":
+        session.log("installing multidict from conda-forge")
+        session.conda_install("multidict")
+
     session.install(
         "-r",
         PATH["requirements"] / "required.txt",
         "-r",
         PATH["requirements"] / "testing.txt",
         "-r",
         PATH["requirements"] / "notebooks.txt",
```

### Comparing `landlab-2.7.0/pyproject.toml` & `landlab-2.8.0/pyproject.toml`

 * *Files 26% similar despite different names*

```diff
@@ -17,15 +17,14 @@
   "bmi",
   "component modeling",
   "earth science",
   "gridding engine",
   "model coupling",
   "numerical modeling",
 ]
-license = {file = "LICENSE.rst"}
 classifiers = [
   "Development Status :: 4 - Beta",
   "Intended Audience :: Science/Research",
   "License :: OSI Approved :: MIT License",
   "Operating System :: OS Independent",
   "Programming Language :: Cython",
   "Programming Language :: Python :: 3",
@@ -34,27 +33,31 @@
   "Programming Language :: Python :: 3.12",
   "Programming Language :: Python :: Implementation :: CPython",
   "Topic :: Scientific/Engineering :: Physics",
 ]
 requires-python = ">=3.10"
 dependencies = [
   "bmipy",
+  "importlib-resources; python_version < '3.12'",
   "matplotlib",
   "netcdf4",
   "numpy >=1.20",
   "pyyaml",
   "pyshp != 2.3.0",
   "rich-click",
   "scipy",
   "statsmodels",
   "pandas",
   "xarray >= 0.16",
 ]
 dynamic = ["readme", "version"]
 
+[project.license]
+text = "MIT"
+
 [project.urls]
 homepage = "https://github.com/landlab"
 documentation = "https://landlab.readthedocs.io"
 repository = "https://github.com/landlab"
 changelog = "https://github.com/landlab/landlab/blob/develop/CHANGES.rst"
 
 [project.optional-dependencies]
@@ -129,16 +132,40 @@
 profile = "black"
 
 [tool.check-manifest]
 ignore = [".nox", "build"]
 
 [tool.cibuildwheel]
 build = "cp310-* cp311-* cp312-*"
-skip = "*-musllinux_*"
+skip = "*-musllinux_* *-win32*"
 archs = "x86_64,aarch64,arm64,AMD64,x86"
+test-command = "python -c \"import landlab; print(landlab.__version__)\""
+
+[tool.cibuildwheel.macos]
+before-all = "brew install libomp"
+# before-all = "brew install llvm libomp"
+
+[tool.cibuildwheel.macos.environment]
+LANDLAB_WITHOUT_OPENMP = "1"
+LDFLAGS = "-Wl,-rpath,/opt/homebrew/opt/libomp/lib -L/opt/homebrew/opt/libomp/lib -L/opt/homebrew/opt/llvm/lib/c++ -Wl,-rpath,/opt/homebrew/opt/llvm/lib/c++ -lomp"
+CPPFLAGS = "-Xpreprocessor -fopenmp -I/opt/homebrew/opt/libomp/include"
+CFLAGS = "-Wno-implicit-function-declaration -I/opt/homebrew/opt/libomp/include"
+CXXFLAGS = "-I/opt/homebrew/opt/libomp/include"
+# PATH = "/opt/homebrew/opt/llvm/bin:$PATH"
+
+[[tool.cibuildwheel.overrides]]
+select = "*x86_64*"
+environment = {"LANDLAB_WITHOUT_OPENMP"="1"}
+
+[tool.cibuildwheel.windows.environment]
+LANDLAB_WITHOUT_OPENMP = "1"
+
+[tool.cython-lint]
+max-line-length = 88
+exclude = "tests/components/flow_router/ext/single_flow/priority_routing/test_breach_c.pyx"
 
 [tool.conda-lock]
 channels = ["conda-forge", "defaults"]
 platforms = ["osx-arm64", "linux-64", "osx-64", "win-64"]
 
 [tool.towncrier]
 directory = "news"
@@ -154,10 +181,16 @@
   {name="New Features", directory="feature", showcontent=true},
   {name="Bug Fixes", directory="bugfix", showcontent=true},
   {name="Documentation Enhancements", directory="docs", showcontent=true},
   {name="Other Changes and Additions", directory="misc", showcontent=true},
 ]
 
 [tool.landlab.credits]
-ignore = ["(no author)", "root", "dependabot[bot]"]
+exclude = '''
+(?x)^(
+  \(no\ author\)|
+  root|
+  .*\[bot\]  # ignore all bots
+)
+'''
 authors_file = "AUTHORS.rst"
 author_format = "* `{name} <https://github.com/{github}>`_"
```

### Comparing `landlab-2.7.0/tests/ca/boundaries/test_hex_normal_fault.py` & `landlab-2.8.0/tests/ca/boundaries/test_hex_normal_fault.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,21 +2,20 @@
 """
 Created on Fri Jun 15 09:31:10 2018
 
 @author: gtucker
 """
 
 import numpy as np
-from numpy.testing import assert_array_equal, assert_equal
+from numpy.testing import assert_array_equal
+from numpy.testing import assert_equal
 
 from landlab import HexModelGrid
-from landlab.ca.boundaries.hex_lattice_tectonicizer import (
-    LatticeNormalFault,
-    LatticeUplifter,
-)
+from landlab.ca.boundaries.hex_lattice_tectonicizer import LatticeNormalFault
+from landlab.ca.boundaries.hex_lattice_tectonicizer import LatticeUplifter
 from landlab.ca.celllab_cts import Transition
 from landlab.ca.oriented_hex_cts import OrientedHexCTS
 
 
 def test_links_to_update():
     """Test that update list includes lower 2 rows and fault-crossing links"""
```

### Comparing `landlab-2.7.0/tests/ca/cts_model.py` & `landlab-2.8.0/tests/ca/cts_model.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 #!/usr/env/python
 import time
 
 from matplotlib.pyplot import axis
 from numpy import random
 
-from landlab.ca.celllab_cts import CAPlotter, Transition
+from landlab.ca.celllab_cts import CAPlotter
+from landlab.ca.celllab_cts import Transition
 from landlab.io.native_landlab import save_grid
 
 _DEBUG = False
 
 
 class CTSModel:
     """
```

### Comparing `landlab-2.7.0/tests/ca/grain_hill.py` & `landlab-2.8.0/tests/ca/grain_hill.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,21 +3,27 @@
 Hillslope model with block uplift.
 """
 
 import sys
 import time
 
 from matplotlib.pyplot import axis
-from numpy import amax, arange, count_nonzero, logical_and, where, zeros
+from numpy import amax
+from numpy import arange
+from numpy import count_nonzero
+from numpy import logical_and
+from numpy import where
+from numpy import zeros
 
 from landlab.ca.boundaries.hex_lattice_tectonicizer import LatticeUplifter
 from landlab.ca.celllab_cts import Transition
 
 from .cts_model import CTSModel
-from .lattice_grain import lattice_grain_node_states, lattice_grain_transition_list
+from .lattice_grain import lattice_grain_node_states
+from .lattice_grain import lattice_grain_transition_list
 
 _DEBUG = False
 
 
 def plot_hill(grid, filename=None, array=None, cmap=None, show=True):
     """Generate a plot of the modeled hillslope."""
     import matplotlib as mpl
```

### Comparing `landlab-2.7.0/tests/ca/lattice_grain.py` & `landlab-2.8.0/tests/ca/lattice_grain.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/ca/test_celllab_cts.py` & `landlab-2.8.0/tests/ca/test_celllab_cts.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,17 +3,19 @@
 
 Created on Thu Jul  9 08:20:06 2015
 
 @author: gtucker
 """
 
 import numpy as np
-from numpy.testing import assert_array_equal, assert_raises
+from numpy.testing import assert_array_equal
+from numpy.testing import assert_raises
 
-from landlab import HexModelGrid, RasterModelGrid
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.ca.celllab_cts import Transition
 from landlab.ca.hex_cts import HexCTS
 from landlab.ca.oriented_hex_cts import OrientedHexCTS
 from landlab.ca.oriented_raster_cts import OrientedRasterCTS
 from landlab.ca.raster_cts import RasterCTS
```

### Comparing `landlab-2.7.0/tests/ca/test_user_guide_example.py` & `landlab-2.8.0/tests/ca/test_user_guide_example.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/advection_solver/test_advection_solver.py` & `landlab-2.8.0/tests/components/advection_solver/test_advection_solver.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,18 @@
 import numpy as np
 import pytest
-from numpy.testing import (
-    assert_almost_equal,
-    assert_array_almost_equal,
-    assert_array_equal,
-)
+from numpy.testing import assert_almost_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
-from landlab import HexModelGrid, RasterModelGrid
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.components import AdvectionSolverTVD
-from landlab.components.advection import (
-    find_upwind_link_at_link,
-    upwind_to_local_grad_ratio,
-)
+from landlab.components.advection import find_upwind_link_at_link
+from landlab.components.advection import upwind_to_local_grad_ratio
 from landlab.grid.linkorientation import LinkOrientation
 
 
 @pytest.mark.parametrize("u", [0.0, 1.0, 10.0, [1.0] * 17])
 def test_upwind_link_at_link_raster_positive(u):
     grid = RasterModelGrid((3, 4))
     uwl = find_upwind_link_at_link(grid, u)
```

### Comparing `landlab-2.7.0/tests/components/advection_solver/test_flux_limiters.py` & `landlab-2.8.0/tests/components/advection_solver/test_flux_limiters.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/bedrock_landslider/test_bedrock_landslider.py` & `landlab-2.8.0/tests/components/bedrock_landslider/test_bedrock_landslider.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,16 +7,18 @@
 Doc tests and unit tests for bedrock landslides using the BedrockLandslider component.
 """
 
 import numpy as np
 import pytest
 from numpy import testing
 
-from landlab import FieldError, RasterModelGrid
-from landlab.components import BedrockLandslider, PriorityFloodFlowRouter
+from landlab import FieldError
+from landlab import RasterModelGrid
+from landlab.components import BedrockLandslider
+from landlab.components import PriorityFloodFlowRouter
 
 try:
     PriorityFloodFlowRouter.load_richdem()
 except ModuleNotFoundError:
     pytestmark = pytest.mark.skip(reason="richdem is not installed")
```

### Comparing `landlab-2.7.0/tests/components/carbonate/test_carbonate_producer.py` & `landlab-2.8.0/tests/components/carbonate/test_carbonate_producer.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 #! /usr/bin/env python
 """
 Unit tests for landlab.components.carbonate.carbonate_producer
 """
-from numpy.testing import assert_allclose, assert_raises
+from numpy.testing import assert_allclose
+from numpy.testing import assert_raises
 
 from landlab import RasterModelGrid
 from landlab.components import CarbonateProducer
 
 
 def test_properties():
     grid = RasterModelGrid((3, 3))
```

### Comparing `landlab-2.7.0/tests/components/chi_index/test_chi_finder.py` & `landlab-2.8.0/tests/components/chi_index/test_chi_finder.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,11 +1,13 @@
 import pytest
 
-from landlab import HexModelGrid, RasterModelGrid
-from landlab.components import ChiFinder, FlowAccumulator
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
+from landlab.components import ChiFinder
+from landlab.components import FlowAccumulator
 
 
 def test_route_to_multiple_error_raised():
     mg = RasterModelGrid((10, 10))
     z = mg.add_zeros("topographic__elevation", at="node")
     z += mg.x_of_node + mg.y_of_node
     fa = FlowAccumulator(mg, flow_director="MFD")
```

### Comparing `landlab-2.7.0/tests/components/depression_finder/conftest.py` & `landlab-2.8.0/tests/components/depression_finder/conftest.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 import numpy as np
 import pytest
 
 from landlab import RasterModelGrid
-from landlab.components import DepressionFinderAndRouter, FlowAccumulator
+from landlab.components import DepressionFinderAndRouter
+from landlab.components import FlowAccumulator
 
 XX = RasterModelGrid.BAD_INDEX
 
 
 @pytest.fixture
 def dans_grid3():
     """
```

### Comparing `landlab-2.7.0/tests/components/depression_finder/test_lake_mapper.py` & `landlab-2.8.0/tests/components/depression_finder/test_lake_mapper.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,22 +1,25 @@
 """
 test_lake_mapper:
 
 Created on Sun Sep 27 09:52:50, 2015
 
 @author: gtucker, amended dejh
 """
+
 import numpy as np  # for use of np.round
 import pytest
-from numpy import pi, sin
+from numpy import pi
+from numpy import sin
 from numpy.testing import assert_array_equal
 from pytest import approx
 
 from landlab import RasterModelGrid
-from landlab.components import DepressionFinderAndRouter, FlowAccumulator
+from landlab.components import DepressionFinderAndRouter
+from landlab.components import FlowAccumulator
 from landlab.components.depression_finder.cfuncs import (
     find_lowest_node_on_lake_perimeter_c,
 )
 
 NUM_GRID_ROWS = 8
 NUM_GRID_COLS = 8
 PERIOD_X = 8.0
```

### Comparing `landlab-2.7.0/tests/components/depth_dependent_diffusion/test_depth_dependent_diffuser.py` & `landlab-2.8.0/tests/components/depth_dependent_diffusion/test_depth_dependent_diffuser.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,15 +3,16 @@
 Created on Fri Mar  3 10:39:32 2017
 
 @author: gtucker
 """
 import pytest
 
 from landlab import RasterModelGrid
-from landlab.components import DepthDependentDiffuser, ExponentialWeatherer
+from landlab.components import DepthDependentDiffuser
+from landlab.components import ExponentialWeatherer
 
 
 def test_raise_kwargs_error():
     mg = RasterModelGrid((5, 5))
     soilTh = mg.add_zeros("soil__depth", at="node")
     z = mg.add_zeros("topographic__elevation", at="node")
     BRz = mg.add_zeros("bedrock__elevation", at="node")
```

### Comparing `landlab-2.7.0/tests/components/depth_dependent_taylor_soil_creep/test_depth_dependent_taylor_diffuser.py` & `landlab-2.8.0/tests/components/depth_dependent_taylor_soil_creep/test_depth_dependent_taylor_diffuser.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,15 +5,16 @@
 @author: gtucker
 """
 import numpy as np
 import pytest
 from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
-from landlab.components import DepthDependentTaylorDiffuser, ExponentialWeatherer
+from landlab.components import DepthDependentTaylorDiffuser
+from landlab.components import ExponentialWeatherer
 
 
 def test_4x7_grid_vs_analytical_solution():
     """Test against known analytical solution."""
 
     # Create a 4-row by 7-column grid with 10 m spacing
     mg = RasterModelGrid((4, 7), xy_spacing=10.0)
```

### Comparing `landlab-2.7.0/tests/components/diffusion/test_sniff_diffusion.py` & `landlab-2.8.0/tests/components/diffusion/test_sniff_diffusion.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,17 +1,20 @@
 """Test the diffuser component.
 
 This tester turns over the diffuser a couple of times to ensure basic
 functionality is working.
 """
+
 import numpy as np
 import pytest
-from numpy.testing import assert_array_almost_equal, assert_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_equal
 
-from landlab import HexModelGrid, RasterModelGrid
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.components.diffusion import LinearDiffuser
 
 
 @pytest.mark.parametrize("at", ("node", "link"))
 def test_diffusion_as_string(at):
     grid = RasterModelGrid((5, 5))
     grid.add_ones("topographic__elevation", at="node")
```

### Comparing `landlab-2.7.0/tests/components/dimensionless_discharge/test_dimensionless_discharge.py` & `landlab-2.8.0/tests/components/dimensionless_discharge/test_dimensionless_discharge.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/drainage_density/test_drainage_density.py` & `landlab-2.8.0/tests/components/drainage_density/test_drainage_density.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,18 @@
 import numpy as np
 import pytest
-from numpy.testing import assert_almost_equal, assert_array_equal
+from numpy.testing import assert_almost_equal
+from numpy.testing import assert_array_equal
 
-from landlab import FieldError, HexModelGrid, RasterModelGrid
-from landlab.components import DrainageDensity, FastscapeEroder, FlowAccumulator
+from landlab import FieldError
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
+from landlab.components import DrainageDensity
+from landlab.components import FastscapeEroder
+from landlab.components import FlowAccumulator
 
 
 def test_route_to_multiple_error_raised():
     mg = RasterModelGrid((10, 10))
     z = mg.add_zeros("topographic__elevation", at="node")
     z += mg.x_of_node + mg.y_of_node
     fa = FlowAccumulator(mg, flow_director="MFD")
```

### Comparing `landlab-2.7.0/tests/components/erosion_deposition/test_ero_dep_mass_conservation.py` & `landlab-2.8.0/tests/components/erosion_deposition/test_ero_dep_mass_conservation.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 import pytest
 from numpy.testing import assert_array_almost_equal
 
 from landlab import RasterModelGrid
-from landlab.components import ErosionDeposition, FlowAccumulator, Space
+from landlab.components import ErosionDeposition
+from landlab.components import FlowAccumulator
+from landlab.components import Space
 
 
 @pytest.fixture
 def grid():
     grid = RasterModelGrid((10, 10), xy_spacing=10.0)
     grid.set_closed_boundaries_at_grid_edges(True, True, True, True)
     z = grid.add_zeros("node", "topographic__elevation")
```

### Comparing `landlab-2.7.0/tests/components/erosion_deposition/test_ero_dep_with_flats.py` & `landlab-2.8.0/tests/components/erosion_deposition/test_ero_dep_with_flats.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,20 @@
 #!/usr/bin/env python3
 """
 Created on Thu Apr 23 09:09:49 2020
 
 @author: gtucker
 """
 
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
-from landlab.components import ErosionDeposition, FlowAccumulator
+from landlab.components import ErosionDeposition
+from landlab.components import FlowAccumulator
 
 
 def test_without_depression_handling():
     grid = RasterModelGrid((3, 5), xy_spacing=10.0)
     grid.set_closed_boundaries_at_grid_edges(False, True, False, True)
     z = grid.add_zeros("node", "topographic__elevation")
     z[grid.x_of_node < 15.0] = 10.0
```

### Comparing `landlab-2.7.0/tests/components/erosion_deposition/test_erodep.py` & `landlab-2.8.0/tests/components/erosion_deposition/test_erodep.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,16 +5,18 @@
 @author: gtucker
 """
 
 import numpy as np
 import pytest
 from numpy import testing
 
-from landlab import HexModelGrid, RasterModelGrid
-from landlab.components import ErosionDeposition, FlowAccumulator
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
+from landlab.components import ErosionDeposition
+from landlab.components import FlowAccumulator
 
 
 def test_route_to_multiple_error_raised():
     mg = RasterModelGrid((10, 10))
     z = mg.add_zeros("topographic__elevation", at="node")
     z += mg.x_of_node + mg.y_of_node
     fa = FlowAccumulator(mg, flow_director="MFD")
```

### Comparing `landlab-2.7.0/tests/components/erosion_deposition/test_erodep_steady_state.py` & `landlab-2.8.0/tests/components/erosion_deposition/test_erodep_steady_state.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,15 +5,16 @@
 @author: gtucker
 """
 
 import numpy as np
 from numpy.testing import assert_equal
 
 from landlab import RasterModelGrid
-from landlab.components import ErosionDeposition, FlowAccumulator
+from landlab.components import ErosionDeposition
+from landlab.components import FlowAccumulator
 
 
 def test_erodep_slope_area_small_vs():
     """Test steady state run with Vs << 1."""
 
     # Set up a 5x5 grid with open boundaries and low initial elevations.
     rg = RasterModelGrid((5, 5))
```

### Comparing `landlab-2.7.0/tests/components/erosion_deposition/test_general_erodep.py` & `landlab-2.8.0/tests/components/erosion_deposition/test_general_erodep.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 import numpy as np
 import pytest
 from numpy import testing
 
 from landlab import RasterModelGrid
-from landlab.components import ErosionDeposition, FlowAccumulator
+from landlab.components import ErosionDeposition
+from landlab.components import FlowAccumulator
 
 
 def test_Ff_too_high_vals():
     """
     Test that instantiating ErosionDeposition with a F_f value > 1 throws a
     ValueError.
     """
```

### Comparing `landlab-2.7.0/tests/components/flexure/conftest.py` & `landlab-2.8.0/tests/components/flexure/conftest.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/flexure/test_api.py` & `landlab-2.8.0/tests/components/flexure/test_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,11 +1,13 @@
 import numpy as np
-from pytest import approx, raises
+from pytest import approx
+from pytest import raises
 
-from landlab.components.flexure import get_flexure_parameter, subside_point_load
+from landlab.components.flexure import get_flexure_parameter
+from landlab.components.flexure import subside_point_load
 
 
 def test_calc_flexure_parameter():
     eet, youngs = 65000.0, 7e10
     alpha_1d = get_flexure_parameter(eet, youngs, 1)
     alpha_2d = get_flexure_parameter(eet, youngs, 2)
     assert alpha_2d == approx(84828.72)
```

### Comparing `landlab-2.7.0/tests/components/flexure/test_flexure.py` & `landlab-2.8.0/tests/components/flexure/test_flexure.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/flexure/test_flexure_1d.py` & `landlab-2.8.0/tests/components/flexure/test_flexure_1d.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,14 @@
 #! /usr/bin/env python
 """Unit tests for landlab.components.flexure.Flexure1D."""
 import numpy as np
 import pytest
-from numpy.testing import (
-    assert_array_almost_equal,
-    assert_array_equal,
-    assert_array_less,
-)
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
+from numpy.testing import assert_array_less
 
 from landlab import RasterModelGrid
 from landlab.components.flexure import Flexure1D
 
 (_SHAPE, _SPACING, _ORIGIN) = ((20, 20), (10e3, 10e3), (0.0, 0.0))
 _ARGS = (_SHAPE, _SPACING, _ORIGIN)
```

### Comparing `landlab-2.7.0/tests/components/flow_accum/conftest.py` & `landlab-2.8.0/tests/components/flow_accum/conftest.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/flow_accum/test_flow_accums.py` & `landlab-2.8.0/tests/components/flow_accum/test_flow_accums.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/flow_accum/test_flow_accumulator.py` & `landlab-2.8.0/tests/components/flow_accum/test_flow_accumulator.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,77 +1,69 @@
 """Test the flow accumulator component.
 
 @author: krb
 """
+
 # Created on Thurs Nov 12, 2015
 import os
 
 import numpy as np
 import pytest
 from numpy.testing import assert_array_equal
 
-from landlab import FieldError, HexModelGrid, NetworkModelGrid, RasterModelGrid
+from landlab import FieldError
+from landlab import HexModelGrid
+from landlab import NetworkModelGrid
+from landlab import RasterModelGrid
 from landlab.components import LinearDiffuser
 from landlab.components.depression_finder.lake_mapper import DepressionFinderAndRouter
 from landlab.components.flow_accum import FlowAccumulator
-from landlab.components.flow_director import (
-    FlowDirectorD8,
-    FlowDirectorDINF,
-    FlowDirectorMFD,
-    FlowDirectorSteepest,
-)
+from landlab.components.flow_director import FlowDirectorD8
+from landlab.components.flow_director import FlowDirectorDINF
+from landlab.components.flow_director import FlowDirectorMFD
+from landlab.components.flow_director import FlowDirectorSteepest
 
 _THIS_DIR = os.path.abspath(os.path.dirname(__file__))
 
 
 def test_check_fields():
     """Check to make sure the right fields have been created."""
 
     mg = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    z = mg.add_field(
-        "topographic__elevation", mg.node_x**2 + mg.node_y**2, at="node"
-    )
+    z = mg.add_field("topographic__elevation", mg.node_x**2 + mg.node_y**2, at="node")
 
     FlowAccumulator(mg)
     assert_array_equal(z, mg.at_node["topographic__elevation"])
     assert_array_equal(np.zeros(100), mg.at_node["drainage_area"])
     assert_array_equal(np.ones(100), mg.at_node["water__unit_flux_in"])
 
     FlowAccumulator(mg, runoff_rate=2.0)
     assert_array_equal(np.full(100, 2.0), mg.at_node["water__unit_flux_in"])
 
 
 def test_director_adding_methods_are_equivalent_Steepest():
     """Check that different methods to specifying the director are the same."""
 
     mg0 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg0.add_field(
-        "topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node"
-    )
+    mg0.add_field("topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node")
     fa0 = FlowAccumulator(mg0, flow_director="D4")
     fa0.run_one_step()
 
     mg1 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg1.add_field(
-        "topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node"
-    )
+    mg1.add_field("topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node")
     fa1 = FlowAccumulator(mg1, flow_director="Steepest")
     fa1.run_one_step()
 
     mg2 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg2.add_field(
-        "topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node"
-    )
+    mg2.add_field("topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node")
     fa2 = FlowAccumulator(mg2, flow_director=FlowDirectorSteepest)
     fa2.run_one_step()
 
     mg3 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg3.add_field(
-        "topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node"
-    )
+    mg3.add_field("topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node")
     fd = FlowDirectorSteepest(mg3)
     fa3 = FlowAccumulator(mg3, flow_director=fd)
     fa3.run_one_step()
 
     for loc in ["node", "link", "grid"]:
         for key in mg0[loc].keys():
             if loc == "grid":
@@ -88,38 +80,30 @@
                 assert_array_equal(mg2[loc][key], mg3[loc][key])
 
 
 def test_director_adding_methods_are_equivalent_D8():
     """Check that different methods to specifying the director are the same."""
 
     mg0 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg0.add_field(
-        "topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node"
-    )
+    mg0.add_field("topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node")
     fa0 = FlowAccumulator(mg0, flow_director="D8")
     fa0.run_one_step()
 
     mg1 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg1.add_field(
-        "topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node"
-    )
+    mg1.add_field("topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node")
     fa1 = FlowAccumulator(mg1, flow_director="FlowDirectorD8")
     fa1.run_one_step()
 
     mg2 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg2.add_field(
-        "topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node"
-    )
+    mg2.add_field("topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node")
     fa2 = FlowAccumulator(mg2, flow_director=FlowDirectorD8)
     fa2.run_one_step()
 
     mg3 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg3.add_field(
-        "topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node"
-    )
+    mg3.add_field("topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node")
     fd = FlowDirectorD8(mg3)
     fa3 = FlowAccumulator(mg3, flow_director=fd)
     fa3.run_one_step()
 
     for loc in ["node", "link", "grid"]:
         for key in mg0[loc].keys():
             if loc == "grid":
@@ -136,38 +120,30 @@
                 assert_array_equal(mg2[loc][key], mg3[loc][key])
 
 
 def test_director_adding_methods_are_equivalent_Dinf():
     """Check that different methods to specifying the director are the same."""
 
     mg0 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg0.add_field(
-        "topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node"
-    )
+    mg0.add_field("topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node")
     fa0 = FlowAccumulator(mg0, flow_director="DINF")
     fa0.run_one_step()
 
     mg1 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg1.add_field(
-        "topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node"
-    )
+    mg1.add_field("topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node")
     fa1 = FlowAccumulator(mg1, flow_director="FlowDirectorDINF")
     fa1.run_one_step()
 
     mg2 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg2.add_field(
-        "topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node"
-    )
+    mg2.add_field("topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node")
     fa2 = FlowAccumulator(mg2, flow_director=FlowDirectorDINF)
     fa2.run_one_step()
 
     mg3 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg3.add_field(
-        "topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node"
-    )
+    mg3.add_field("topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node")
     fd = FlowDirectorDINF(mg3)
     fa3 = FlowAccumulator(mg3, flow_director=fd)
     fa3.run_one_step()
 
     for loc in ["node", "link", "grid"]:
         for key in mg0[loc].keys():
             if loc == "grid":
@@ -184,38 +160,30 @@
                 assert_array_equal(mg2[loc][key], mg3[loc][key])
 
 
 def test_director_adding_methods_are_equivalent_MFD():
     """Check that different methods to specifying the director are the same."""
 
     mg0 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg0.add_field(
-        "topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node"
-    )
+    mg0.add_field("topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node")
     fa0 = FlowAccumulator(mg0, flow_director="MFD")
     fa0.run_one_step()
 
     mg1 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg1.add_field(
-        "topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node"
-    )
+    mg1.add_field("topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node")
     fa1 = FlowAccumulator(mg1, flow_director="FlowDirectorMFD")
     fa1.run_one_step()
 
     mg2 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg2.add_field(
-        "topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node"
-    )
+    mg2.add_field("topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node")
     fa2 = FlowAccumulator(mg2, flow_director=FlowDirectorMFD)
     fa2.run_one_step()
 
     mg3 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg3.add_field(
-        "topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node"
-    )
+    mg3.add_field("topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node")
     fd = FlowDirectorMFD(mg3)
     fa3 = FlowAccumulator(mg3, flow_director=fd)
     fa3.run_one_step()
 
     for loc in ["node", "link", "grid"]:
         for key in mg0[loc].keys():
             if loc == "grid":
@@ -244,22 +212,18 @@
         FlowAccumulator(mg, "topographic__elevation", flow_director=ChiFinder)
 
 
 def test_error_for_to_many_with_depression():
     """Check that an error is thrown when to_many methods started DF."""
 
     mg0 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg0.add_field(
-        "topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node"
-    )
+    mg0.add_field("topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node")
 
     mg1 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg1.add_field(
-        "topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node"
-    )
+    mg1.add_field("topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node")
 
     with pytest.raises(NotImplementedError):
         FlowAccumulator(
             mg0, flow_director="MFD", depression_finder="DepressionFinderAndRouter"
         )
     with pytest.raises(NotImplementedError):
         FlowAccumulator(
```

### Comparing `landlab-2.7.0/tests/components/flow_accum/test_flow_routing.py` & `landlab-2.8.0/tests/components/flow_accum/test_flow_routing.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/flow_accum/test_lossy_flow_accumulator.py` & `landlab-2.8.0/tests/components/flow_accum/test_lossy_flow_accumulator.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 """Test the flow accumulator component.
 
 @author: krb
 """
+
 # Created on Thurs Nov 12, 2015
 import os
 
 import numpy as np
 import pytest
 from numpy.testing import assert_array_equal
 
-from landlab import HexModelGrid, RasterModelGrid
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.components import LinearDiffuser
 from landlab.components.depression_finder.lake_mapper import DepressionFinderAndRouter
 from landlab.components.flow_accum import LossyFlowAccumulator
-from landlab.components.flow_director import (
-    FlowDirectorD8,
-    FlowDirectorDINF,
-    FlowDirectorMFD,
-    FlowDirectorSteepest,
-)
+from landlab.components.flow_director import FlowDirectorD8
+from landlab.components.flow_director import FlowDirectorDINF
+from landlab.components.flow_director import FlowDirectorMFD
+from landlab.components.flow_director import FlowDirectorSteepest
 
 _THIS_DIR = os.path.abspath(os.path.dirname(__file__))
 
 
 def test_loss_func_arguments():
     """Check the loss_function only has one argument."""
     mg = RasterModelGrid((10, 10), xy_spacing=(1, 1))
@@ -142,17 +142,15 @@
     )
 
 
 def test_check_fields():
     """Check to make sure the right fields have been created."""
 
     mg = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    z = mg.add_field(
-        "topographic__elevation", mg.node_x**2 + mg.node_y**2, at="node"
-    )
+    z = mg.add_field("topographic__elevation", mg.node_x**2 + mg.node_y**2, at="node")
 
     LossyFlowAccumulator(mg)
     assert_array_equal(z, mg.at_node["topographic__elevation"])
     assert_array_equal(np.zeros(100), mg.at_node["drainage_area"])
     assert_array_equal(np.ones(100), mg.at_node["water__unit_flux_in"])
     assert_array_equal(np.zeros(100), mg.at_node["surface_water__discharge_loss"])
 
@@ -167,38 +165,30 @@
     assert mg.at_node["surface_water__discharge_loss"] is L
 
 
 def test_director_adding_methods_are_equivalent_Steepest():
     """Check that different methods to specifying the director are the same."""
 
     mg0 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg0.add_field(
-        "topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node"
-    )
+    mg0.add_field("topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node")
     fa0 = LossyFlowAccumulator(mg0, flow_director="D4")
     fa0.run_one_step()
 
     mg1 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg1.add_field(
-        "topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node"
-    )
+    mg1.add_field("topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node")
     fa1 = LossyFlowAccumulator(mg1, flow_director="Steepest")
     fa1.run_one_step()
 
     mg2 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg2.add_field(
-        "topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node"
-    )
+    mg2.add_field("topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node")
     fa2 = LossyFlowAccumulator(mg2, flow_director=FlowDirectorSteepest)
     fa2.run_one_step()
 
     mg3 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg3.add_field(
-        "topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node"
-    )
+    mg3.add_field("topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node")
     fd = FlowDirectorSteepest(mg3)
     fa3 = LossyFlowAccumulator(mg3, flow_director=fd)
     fa3.run_one_step()
 
     for key in mg0.at_node.keys():
         assert_array_equal(mg0.at_node[key], mg1.at_node[key])
 
@@ -207,38 +197,30 @@
         assert_array_equal(mg2.at_node[key], mg3.at_node[key])
 
 
 def test_director_adding_methods_are_equivalent_D8():
     """Check that different methods to specifying the director are the same."""
 
     mg0 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg0.add_field(
-        "topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node"
-    )
+    mg0.add_field("topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node")
     fa0 = LossyFlowAccumulator(mg0, flow_director="D8")
     fa0.run_one_step()
 
     mg1 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg1.add_field(
-        "topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node"
-    )
+    mg1.add_field("topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node")
     fa1 = LossyFlowAccumulator(mg1, flow_director="FlowDirectorD8")
     fa1.run_one_step()
 
     mg2 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg2.add_field(
-        "topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node"
-    )
+    mg2.add_field("topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node")
     fa2 = LossyFlowAccumulator(mg2, flow_director=FlowDirectorD8)
     fa2.run_one_step()
 
     mg3 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg3.add_field(
-        "topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node"
-    )
+    mg3.add_field("topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node")
     fd = FlowDirectorD8(mg3)
     fa3 = LossyFlowAccumulator(mg3, flow_director=fd)
     fa3.run_one_step()
 
     for key in mg0.at_node.keys():
         assert_array_equal(mg0.at_node[key], mg1.at_node[key])
 
@@ -247,38 +229,30 @@
         assert_array_equal(mg2.at_node[key], mg3.at_node[key])
 
 
 def test_director_adding_methods_are_equivalent_Dinf():
     """Check that different methods to specifying the director are the same."""
 
     mg0 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg0.add_field(
-        "topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node"
-    )
+    mg0.add_field("topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node")
     fa0 = LossyFlowAccumulator(mg0, flow_director="DINF")
     fa0.run_one_step()
 
     mg1 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg1.add_field(
-        "topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node"
-    )
+    mg1.add_field("topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node")
     fa1 = LossyFlowAccumulator(mg1, flow_director="FlowDirectorDINF")
     fa1.run_one_step()
 
     mg2 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg2.add_field(
-        "topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node"
-    )
+    mg2.add_field("topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node")
     fa2 = LossyFlowAccumulator(mg2, flow_director=FlowDirectorDINF)
     fa2.run_one_step()
 
     mg3 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg3.add_field(
-        "topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node"
-    )
+    mg3.add_field("topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node")
     fd = FlowDirectorDINF(mg3)
     fa3 = LossyFlowAccumulator(mg3, flow_director=fd)
     fa3.run_one_step()
 
     for key in mg0.at_node.keys():
         assert_array_equal(mg0.at_node[key], mg1.at_node[key])
 
@@ -287,38 +261,30 @@
         assert_array_equal(mg2.at_node[key], mg3.at_node[key])
 
 
 def test_director_adding_methods_are_equivalent_MFD():
     """Check that different methods to specifying the director are the same."""
 
     mg0 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg0.add_field(
-        "topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node"
-    )
+    mg0.add_field("topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node")
     fa0 = LossyFlowAccumulator(mg0, flow_director="MFD")
     fa0.run_one_step()
 
     mg1 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg1.add_field(
-        "topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node"
-    )
+    mg1.add_field("topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node")
     fa1 = LossyFlowAccumulator(mg1, flow_director="FlowDirectorMFD")
     fa1.run_one_step()
 
     mg2 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg2.add_field(
-        "topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node"
-    )
+    mg2.add_field("topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node")
     fa2 = LossyFlowAccumulator(mg2, flow_director=FlowDirectorMFD)
     fa2.run_one_step()
 
     mg3 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg3.add_field(
-        "topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node"
-    )
+    mg3.add_field("topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node")
     fd = FlowDirectorMFD(mg3)
     fa3 = LossyFlowAccumulator(mg3, flow_director=fd)
     fa3.run_one_step()
 
     for key in mg0.at_node.keys():
         assert_array_equal(mg0.at_node[key], mg1.at_node[key])
 
@@ -339,22 +305,18 @@
         LossyFlowAccumulator(mg, "topographic__elevation", flow_director=ChiFinder)
 
 
 def test_error_for_to_many_with_depression():
     """Check that an error is thrown when to_many methods started DF."""
 
     mg0 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg0.add_field(
-        "topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node"
-    )
+    mg0.add_field("topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node")
 
     mg1 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg1.add_field(
-        "topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node"
-    )
+    mg1.add_field("topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node")
 
     with pytest.raises(NotImplementedError):
         LossyFlowAccumulator(
             mg0, flow_director="MFD", depression_finder="DepressionFinderAndRouter"
         )
     with pytest.raises(NotImplementedError):
         LossyFlowAccumulator(
```

### Comparing `landlab-2.7.0/tests/components/flow_director/test_cfuncs.py` & `landlab-2.8.0/tests/components/flow_director/test_cfuncs.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 import numpy as np
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
 import landlab.components.flow_director.cfuncs as _cfuncs
-from landlab import HexModelGrid, RasterModelGrid
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 
 
 def test_hex():
     grid = HexModelGrid((3, 3))
     z = grid.x_of_node
 
     steepest_slope = np.zeros(grid.number_of_nodes)
```

### Comparing `landlab-2.7.0/tests/components/flow_director/test_dinf.py` & `landlab-2.8.0/tests/components/flow_director/test_dinf.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,15 @@
 import numpy as np
 import pytest
 from numpy.testing import assert_array_equal
 
-from landlab import RasterModelGrid, VoronoiDelaunayGrid
-from landlab.components import FlowAccumulator, FlowDirectorDINF
+from landlab import RasterModelGrid
+from landlab import VoronoiDelaunayGrid
+from landlab.components import FlowAccumulator
+from landlab.components import FlowDirectorDINF
 from landlab.components.flow_director import flow_direction_dinf
 
 
 def test_not_implemented_voroni():
     x = [0, 0.1, 0.2, 0.3, 1, 1.1, 1.2, 1.3, 2, 2.1, 2.2, 2.3]
     y = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]
     vmg = VoronoiDelaunayGrid(x, y)
```

### Comparing `landlab-2.7.0/tests/components/flow_director/test_flow_director.py` & `landlab-2.8.0/tests/components/flow_director/test_flow_director.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,25 +1,26 @@
 """Test the flow director components.
 
 @author: krb
 """
+
 # Created on Thurs Nov 12, 2015
 import os
 
 import numpy as np
 import pytest
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
-from landlab import HexModelGrid, RasterModelGrid
-from landlab.components.flow_director import (
-    FlowDirectorD8,
-    FlowDirectorDINF,
-    FlowDirectorMFD,
-    FlowDirectorSteepest,
-)
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
+from landlab.components.flow_director import FlowDirectorD8
+from landlab.components.flow_director import FlowDirectorDINF
+from landlab.components.flow_director import FlowDirectorMFD
+from landlab.components.flow_director import FlowDirectorSteepest
 from landlab.components.flow_director.flow_director import _FlowDirector
 from landlab.components.flow_director.flow_director_to_many import _FlowDirectorToMany
 from landlab.components.flow_director.flow_director_to_one import _FlowDirectorToOne
 
 _THIS_DIR = os.path.abspath(os.path.dirname(__file__))
 
 
@@ -76,101 +77,87 @@
     """Check to make sure the right fields have been created.
 
     Check that the sizes of at least one are also correct (they are at node
     so if one is the right size, then they all should be)
     """
 
     mg0 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg0.add_field(
-        "topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node"
-    )
+    mg0.add_field("topographic__elevation", mg0.node_x**2 + mg0.node_y**2, at="node")
     _FlowDirector(mg0, "topographic__elevation")
     assert sorted(mg0.at_node) == [
         "flow__sink_flag",
         "topographic__elevation",
     ]
     assert np.size(mg0.at_node["topographic__elevation"]) == mg0.number_of_nodes
 
     mg1 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg1.add_field(
-        "topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node"
-    )
+    mg1.add_field("topographic__elevation", mg1.node_x**2 + mg1.node_y**2, at="node")
     _FlowDirectorToMany(mg1, "topographic__elevation")
     assert sorted(mg1.at_node) == [
         "flow__link_to_receiver_node",
         "flow__receiver_node",
         "flow__receiver_proportions",
         "flow__sink_flag",
         "topographic__elevation",
         "topographic__steepest_slope",
     ]
     assert np.size(mg1.at_node["topographic__elevation"]) == mg1.number_of_nodes
 
     mg2 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg2.add_field(
-        "topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node"
-    )
+    mg2.add_field("topographic__elevation", mg2.node_x**2 + mg2.node_y**2, at="node")
     _FlowDirectorToOne(mg2, "topographic__elevation")
     assert sorted(mg2.at_node) == [
         "flow__link_to_receiver_node",
         "flow__receiver_node",
         "flow__sink_flag",
         "topographic__elevation",
         "topographic__steepest_slope",
     ]
     assert np.size(mg2.at_node["topographic__elevation"]) == mg2.number_of_nodes
 
     mg3 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg3.add_field(
-        "topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node"
-    )
+    mg3.add_field("topographic__elevation", mg3.node_x**2 + mg3.node_y**2, at="node")
     FlowDirectorMFD(mg3, "topographic__elevation")
     assert sorted(mg3.at_node) == [
         "flow__link_to_receiver_node",
         "flow__receiver_node",
         "flow__receiver_proportions",
         "flow__sink_flag",
         "topographic__elevation",
         "topographic__steepest_slope",
     ]
     assert np.size(mg3.at_node["topographic__elevation"]) == mg3.number_of_nodes
 
     mg4 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg4.add_field(
-        "topographic__elevation", mg4.node_x**2 + mg4.node_y**2, at="node"
-    )
+    mg4.add_field("topographic__elevation", mg4.node_x**2 + mg4.node_y**2, at="node")
     FlowDirectorDINF(mg4, "topographic__elevation")
     assert sorted(mg4.at_node) == [
         "flow__link_to_receiver_node",
         "flow__receiver_node",
         "flow__receiver_proportions",
         "flow__sink_flag",
         "topographic__elevation",
         "topographic__steepest_slope",
     ]
     assert np.size(mg4.at_node["topographic__elevation"]) == mg4.number_of_nodes
 
     mg5 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg5.add_field(
-        "topographic__elevation", mg5.node_x**2 + mg5.node_y**2, at="node"
-    )
+    mg5.add_field("topographic__elevation", mg5.node_x**2 + mg5.node_y**2, at="node")
     FlowDirectorSteepest(mg5, "topographic__elevation")
     assert sorted(mg5.at_node) == [
         "flow__link_to_receiver_node",
         "flow__receiver_node",
         "flow__sink_flag",
         "topographic__elevation",
         "topographic__steepest_slope",
     ]
     assert np.size(mg5.at_node["topographic__elevation"]) == mg5.number_of_nodes
 
     mg6 = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    mg6.add_field(
-        "topographic__elevation", mg6.node_x**2 + mg6.node_y**2, at="node"
-    )
+    mg6.add_field("topographic__elevation", mg6.node_x**2 + mg6.node_y**2, at="node")
     FlowDirectorD8(mg6, "topographic__elevation")
     assert sorted(mg6.at_node) == [
         "flow__link_to_receiver_node",
         "flow__receiver_node",
         "flow__sink_flag",
         "topographic__elevation",
         "topographic__steepest_slope",
```

### Comparing `landlab-2.7.0/tests/components/flow_director/test_mfd.py` & `landlab-2.8.0/tests/components/flow_director/test_mfd.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,15 @@
 import numpy as np
 import pytest
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
-from landlab.components import FlowAccumulator, FlowDirectorMFD
+from landlab.components import FlowAccumulator
+from landlab.components import FlowDirectorMFD
 from landlab.components.flow_director import flow_direction_mfd
 
 
 def test_bad_argument_mfd():
     mg = RasterModelGrid((5, 5), xy_spacing=(1, 1))
     z = mg.add_field("topographic__elevation", mg.node_x + mg.node_y, at="node")
```

### Comparing `landlab-2.7.0/tests/components/flow_router/ext/single_flow/priority_routing/test_breach_c.pyx` & `landlab-2.8.0/tests/components/flow_router/ext/single_flow/priority_routing/test_breach_c.pyx`

 * *Files 13% similar despite different names*

```diff
@@ -1,24 +1,21 @@
-#distutils: define_macros=NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION
-#distutils: extra_compile_args = -std=c++11
-#distutils: extra_link_args = -std=c++11
+# distutils: define_macros=NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION
+# distutils: extra_compile_args = -std=c++11
+# distutils: extra_link_args = -std=c++11
 
 # NB: apparently not possible to add language: C++ in this file
 # because of the extracompile -std=c++11 (necessary to understand the
 # priorityqueue template. To be compiled in C++,
 # must add a .pxd file with the instruction # distutils: language = c++
 
 import numpy as np
 
-cimport cython
 cimport numpy as cnp
 from libcpp cimport bool
 from libcpp.pair cimport pair
-from libcpp.queue cimport queue
-from libcpp.vector cimport vector
 
 from numpy.testing import assert_array_almost_equal, assert_array_equal
 
 from landlab.components.flow_router.ext.single_flow.priority_routing cimport (
     breach as breach_c,
 )
 
@@ -30,43 +27,47 @@
         _priority_queue(...) except +
         void push(pair[cnp.int_t, cnp.float_t])
         pair[cnp.int_t, cnp.float_t] top() except +
         void pop()
         bool empty()
         cnp.int_t size()
 
+
 def test_priority_queue():
     cdef:
         pair[cnp.int_t, cnp.float_t] a = pair[cnp.int_t, cnp.float_t](0, 1045.3)
         pair[cnp.int_t, cnp.float_t] b = pair[cnp.int_t, cnp.float_t](1, 536.3)
         pair[cnp.int_t, cnp.float_t] c = pair[cnp.int_t, cnp.float_t](2, 2034.12)
         _priority_queue to_do = _priority_queue(breach_c._compare_second)
 
-    assert to_do.empty() == True
-    to_do.push(a); to_do.push(b)
-    assert to_do.empty() == False
+    assert to_do.empty() is True
+    to_do.push(a)
+    to_do.push(b)
+    assert to_do.empty() is False
     assert to_do.top() == b
     to_do.push(c)
     to_do.pop()
     assert to_do.top() == a
 
+
 def test_init_flow_direction_queues():
     # on a grid of 7 nodes
     cdef:
         cnp.int_t nodes_n = 7
         cnp.int_t [:] base_level_nodes = np.array([0, 2])
         cnp.int_t [:] closed_nodes = np.array([5])
         cnp.float_t [:] z = np.array([4.5, 3.2, 6.7, 13.2, 5.6, 100.3, 45.32])
         _priority_queue to_do = _priority_queue(breach_c._compare_second)
         cnp.int_t [:] receivers = -1 * np.ones(nodes_n, dtype=int)
         cnp.int_t [:] outlet_nodes = -1 * np.ones(nodes_n, dtype=int)
         cnp.int_t [:] done = np.zeros(nodes_n, dtype=int)
         cnp.int_t done_n = 0
-    breach_c._init_flow_direction_queues(base_level_nodes, closed_nodes,
-        z, to_do, receivers, outlet_nodes, done, &done_n)
+    breach_c._init_flow_direction_queues(
+        base_level_nodes, closed_nodes, z, to_do, receivers, outlet_nodes, done, &done_n
+    )
     assert nodes_n == 7
     assert_array_equal(base_level_nodes, np.array([0, 2]))
     assert_array_equal(closed_nodes, np.array([5]))
     assert_array_almost_equal(z, np.array([4.5, 3.2, 6.7, 13.2, 5.6, 100.3, 45.32]))
     assert_array_equal(receivers, np.array([0, -1, 2, -1, -1, 5, -1]))
     assert_array_equal(done, np.array([1, 0, 1, 0, 0, 1, 0]))
     assert done_n == 3
@@ -83,346 +84,613 @@
         cnp.int_t [:] depression_outlet_nodes = np.array([-1, -1, -1, -1, -1])
         cnp.int_t [:] flooded_nodes = np.zeros(5, dtype=int)
         cnp.float_t [:] depression_depths = np.zeros(5, dtype=float)
         cnp.float_t [:] depression_free_elevations = (
             np.array([0.1, 67.1, 42.1, 70.3, 34.5])
         )
 
-    breach_c._set_flooded_and_outlet(donor_id, z, receivers, outlet_nodes,
-        depression_outlet_nodes, flooded_nodes, depression_depths,
-        depression_free_elevations, flooded_status, bad_index,
-        min_elevation_relative_diff)
+    breach_c._set_flooded_and_outlet(
+        donor_id,
+        z,
+        receivers,
+        outlet_nodes,
+        depression_outlet_nodes,
+        flooded_nodes,
+        depression_depths,
+        depression_free_elevations,
+        flooded_status,
+        bad_index,
+        min_elevation_relative_diff,
+    )
 
     assert donor_id == 2
     assert_array_almost_equal(z, np.array([0.1, 67.1, 42.1, 70.3, 34.5]))
     assert_array_equal(receivers, np.array([0, 0, 1, -1, -1]))
     assert_array_equal(outlet_nodes, np.array([0, 0, 0, -1, -1]))
     assert_array_equal(depression_outlet_nodes, np.array([-1, -1, 1, -1, -1]))
     assert_array_equal(flooded_nodes, np.array([0, 0, 3, 0, 0]))
     assert_array_almost_equal(depression_depths, np.array([0, 0, 67.1 - 42.1, 0, 0]))
-    assert_array_almost_equal(depression_free_elevations,
-            np.array([0.1, 67.1, 67.771, 70.3, 34.5]))
+    assert_array_almost_equal(
+        depression_free_elevations, np.array([0.1, 67.1, 67.771, 70.3, 34.5])
+    )
     assert flooded_status == 3
     assert bad_index == -1
 
     donor_id = 3
     receivers = np.array([0, 0, 1, 2, -1])
 
-    breach_c._set_flooded_and_outlet(donor_id, z, receivers, outlet_nodes,
-        depression_outlet_nodes, flooded_nodes, depression_depths,
-        depression_free_elevations, flooded_status, bad_index,
-        min_elevation_relative_diff)
+    breach_c._set_flooded_and_outlet(
+        donor_id,
+        z,
+        receivers,
+        outlet_nodes,
+        depression_outlet_nodes,
+        flooded_nodes,
+        depression_depths,
+        depression_free_elevations,
+        flooded_status,
+        bad_index,
+        min_elevation_relative_diff,
+    )
     assert donor_id == 3
     assert_array_almost_equal(z, np.array([0.1, 67.1, 42.1, 70.3, 34.5]))
     assert_array_equal(receivers, np.array([0, 0, 1, 2, -1]))
     assert_array_equal(outlet_nodes, np.array([0, 0, 0, 0, -1]))
     assert_array_equal(depression_outlet_nodes, np.array([-1, -1, 1, -1, -1]))
     assert_array_equal(flooded_nodes, np.array([0, 0, 3, 0, 0]))
     assert_array_almost_equal(depression_depths, np.array([0, 0, 67.1 - 42.1, 0, 0]))
-    assert_array_almost_equal(depression_free_elevations,
-            np.array([ 0.1, 67.1, 67.771, 70.3, 34.5]))
+    assert_array_almost_equal(
+        depression_free_elevations, np.array([0.1, 67.1, 67.771, 70.3, 34.5])
+    )
     assert flooded_status == 3
     assert bad_index == -1
 
+
 def test_set_receiver():
     # on a grid of 6 nodes
     cdef:
         cnp.int_t donor_id = 3, receiver_id = 4, done_n = 1
         cnp.int_t [:] receivers = np.array([0, -1, -1, -1, -1, -1])
         cnp.int_t [:] done = np.array([1, 0, 0, 0, 0, 0])
     breach_c._set_receiver(donor_id, receiver_id, receivers, done, &done_n)
     assert donor_id == 3
     assert receiver_id == 4
     assert done_n == 2
     assert_array_equal(receivers, np.array([0, -1, -1, 4, -1, -1]))
     assert_array_equal(done, np.array([1, 0, 0, 1, 0, 0]))
 
+
 def test_set_donor_properties():
     # on a grid of 9 nodes
     cdef:
         cnp.int_t donor_id = 5, receiver_id = 7
-        cnp.int_t [:] sorted_pseudo_heads = np.array([0, 0, 1, 1, 1, 2, 2, 3, 3,
-            3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 7, 8, 8])
-        cnp.int_t [:] sorted_pseudo_tails =  np.array([3, 1, 0, 4, 2, 1, 5, 0, 6,
-            4, 7, 3, 1, 5, 4, 2, 8, 7, 3, 8, 4, 6, 5, 7])
-        cnp.int_t [:,:] head_start_end_indexes = np.array([[ 0, 2, 5, 7, 10,
-            14, 17, 19, 22],
-           [ 1, 4, 6, 9, 13, 16, 18, 21, 23]])
-        cnp.int_t [:] sorted_dupli_links = np.array([ 2, 0, 0, 3, 1, 1, 4,
-            2, 7, 5, 8, 5, 3, 6, 6, 4, 9,
-           10, 7, 11, 8, 10, 9, 11])
-        cnp.float_t [:] sorted_dupli_gradients = np.array([ 0.03879335, 0.04387396,
-            0.04387396, 0.08236696, 0.12232775,
-            0.12232775, 0.02936549, 0.03879335, 0.28953386, 0.16503428,
-            0.18134194, 0.16503428, 0.08236696, 0.06932627, 0.06932627,
-            0.02936549, 0.00526324, 0.30584151, 0.28953386, 0.24540497,
-            0.18134194, 0.30584151, 0.00526324, 0.24540497])
-        cnp.float_t [:] z = np.array([ 2.29047865, 3.60669759, 7.27652998, 1.12667805,
-            6.0777065, 8.15749462, 9.81269383, 0.63744841, 7.99959748])
+        cnp.int_t [:] _sorted_pseudo_heads = np.array(
+            [
+                0, 0, 1, 1, 1, 2, 2, 3, 3,
+                3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 7, 8, 8
+            ]
+        )
+        cnp.int_t [:] sorted_pseudo_tails = np.array(
+            [
+                3, 1, 0, 4, 2, 1, 5, 0, 6,
+                4, 7, 3, 1, 5, 4, 2, 8, 7, 3, 8, 4, 6, 5, 7
+            ]
+        )
+        cnp.int_t [:, :] head_start_end_indexes = np.array(
+            [
+                [0, 2, 5, 7, 10, 14, 17, 19, 22],
+                [1, 4, 6, 9, 13, 16, 18, 21, 23]
+            ]
+        )
+        cnp.int_t [:] sorted_dupli_links = np.array(
+            [
+                2, 0, 0, 3, 1, 1, 4,
+                2, 7, 5, 8, 5, 3, 6, 6, 4, 9,
+                10, 7, 11, 8, 10, 9, 11
+            ]
+        )
+        cnp.float_t [:] sorted_dupli_gradients = np.array(
+            [
+                0.03879335, 0.04387396,
+                0.04387396, 0.08236696, 0.12232775,
+                0.12232775, 0.02936549, 0.03879335, 0.28953386, 0.16503428,
+                0.18134194, 0.16503428, 0.08236696, 0.06932627, 0.06932627,
+                0.02936549, 0.00526324, 0.30584151, 0.28953386, 0.24540497,
+                0.18134194, 0.30584151, 0.00526324, 0.24540497
+            ]
+        )
+        cnp.float_t [:] z = np.array(
+            [
+                2.29047865, 3.60669759, 7.27652998, 1.12667805,
+                6.0777065, 8.15749462, 9.81269383, 0.63744841, 7.99959748
+            ]
+        )
         cnp.float_t [:] steepest_slopes = np.zeros(9, dtype=float)
         cnp.int_t [:] links_to_receivers = -1 * np.ones(9, dtype=int)
 
-    breach_c._set_donor_properties(donor_id, receiver_id, sorted_pseudo_tails,
-        head_start_end_indexes, sorted_dupli_links, sorted_dupli_gradients, z,
-        steepest_slopes, links_to_receivers)
+    breach_c._set_donor_properties(
+        donor_id,
+        receiver_id,
+        sorted_pseudo_tails,
+        head_start_end_indexes,
+        sorted_dupli_links,
+        sorted_dupli_gradients,
+        z,
+        steepest_slopes,
+        links_to_receivers,
+    )
     assert donor_id == 5
     assert receiver_id == 7
-    assert_array_equal(sorted_pseudo_tails, np.array([3, 1, 0, 4, 2, 1, 5, 0, 6,
-        4, 7, 3, 1, 5, 4, 2, 8, 7, 3, 8, 4, 6, 5, 7]))
-    assert_array_equal(head_start_end_indexes, np.array([[ 0, 2, 5, 7, 10,
-        14, 17, 19, 22],
-        [1, 4, 6, 9, 13, 16, 18, 21, 23]]))
-    assert_array_equal(sorted_dupli_links, np.array([ 2, 0, 0, 3, 1, 1, 4,
-        2, 7, 5, 8, 5, 3, 6, 6, 4, 9,
-        10, 7, 11, 8, 10, 9, 11]))
-    assert_array_almost_equal(sorted_dupli_gradients, np.array([ 0.03879335,
-        0.04387396,
-        0.04387396, 0.08236696, 0.12232775,
-        0.12232775, 0.02936549, 0.03879335, 0.28953386, 0.16503428,
-        0.18134194, 0.16503428, 0.08236696, 0.06932627, 0.06932627,
-        0.02936549, 0.00526324, 0.30584151, 0.28953386, 0.24540497,
-        0.18134194, 0.30584151, 0.00526324, 0.24540497]))
-    assert_array_almost_equal(z, np.array([ 2.29047865, 3.60669759, 7.27652998,
-        1.12667805,
-        6.0777065, 8.15749462, 9.81269383, 0.63744841, 7.99959748]))
-    assert_array_almost_equal(steepest_slopes, np.array([ 0., 0.,
-        0., 0., 0., 0.245405,
-        0., 0., 0.]))
-    assert_array_equal(links_to_receivers, np.array([-1, -1, -1, -1, -1, 11, -1, -1, -1]))
+    assert_array_equal(
+        sorted_pseudo_tails,
+        np.array(
+            [
+                3, 1, 0, 4, 2, 1, 5, 0, 6,
+                4, 7, 3, 1, 5, 4, 2, 8, 7, 3, 8, 4, 6, 5, 7
+            ]
+        )
+    )
+    assert_array_equal(
+        head_start_end_indexes,
+        np.array(
+            [
+                [0, 2, 5, 7, 10, 14, 17, 19, 22],
+                [1, 4, 6, 9, 13, 16, 18, 21, 23]
+            ]
+        )
+    )
+    assert_array_equal(
+        sorted_dupli_links,
+        np.array(
+            [
+                2, 0, 0, 3, 1, 1, 4,
+                2, 7, 5, 8, 5, 3, 6, 6, 4, 9,
+                10, 7, 11, 8, 10, 9, 11
+            ]
+        )
+    )
+    assert_array_almost_equal(
+        sorted_dupli_gradients,
+        np.array(
+            [
+                0.03879335,
+                0.04387396,
+                0.04387396, 0.08236696, 0.12232775,
+                0.12232775, 0.02936549, 0.03879335, 0.28953386, 0.16503428,
+                0.18134194, 0.16503428, 0.08236696, 0.06932627, 0.06932627,
+                0.02936549, 0.00526324, 0.30584151, 0.28953386, 0.24540497,
+                0.18134194, 0.30584151, 0.00526324, 0.24540497
+            ]
+        )
+    )
+    assert_array_almost_equal(
+        z,
+        np.array(
+            [
+                2.29047865, 3.60669759, 7.27652998, 1.12667805,
+                6.0777065, 8.15749462, 9.81269383, 0.63744841, 7.99959748
+            ]
+        )
+    )
+    assert_array_almost_equal(
+        steepest_slopes,
+        np.array(
+            [
+                0., 0.,
+                0., 0., 0., 0.245405,
+                0., 0., 0.
+            ]
+        )
+    )
+    assert_array_equal(
+        links_to_receivers, np.array([-1, -1, -1, -1, -1, 11, -1, -1, -1])
+    )
 
 #######################################################################################
 
+
 def test_direct_flow_c():
     # Grid of 25 nodes
     cdef:
         cnp.int_t nodes_n = 25, flooded_status = 3, bad_index = -1
         cnp.float_t min_elevation_relative_diff = 1e-2
         cnp.int_t neighbors_max_number = 50
-        cnp.int_t[:] base_level_nodes = np.array([0, 1, 2, 4,
-            5, 9, 10, 14, 15, 19, 20, 21, 22, 23, 24])
+        cnp.int_t[:] base_level_nodes = np.array(
+            [0, 1, 2, 4, 5, 9, 10, 14, 15, 19, 20, 21, 22, 23, 24]
+        )
         cnp.int_t[:] base_level_nodes_0 = np.copy(base_level_nodes)
         cnp.int_t[:] closed_nodes = np.array([3])
         cnp.int_t[:] closed_nodes_0 = np.copy(closed_nodes)
-        cnp.int_t[:] sorted_pseudo_heads = np.array([0, 0, 1, 1, 1,
-            2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6,
-            6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10,
-           11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
-           15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20,
-           20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24]) # unused, for info
-        cnp.int_t[:] sorted_pseudo_tails = np.array([5, 1, 6, 2, 0, 3,
-            7, 1, 8, 2, 4, 9, 3, 6, 10, 0, 7,
-           11, 1, 5, 12, 8, 6, 2, 7, 9, 3, 13, 8, 4, 14, 15, 11, 5,
-           16, 6, 12, 10, 13, 17, 7, 11, 14, 18, 8, 12, 19, 9, 13, 16, 20,
-           10, 21, 15, 17, 11, 12, 22, 16, 18, 19, 23, 17, 13, 24, 18, 14, 21,
-           15, 20, 22, 16, 17, 23, 21, 24, 18, 22, 19, 23])
+        cnp.int_t[:] _sorted_pseudo_heads = np.array(
+            [
+                0, 0, 1, 1, 1,
+                2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6,
+                6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10,
+                11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
+                15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20,
+                20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24
+            ]
+        )  # unused, for info
+        cnp.int_t[:] sorted_pseudo_tails = np.array(
+            [
+                5, 1, 6, 2, 0, 3,
+                7, 1, 8, 2, 4, 9, 3, 6, 10, 0, 7,
+                11, 1, 5, 12, 8, 6, 2, 7, 9, 3, 13, 8, 4, 14, 15, 11, 5,
+                16, 6, 12, 10, 13, 17, 7, 11, 14, 18, 8, 12, 19, 9, 13, 16, 20,
+                10, 21, 15, 17, 11, 12, 22, 16, 18, 19, 23, 17, 13, 24, 18, 14, 21,
+                15, 20, 22, 16, 17, 23, 21, 24, 18, 22, 19, 23
+            ]
+        )
         cnp.int_t[:] sorted_pseudo_tails_0 = np.copy(sorted_pseudo_tails)
-        cnp.float_t[:] sorted_dupli_gradients = np.array([0.1955672,
-            0.04387396, 0.20686654, 0.12232775, 0.04387396,
-            0.20499506, 0.22130272, 0.12232775, 0.22909731, 0.20499506,
-            0.16503428, 0.17027403, 0.16503428, 0.05517331, 0.1382939,
-            0.1955672,  0.30584151, 0.10637057, 0.20686654, 0.05517331,
-            0.30061369, 0.24540497, 0.30584151, 0.22130272, 0.24540497,
-            0.23433706, 0.22909731, 0.10635323, 0.23433706, 0.17027403,
-            0.05572124, 0.06218312, 0.08709664, 0.1382939,  0.20119303,
-            0.10637057, 0.10114275, 0.08709664, 0.16156195, 0.12329631,
-            0.30061369, 0.10114275, 0.07226259, 0.01279225, 0.10635323,
-            0.16156195, 0.08976513, 0.05572124, 0.07226259, 0.17627952,
-            0.00161023, 0.06218312, 0.1169648,  0.17627952, 0.17903947,
-            0.20119303, 0.12329631, 0.0359346,  0.17903947, 0.05105789,
-            0.0302948,  0.13452944, 0.05105789, 0.01279225, 0.14332401,
-            0.0302948,  0.08976513, 0.06092495, 0.00161023, 0.06092495,
-            0.09800927, 0.1169648,  0.0359346,  0.22152193, 0.09800927,
-            0.02150023, 0.13452944, 0.22152193, 0.14332401, 0.02150023])
+        cnp.float_t[:] sorted_dupli_gradients = np.array(
+            [
+                0.1955672,
+                0.04387396, 0.20686654, 0.12232775, 0.04387396,
+                0.20499506, 0.22130272, 0.12232775, 0.22909731, 0.20499506,
+                0.16503428, 0.17027403, 0.16503428, 0.05517331, 0.1382939,
+                0.1955672,  0.30584151, 0.10637057, 0.20686654, 0.05517331,
+                0.30061369, 0.24540497, 0.30584151, 0.22130272, 0.24540497,
+                0.23433706, 0.22909731, 0.10635323, 0.23433706, 0.17027403,
+                0.05572124, 0.06218312, 0.08709664, 0.1382939,  0.20119303,
+                0.10637057, 0.10114275, 0.08709664, 0.16156195, 0.12329631,
+                0.30061369, 0.10114275, 0.07226259, 0.01279225, 0.10635323,
+                0.16156195, 0.08976513, 0.05572124, 0.07226259, 0.17627952,
+                0.00161023, 0.06218312, 0.1169648,  0.17627952, 0.17903947,
+                0.20119303, 0.12329631, 0.0359346,  0.17903947, 0.05105789,
+                0.0302948,  0.13452944, 0.05105789, 0.01279225, 0.14332401,
+                0.0302948,  0.08976513, 0.06092495, 0.00161023, 0.06092495,
+                0.09800927, 0.1169648,  0.0359346,  0.22152193, 0.09800927,
+                0.02150023, 0.13452944, 0.22152193, 0.14332401, 0.02150023
+            ]
+        )
         cnp.float_t[:] sorted_dupli_gradients_0 = np.copy(sorted_dupli_gradients)
-        cnp.int_t[:] sorted_dupli_links = np.array([4, 0, 5, 1, 0,
-            2, 6, 1, 7, 2, 3, 8, 3, 9, 13, 4, 10,
-           14, 5, 9, 15, 11, 10, 6, 11, 12, 7, 16, 12, 8, 17, 22, 18, 13,
-           23, 14, 19, 18, 20, 24, 15, 19, 21, 25, 16, 20, 26, 17, 21, 27, 31,
-           22, 32, 27, 28, 23, 24, 33, 28, 29, 30, 34, 29, 25, 35, 30, 26, 36,
-           31, 36, 37, 32, 33, 38, 37, 39, 34, 38, 35, 39])
+        cnp.int_t[:] sorted_dupli_links = np.array(
+            [
+                4, 0, 5, 1, 0,
+                2, 6, 1, 7, 2, 3, 8, 3, 9, 13, 4, 10,
+                14, 5, 9, 15, 11, 10, 6, 11, 12, 7, 16, 12, 8, 17, 22, 18, 13,
+                23, 14, 19, 18, 20, 24, 15, 19, 21, 25, 16, 20, 26, 17, 21, 27, 31,
+                22, 32, 27, 28, 23, 24, 33, 28, 29, 30, 34, 29, 25, 35, 30, 26, 36,
+                31, 36, 37, 32, 33, 38, 37, 39, 34, 38, 35, 39
+            ]
+        )
         cnp.int_t[:] sorted_dupli_links_0 = np.copy(sorted_dupli_links)
-        cnp.int_t[:, :] head_start_end_indexes = np.array([[0, 2, 5,
-            8, 11, 13, 16, 20, 24, 28, 31, 34, 38, 42, 46, 49, 52,
-            56, 60, 64, 67, 69, 72, 75, 78],
-            [1, 4, 7, 10, 12, 15, 19, 23, 27, 30, 33, 37, 41, 45, 48, 51,
-             55, 59, 63, 66, 68, 71, 74, 77, 79]])
+        cnp.int_t[:, :] head_start_end_indexes = np.array(
+            [
+                [
+                    0, 2, 5,
+                    8, 11, 13, 16, 20, 24, 28, 31, 34, 38, 42, 46, 49, 52,
+                    56, 60, 64, 67, 69, 72, 75, 78
+                ],
+                [
+                    1, 4, 7, 10, 12, 15, 19, 23, 27, 30, 33, 37, 41, 45, 48, 51,
+                    55, 59, 63, 66, 68, 71, 74, 77, 79
+                ]
+            ]
+        )
         cnp.int_t[:, :] head_start_end_indexes_0 = np.copy(head_start_end_indexes)
         cnp.float_t[:] depression_depths = np.zeros(25, dtype=float)
         cnp.int_t[:] outlet_nodes = -1 * np.ones(25, dtype=int)
         cnp.int_t[:] depression_outlet_nodes = -1 * np.ones(25, dtype=int)
         cnp.int_t[:] flooded_nodes = np.zeros(25, dtype=int)
         cnp.int_t[:] links_to_receivers = -1 * np.ones(25, dtype=int)
         cnp.int_t[:] receivers = -1 * np.ones(25, dtype=int)
         cnp.float_t[:] steepest_slopes = np.zeros(25, dtype=float)
-        cnp.float_t[:] z = np.array([2.29047865, 3.60669759, 7.27652998,
-            1.12667805, 6.0777065,
-            8.15749462, 9.81269383, 0.63744841, 7.99959748, 0.96948555,
-            4.00867748, 6.62157669, 9.65585909, 4.80900059, 2.64112287,
-            5.8741712,  0.5857857,  5.95696968, 4.42523296, 5.33407687,
-            5.92247815, 4.09472964, 7.03500768, 0.38934984, 1.03435662])
+        cnp.float_t[:] z = np.array(
+            [
+                2.29047865, 3.60669759, 7.27652998,
+                1.12667805, 6.0777065,
+                8.15749462, 9.81269383, 0.63744841, 7.99959748, 0.96948555,
+                4.00867748, 6.62157669, 9.65585909, 4.80900059, 2.64112287,
+                5.8741712,  0.5857857,  5.95696968, 4.42523296, 5.33407687,
+                5.92247815, 4.09472964, 7.03500768, 0.38934984, 1.03435662
+            ]
+        )
         cnp.float_t[:] depression_free_elevations = z.copy()
         cnp.float_t[:] z_0 = np.copy(z)
 
-    breach_c._direct_flow_c(nodes_n, base_level_nodes, closed_nodes,
-                    sorted_pseudo_tails, sorted_dupli_gradients,
-                    sorted_dupli_links, head_start_end_indexes,
-                    outlet_nodes, depression_outlet_nodes,
-                    flooded_nodes, depression_depths, depression_free_elevations,
-                    links_to_receivers, receivers, steepest_slopes, z,
-                    flooded_status, bad_index, neighbors_max_number,
-                    min_elevation_relative_diff)
+    breach_c._direct_flow_c(
+        nodes_n,
+        base_level_nodes,
+        closed_nodes,
+        sorted_pseudo_tails,
+        sorted_dupli_gradients,
+        sorted_dupli_links,
+        head_start_end_indexes,
+        outlet_nodes,
+        depression_outlet_nodes,
+        flooded_nodes,
+        depression_depths,
+        depression_free_elevations,
+        links_to_receivers,
+        receivers,
+        steepest_slopes,
+        z,
+        flooded_status,
+        bad_index,
+        neighbors_max_number,
+        min_elevation_relative_diff,
+    )
     assert nodes_n == 25
     assert flooded_status == 3
     assert bad_index == -1
     assert neighbors_max_number == 50
     assert_array_equal(base_level_nodes, base_level_nodes_0)
     assert_array_equal(closed_nodes, closed_nodes_0)
     assert_array_equal(sorted_pseudo_tails, sorted_pseudo_tails_0)
     assert_array_almost_equal(sorted_dupli_gradients, sorted_dupli_gradients_0)
     assert_array_equal(sorted_dupli_links, sorted_dupli_links_0)
     assert_array_equal(head_start_end_indexes, head_start_end_indexes_0)
-    assert_array_almost_equal(depression_depths,
-        np.array([0., 0., 0., 0., 0.,
-            0., 0., 6.63908157, 0., 0.,
-            0., 0., 0., 0., 0.,
-            0., 3.50894394, 0., 0., 0.,
-            0., 0., 0., 0., 0.]))
-    assert_array_equal(outlet_nodes,
-        np.array([0, 1, 2, 3, 4, 5, 1, 2, 9, 9, 10, 10, 14,
-                  14, 14, 15, 21, 21, 23, 19, 20, 21, 22, 23, 24]))
-    assert_array_equal(depression_outlet_nodes,
-        np.array([-1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1,
-            -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1]))
-    assert_array_equal(flooded_nodes,
-        np.array([0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3,
-            0, 0, 0, 0, 0, 0, 0, 0]))
-    assert_array_equal(links_to_receivers,
-        np.array([-1, -1, -1, -1, -1, -1, 5, 6, 12, -1, -1, 18, 20,
-            21, -1, -1, 32, 28, 34, -1, -1, -1, -1, -1, -1]))
-    assert_array_equal(receivers,
-        np.array([0, 1, 2, 3, 4, 5, 1, 2, 9, 9, 10, 10,
-            13, 14, 14, 15, 21, 16, 23, 19, 20, 21, 22, 23, 24]))
-    assert_array_almost_equal(steepest_slopes,
-        np.array([0., 0., 0., 0., 0.,
-        0., 0.20686654, 0., 0.23433706, 0.,
-        0., 0.08709664, 0.16156195, 0.07226259, 0.,
-        0., 0., 0.17903947, 0.13452944, 0.,
-        0., 0., 0., 0., 0.]))
+    assert_array_almost_equal(
+        depression_depths,
+        np.array(
+            [
+                0., 0., 0., 0., 0.,
+                0., 0., 6.63908157, 0., 0.,
+                0., 0., 0., 0., 0.,
+                0., 3.50894394, 0., 0., 0.,
+                0., 0., 0., 0., 0.
+            ]
+        )
+    )
+    assert_array_equal(
+        outlet_nodes,
+        np.array(
+            [
+                0, 1, 2, 3, 4, 5, 1, 2, 9, 9, 10, 10, 14,
+                14, 14, 15, 21, 21, 23, 19, 20, 21, 22, 23, 24
+            ]
+        )
+    )
+    assert_array_equal(
+        depression_outlet_nodes,
+        np.array(
+            [
+                -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1,
+                -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1
+            ]
+        )
+    )
+    assert_array_equal(
+        flooded_nodes,
+        np.array(
+            [
+                0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3,
+                0, 0, 0, 0, 0, 0, 0, 0
+            ]
+        )
+    )
+    assert_array_equal(
+        links_to_receivers,
+        np.array(
+            [
+                -1, -1, -1, -1, -1, -1, 5, 6, 12, -1, -1, 18, 20,
+                21, -1, -1, 32, 28, 34, -1, -1, -1, -1, -1, -1
+            ]
+        )
+    )
+    assert_array_equal(
+        receivers,
+        np.array(
+            [
+                0, 1, 2, 3, 4, 5, 1, 2, 9, 9, 10, 10,
+                13, 14, 14, 15, 21, 16, 23, 19, 20, 21, 22, 23, 24
+            ]
+        )
+    )
+    assert_array_almost_equal(
+        steepest_slopes,
+        np.array(
+            [
+                0., 0., 0., 0., 0.,
+                0., 0.20686654, 0., 0.23433706, 0.,
+                0., 0.08709664, 0.16156195, 0.07226259, 0.,
+                0., 0., 0.17903947, 0.13452944, 0.,
+                0., 0., 0., 0., 0.
+            ]
+        )
+    )
     assert_array_almost_equal(z, z_0)
 
+
 def test_direct_flow():
     # Grid of 25 nodes
     cdef:
         cnp.int_t nodes_n = 25, flooded_status = 3, bad_index = -1
         cnp.int_t neighbors_max_number = 50
         cnp.float_t min_elevation_relative_diff = 1e-2
-        cnp.int_t[:] base_level_nodes = np.array([0, 1, 2, 4,
-            5, 9, 10, 14, 15, 19, 20, 21, 22, 23, 24])
+        cnp.int_t[:] base_level_nodes = np.array(
+            [0, 1, 2, 4, 5, 9, 10, 14, 15, 19, 20, 21, 22, 23, 24]
+        )
         cnp.int_t[:] base_level_nodes_0 = np.copy(base_level_nodes)
         cnp.int_t[:] closed_nodes = np.array([3])
         cnp.int_t[:] closed_nodes_0 = np.copy(closed_nodes)
-        cnp.int_t[:] sorted_pseudo_heads = np.array([0, 0, 1, 1, 1,
-            2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6,
-            6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10,
-           11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
-           15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20,
-           20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24]) # unused, for info
-        cnp.int_t[:] sorted_pseudo_tails = np.array([5, 1, 6, 2, 0, 3,
-            7, 1, 8, 2, 4, 9, 3, 6, 10, 0, 7,
-           11, 1, 5, 12, 8, 6, 2, 7, 9, 3, 13, 8, 4, 14, 15, 11, 5,
-           16, 6, 12, 10, 13, 17, 7, 11, 14, 18, 8, 12, 19, 9, 13, 16, 20,
-           10, 21, 15, 17, 11, 12, 22, 16, 18, 19, 23, 17, 13, 24, 18, 14, 21,
-           15, 20, 22, 16, 17, 23, 21, 24, 18, 22, 19, 23])
+        cnp.int_t[:] _sorted_pseudo_heads = np.array(
+            [
+                0, 0, 1, 1, 1,
+                2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6,
+                6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10,
+                11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
+                15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20,
+                20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24
+            ]
+        )  # unused, for info
+        cnp.int_t[:] sorted_pseudo_tails = np.array(
+            [
+                5, 1, 6, 2, 0, 3,
+                7, 1, 8, 2, 4, 9, 3, 6, 10, 0, 7,
+                11, 1, 5, 12, 8, 6, 2, 7, 9, 3, 13, 8, 4, 14, 15, 11, 5,
+                16, 6, 12, 10, 13, 17, 7, 11, 14, 18, 8, 12, 19, 9, 13, 16, 20,
+                10, 21, 15, 17, 11, 12, 22, 16, 18, 19, 23, 17, 13, 24, 18, 14, 21,
+                15, 20, 22, 16, 17, 23, 21, 24, 18, 22, 19, 23
+            ]
+        )
         cnp.int_t[:] sorted_pseudo_tails_0 = np.copy(sorted_pseudo_tails)
-        cnp.float_t[:] sorted_dupli_gradients = np.array([0.1955672,
-            0.04387396, 0.20686654, 0.12232775, 0.04387396,
-            0.20499506, 0.22130272, 0.12232775, 0.22909731, 0.20499506,
-            0.16503428, 0.17027403, 0.16503428, 0.05517331, 0.1382939,
-            0.1955672,  0.30584151, 0.10637057, 0.20686654, 0.05517331,
-            0.30061369, 0.24540497, 0.30584151, 0.22130272, 0.24540497,
-            0.23433706, 0.22909731, 0.10635323, 0.23433706, 0.17027403,
-            0.05572124, 0.06218312, 0.08709664, 0.1382939,  0.20119303,
-            0.10637057, 0.10114275, 0.08709664, 0.16156195, 0.12329631,
-            0.30061369, 0.10114275, 0.07226259, 0.01279225, 0.10635323,
-            0.16156195, 0.08976513, 0.05572124, 0.07226259, 0.17627952,
-            0.00161023, 0.06218312, 0.1169648,  0.17627952, 0.17903947,
-            0.20119303, 0.12329631, 0.0359346,  0.17903947, 0.05105789,
-            0.0302948,  0.13452944, 0.05105789, 0.01279225, 0.14332401,
-            0.0302948,  0.08976513, 0.06092495, 0.00161023, 0.06092495,
-            0.09800927, 0.1169648,  0.0359346,  0.22152193, 0.09800927,
-            0.02150023, 0.13452944, 0.22152193, 0.14332401, 0.02150023])
+        cnp.float_t[:] sorted_dupli_gradients = np.array(
+            [
+                0.1955672,
+                0.04387396, 0.20686654, 0.12232775, 0.04387396,
+                0.20499506, 0.22130272, 0.12232775, 0.22909731, 0.20499506,
+                0.16503428, 0.17027403, 0.16503428, 0.05517331, 0.1382939,
+                0.1955672,  0.30584151, 0.10637057, 0.20686654, 0.05517331,
+                0.30061369, 0.24540497, 0.30584151, 0.22130272, 0.24540497,
+                0.23433706, 0.22909731, 0.10635323, 0.23433706, 0.17027403,
+                0.05572124, 0.06218312, 0.08709664, 0.1382939,  0.20119303,
+                0.10637057, 0.10114275, 0.08709664, 0.16156195, 0.12329631,
+                0.30061369, 0.10114275, 0.07226259, 0.01279225, 0.10635323,
+                0.16156195, 0.08976513, 0.05572124, 0.07226259, 0.17627952,
+                0.00161023, 0.06218312, 0.1169648,  0.17627952, 0.17903947,
+                0.20119303, 0.12329631, 0.0359346,  0.17903947, 0.05105789,
+                0.0302948,  0.13452944, 0.05105789, 0.01279225, 0.14332401,
+                0.0302948,  0.08976513, 0.06092495, 0.00161023, 0.06092495,
+                0.09800927, 0.1169648,  0.0359346,  0.22152193, 0.09800927,
+                0.02150023, 0.13452944, 0.22152193, 0.14332401, 0.02150023
+            ]
+        )
         cnp.float_t[:] sorted_dupli_gradients_0 = np.copy(sorted_dupli_gradients)
-        cnp.int_t[:] sorted_dupli_links = np.array([4, 0, 5, 1, 0,
-            2, 6, 1, 7, 2, 3, 8, 3, 9, 13, 4, 10,
-           14, 5, 9, 15, 11, 10, 6, 11, 12, 7, 16, 12, 8, 17, 22, 18, 13,
-           23, 14, 19, 18, 20, 24, 15, 19, 21, 25, 16, 20, 26, 17, 21, 27, 31,
-           22, 32, 27, 28, 23, 24, 33, 28, 29, 30, 34, 29, 25, 35, 30, 26, 36,
-           31, 36, 37, 32, 33, 38, 37, 39, 34, 38, 35, 39])
+        cnp.int_t[:] sorted_dupli_links = np.array(
+            [
+                4, 0, 5, 1, 0,
+                2, 6, 1, 7, 2, 3, 8, 3, 9, 13, 4, 10,
+                14, 5, 9, 15, 11, 10, 6, 11, 12, 7, 16, 12, 8, 17, 22, 18, 13,
+                23, 14, 19, 18, 20, 24, 15, 19, 21, 25, 16, 20, 26, 17, 21, 27, 31,
+                22, 32, 27, 28, 23, 24, 33, 28, 29, 30, 34, 29, 25, 35, 30, 26, 36,
+                31, 36, 37, 32, 33, 38, 37, 39, 34, 38, 35, 39
+            ]
+        )
         cnp.int_t[:] sorted_dupli_links_0 = np.copy(sorted_dupli_links)
-        cnp.int_t[:, :] head_start_end_indexes = np.array([[0, 2, 5,
-            8, 11, 13, 16, 20, 24, 28, 31, 34, 38, 42, 46, 49, 52,
-            56, 60, 64, 67, 69, 72, 75, 78],
-            [1, 4, 7, 10, 12, 15, 19, 23, 27, 30, 33, 37, 41, 45, 48, 51,
-             55, 59, 63, 66, 68, 71, 74, 77, 79]])
+        cnp.int_t[:, :] head_start_end_indexes = np.array(
+            [
+                [
+                    0, 2, 5,
+                    8, 11, 13, 16, 20, 24, 28, 31, 34, 38, 42, 46, 49, 52,
+                    56, 60, 64, 67, 69, 72, 75, 78
+                ],
+                [
+                    1, 4, 7, 10, 12, 15, 19, 23, 27, 30, 33, 37, 41, 45, 48, 51,
+                    55, 59, 63, 66, 68, 71, 74, 77, 79
+                ]
+            ]
+        )
         cnp.int_t[:, :] head_start_end_indexes_0 = np.copy(head_start_end_indexes)
         cnp.float_t[:] depression_depths = np.zeros(25, dtype=float)
         cnp.int_t[:] outlet_nodes = -1 * np.ones(25, dtype=int)
         cnp.int_t[:] depression_outlet_nodes = -1 * np.ones(25, dtype=int)
         cnp.int_t[:] flooded_nodes = np.zeros(25, dtype=int)
         cnp.int_t[:] links_to_receivers = -1 * np.ones(25, dtype=int)
         cnp.int_t[:] receivers = -1 * np.ones(25, dtype=int)
         cnp.float_t[:] steepest_slopes = np.zeros(25, dtype=float)
-        cnp.float_t[:] z = np.array([2.29047865, 3.60669759, 7.27652998,
-            1.12667805, 6.0777065,
-            8.15749462, 9.81269383, 0.63744841, 7.99959748, 0.96948555,
-            4.00867748, 6.62157669, 9.65585909, 4.80900059, 2.64112287,
-            5.8741712,  0.5857857,  5.95696968, 4.42523296, 5.33407687,
-            5.92247815, 4.09472964, 7.03500768, 0.38934984, 1.03435662])
+        cnp.float_t[:] z = np.array(
+            [
+                2.29047865, 3.60669759, 7.27652998,
+                1.12667805, 6.0777065,
+                8.15749462, 9.81269383, 0.63744841, 7.99959748, 0.96948555,
+                4.00867748, 6.62157669, 9.65585909, 4.80900059, 2.64112287,
+                5.8741712,  0.5857857,  5.95696968, 4.42523296, 5.33407687,
+                5.92247815, 4.09472964, 7.03500768, 0.38934984, 1.03435662
+            ]
+        )
         cnp.float_t[:] depression_free_elevations = z.copy()
         cnp.float_t[:] z_0 = np.copy(z)
 
-    breach._direct_flow(nodes_n, base_level_nodes, closed_nodes,
-                    sorted_pseudo_tails, sorted_dupli_gradients,
-                    sorted_dupli_links, head_start_end_indexes,
-                    outlet_nodes, depression_outlet_nodes,
-                    flooded_nodes, depression_depths, depression_free_elevations,
-                    links_to_receivers, receivers, steepest_slopes, z,
-                    flooded_status, bad_index, neighbors_max_number,
-                    min_elevation_relative_diff)
+    breach._direct_flow(
+        nodes_n,
+        base_level_nodes,
+        closed_nodes,
+        sorted_pseudo_tails,
+        sorted_dupli_gradients,
+        sorted_dupli_links,
+        head_start_end_indexes,
+        outlet_nodes,
+        depression_outlet_nodes,
+        flooded_nodes,
+        depression_depths,
+        depression_free_elevations,
+        links_to_receivers,
+        receivers,
+        steepest_slopes,
+        z,
+        flooded_status,
+        bad_index,
+        neighbors_max_number,
+        min_elevation_relative_diff,
+    )
     assert nodes_n == 25
     assert flooded_status == 3
     assert bad_index == -1
     assert neighbors_max_number == 50
     assert_array_equal(base_level_nodes, base_level_nodes_0)
     assert_array_equal(closed_nodes, closed_nodes_0)
     assert_array_equal(sorted_pseudo_tails, sorted_pseudo_tails_0)
     assert_array_almost_equal(sorted_dupli_gradients, sorted_dupli_gradients_0)
     assert_array_equal(sorted_dupli_links, sorted_dupli_links_0)
     assert_array_equal(head_start_end_indexes, head_start_end_indexes_0)
-    assert_array_almost_equal(depression_depths,
-        np.array([0., 0., 0., 0., 0.,
-            0., 0., 6.63908157, 0., 0.,
-            0., 0., 0., 0., 0.,
-            0., 3.50894394, 0., 0., 0.,
-            0., 0., 0., 0., 0.]))
-    assert_array_equal(outlet_nodes,
-        np.array([0, 1, 2, 3, 4, 5, 1, 2, 9, 9, 10, 10, 14,
-                  14, 14, 15, 21, 21, 23, 19, 20, 21, 22, 23, 24]))
-    assert_array_equal(depression_outlet_nodes,
-        np.array([-1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1,
-            -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1]))
-    assert_array_equal(flooded_nodes,
-        np.array([0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3,
-            0, 0, 0, 0, 0, 0, 0, 0]))
-    assert_array_equal(links_to_receivers,
-        np.array([-1, -1, -1, -1, -1, -1, 5, 6, 12, -1, -1, 18, 20,
-            21, -1, -1, 32, 28, 34, -1, -1, -1, -1, -1, -1]))
-    assert_array_equal(receivers,
-        np.array([0, 1, 2, 3, 4, 5, 1, 2, 9, 9, 10, 10,
-            13, 14, 14, 15, 21, 16, 23, 19, 20, 21, 22, 23, 24]))
-    assert_array_almost_equal(steepest_slopes,
-        np.array([0., 0., 0., 0., 0.,
-        0., 0.20686654, 0., 0.23433706, 0.,
-        0., 0.08709664, 0.16156195, 0.07226259, 0.,
-        0., 0., 0.17903947, 0.13452944, 0.,
-        0., 0., 0., 0., 0.]))
+    assert_array_almost_equal(
+        depression_depths,
+        np.array(
+            [
+                0., 0., 0., 0., 0.,
+                0., 0., 6.63908157, 0., 0.,
+                0., 0., 0., 0., 0.,
+                0., 3.50894394, 0., 0., 0.,
+                0., 0., 0., 0., 0.
+            ]
+        )
+    )
+    assert_array_equal(
+        outlet_nodes,
+        np.array(
+            [
+                0, 1, 2, 3, 4, 5, 1, 2, 9, 9, 10, 10, 14,
+                14, 14, 15, 21, 21, 23, 19, 20, 21, 22, 23, 24
+            ]
+        )
+    )
+    assert_array_equal(
+        depression_outlet_nodes,
+        np.array(
+            [
+                -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1,
+                -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1
+            ]
+        )
+    )
+    assert_array_equal(
+        flooded_nodes,
+        np.array(
+            [
+                0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3,
+                0, 0, 0, 0, 0, 0, 0, 0
+            ]
+        )
+    )
+    assert_array_equal(
+        links_to_receivers,
+        np.array(
+            [
+                -1, -1, -1, -1, -1, -1, 5, 6, 12, -1, -1, 18, 20,
+                21, -1, -1, 32, 28, 34, -1, -1, -1, -1, -1, -1
+            ]
+        )
+    )
+    assert_array_equal(
+        receivers,
+        np.array(
+            [
+                0, 1, 2, 3, 4, 5, 1, 2, 9, 9, 10, 10,
+                13, 14, 14, 15, 21, 16, 23, 19, 20, 21, 22, 23, 24
+            ]
+        )
+    )
+    assert_array_almost_equal(
+        steepest_slopes,
+        np.array(
+            [
+                0., 0., 0., 0., 0.,
+                0., 0.20686654, 0., 0.23433706, 0.,
+                0., 0.08709664, 0.16156195, 0.07226259, 0.,
+                0., 0., 0.17903947, 0.13452944, 0.,
+                0., 0., 0., 0., 0.
+            ]
+        )
+    )
     assert_array_almost_equal(z, z_0)
```

### Comparing `landlab-2.7.0/tests/components/fracture_grid/test_fracture_grid.py` & `landlab-2.8.0/tests/components/fracture_grid/test_fracture_grid.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/gravel_bedrock_eroder/test_gravel_bedrock_eroder.py` & `landlab-2.8.0/tests/components/gravel_bedrock_eroder/test_gravel_bedrock_eroder.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,15 +2,16 @@
 """
 Unit tests for landlab.components.gravel_bedrock_eroder.gravel_bedrock_eroder
 """
 import numpy as np
 from numpy.testing import assert_almost_equal
 
 from landlab import HexModelGrid
-from landlab.components import FlowAccumulator, GravelBedrockEroder
+from landlab.components import FlowAccumulator
+from landlab.components import GravelBedrockEroder
 
 
 def test_transport_rate():
     grid = HexModelGrid((4, 2), spacing=1000.0)
     grid.status_at_node[grid.perimeter_nodes] = grid.BC_NODE_IS_CLOSED
     grid.status_at_node[0] = grid.BC_NODE_IS_FIXED_VALUE
```

### Comparing `landlab-2.7.0/tests/components/gravel_river_transporter/test_gravel_river_transporter.py` & `landlab-2.8.0/tests/components/gravel_river_transporter/test_gravel_river_transporter.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,20 @@
 #! /usr/bin/env python
 """
 Unit tests for landlab.components.gravel_river_transporter.gravel_river_transporter
 """
-from numpy.testing import assert_allclose, assert_equal, assert_raises
+from numpy.testing import assert_allclose
+from numpy.testing import assert_equal
+from numpy.testing import assert_raises
 
-from landlab import HexModelGrid, RadialModelGrid, RasterModelGrid
-from landlab.components import FlowAccumulator, GravelRiverTransporter
+from landlab import HexModelGrid
+from landlab import RadialModelGrid
+from landlab import RasterModelGrid
+from landlab.components import FlowAccumulator
+from landlab.components import GravelRiverTransporter
 
 
 def test_analytical_solution_one_cell_basic_solver():
     # parameters
     dx = 1000.0  # node spacing, m
     uplift_rate = 0.0001  # rate of relative uplift, m/y
     bankfull_runoff_rate = 10.0  # bankfull runoff rate, m/y
```

### Comparing `landlab-2.7.0/tests/components/groundwater/test_dupuit_percolator.py` & `landlab-2.8.0/tests/components/groundwater/test_dupuit_percolator.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,18 +2,21 @@
 """
 Created on Tue Jun  4 16:26:31 2019
 
 @author: G Tucker, D Litwin
 """
 
 import numpy as np
-from numpy.testing import assert_almost_equal, assert_equal
+from numpy.testing import assert_almost_equal
+from numpy.testing import assert_equal
 
-from landlab import HexModelGrid, RasterModelGrid
-from landlab.components import FlowAccumulator, GroundwaterDupuitPercolator
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
+from landlab.components import FlowAccumulator
+from landlab.components import GroundwaterDupuitPercolator
 from landlab.grid.mappers import map_mean_of_link_nodes_to_link
 
 
 def test_simple_water_table():
     """Test a one-node steady simulation.
 
     Notes
```

### Comparing `landlab-2.7.0/tests/components/hack_calculator/test_hack.py` & `landlab-2.8.0/tests/components/hack_calculator/test_hack.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import pytest
 
 from landlab import RasterModelGrid
-from landlab.components import FlowAccumulator, HackCalculator
+from landlab.components import FlowAccumulator
+from landlab.components import HackCalculator
 
 
 @pytest.fixture()
 def simple_hack_test_grid():
     mg = RasterModelGrid((10, 10))
     z = mg.add_zeros("topographic__elevation", at="node")
     z += mg.x_of_node + mg.y_of_node
```

### Comparing `landlab-2.7.0/tests/components/lake_fill/test_lake_fill.py` & `landlab-2.8.0/tests/components/lake_fill/test_lake_fill.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 #!/usr/env/python
 
 from collections import deque
 
 import numpy as np
 import pytest
 
-from landlab import FieldError, HexModelGrid, RasterModelGrid
-from landlab.components import (
-    FlowAccumulator,
-    FlowDirectorDINF,
-    FlowDirectorSteepest,
-    LakeMapperBarnes,
-)
+from landlab import FieldError
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
+from landlab.components import FlowAccumulator
+from landlab.components import FlowDirectorDINF
+from landlab.components import FlowDirectorSteepest
+from landlab.components import LakeMapperBarnes
 from landlab.utils import StablePriorityQueue
 
 """
 These tests test specific aspects of LakeMapperBarnes not picked up in the
 various docstrings.
 """
```

### Comparing `landlab-2.7.0/tests/components/landslides/conftest.py` & `landlab-2.8.0/tests/components/landslides/conftest.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/landslides/test_landslide_probability.py` & `landlab-2.8.0/tests/components/landslides/test_landslide_probability.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 """
 Unit tests for landlab.components.landslides.landslide_probability
 """
+
 import numpy as np
 import pytest
 from numpy.testing import assert_array_almost_equal
 
 from landlab import RasterModelGrid
 from landlab.components import LandslideProbability
```

### Comparing `landlab-2.7.0/tests/components/lateral_erosion/test_latero.py` & `landlab-2.8.0/tests/components/lateral_erosion/test_latero.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,15 +8,16 @@
 """
 
 import numpy as np
 import pytest
 from numpy import testing
 
 from landlab import RasterModelGrid
-from landlab.components import FlowAccumulator, LateralEroder
+from landlab.components import FlowAccumulator
+from landlab.components import LateralEroder
 
 
 def test_lateral_erosion_and_node():
     """
     Test that sets up a simple, pre-defined drainage network and compares
     the lateral node that is eroded, the volume of lateral eorsion, and the elevation
     of the landscape after one timestep to known values.
```

### Comparing `landlab-2.7.0/tests/components/lateral_erosion/test_node_finder.py` & `landlab-2.8.0/tests/components/lateral_erosion/test_node_finder.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/lithology/test_litholayers.py` & `landlab-2.8.0/tests/components/lithology/test_litholayers.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/lithology/test_lithology.py` & `landlab-2.8.0/tests/components/lithology/test_lithology.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,15 +6,16 @@
 """
 import numpy as np
 import pytest
 from numpy.testing import assert_array_equal  # , assert_array_almost_equal
 
 from landlab import RasterModelGrid
 from landlab.bmi import wrap_as_bmi
-from landlab.components import LithoLayers, Lithology
+from landlab.components import LithoLayers
+from landlab.components import Lithology
 
 
 def test_lithology_as_bmi():
     """Test Lithology can be wrapped with a BMI."""
     wrap_as_bmi(Lithology)
```

### Comparing `landlab-2.7.0/tests/components/marine_sediment_transport/test_simple_submarine_diffuser.py` & `landlab-2.8.0/tests/components/marine_sediment_transport/test_simple_submarine_diffuser.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 #!/usr/bin/env python3
 """
 Created on Fri Feb 12 17:12:24 2021
 
 @author: gtucker
 """
 
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
 from landlab.components import SimpleSubmarineDiffuser
 
 
 def test_diffusivity_vs_depth():
     """
```

### Comparing `landlab-2.7.0/tests/components/network_sediment_transporter/conftest.py` & `landlab-2.8.0/tests/components/network_sediment_transporter/conftest.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import numpy as np
 import pytest
 
-from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
+from landlab.components import FlowDirectorSteepest
+from landlab.components import NetworkSedimentTransporter
 from landlab.data_record import DataRecord
 from landlab.grid.network import NetworkModelGrid
 
 
 @pytest.fixture()
 def example_nmg():
     y_of_node = (0, 100, 200, 200, 300, 400, 400, 125)
```

### Comparing `landlab-2.7.0/tests/components/network_sediment_transporter/test_abrasion.py` & `landlab-2.8.0/tests/components/network_sediment_transporter/test_abrasion.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/network_sediment_transporter/test_active_layer_methods.py` & `landlab-2.8.0/tests/components/network_sediment_transporter/test_active_layer_methods.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/network_sediment_transporter/test_bed_initializer.py` & `landlab-2.8.0/tests/components/network_sediment_transporter/test_bed_initializer.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,25 +1,31 @@
 """
 Tests written by Jeff Keck and Allison Pfeiffer
 """
 
 import numpy as np
 import pytest
 
-from landlab.components import (
-    BedParcelInitializerArea,
-    BedParcelInitializerDepth,
-    BedParcelInitializerDischarge,
-    BedParcelInitializerUserD50,
-)
+from landlab.components import BedParcelInitializerArea
+from landlab.components import BedParcelInitializerDepth
+from landlab.components import BedParcelInitializerDischarge
+from landlab.components import BedParcelInitializerUserD50
 from landlab.components.network_sediment_transporter.bed_parcel_initializers import (
     _determine_approx_parcel_volume,
+)
+from landlab.components.network_sediment_transporter.bed_parcel_initializers import (
     calc_d50_dArea_scaling,
+)
+from landlab.components.network_sediment_transporter.bed_parcel_initializers import (
     calc_d50_depth,
+)
+from landlab.components.network_sediment_transporter.bed_parcel_initializers import (
     calc_d50_discharge,
+)
+from landlab.components.network_sediment_transporter.bed_parcel_initializers import (
     calc_total_parcel_volume,
 )
 from landlab.data_record import DataRecord
 
 
 # Basic test: that you can call the four initializers, create DataRecord
 def test_call_area_BPI(example_nmg2):
```

### Comparing `landlab-2.7.0/tests/components/network_sediment_transporter/test_filo.py` & `landlab-2.8.0/tests/components/network_sediment_transporter/test_filo.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import numpy as np
 from numpy.testing import assert_array_equal
 
-from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
+from landlab.components import FlowDirectorSteepest
+from landlab.components import NetworkSedimentTransporter
 from landlab.data_record import DataRecord
 from landlab.grid.network import NetworkModelGrid
 
 
 def test_first_in_last_out():
     y_of_node = (0, 0, 0, 0, 0, 0)
     x_of_node = (0, 100, 200, 300, 400, 500)
```

### Comparing `landlab-2.7.0/tests/components/network_sediment_transporter/test_init.py` & `landlab-2.8.0/tests/components/network_sediment_transporter/test_init.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/network_sediment_transporter/test_init_sediment_pulser.py` & `landlab-2.8.0/tests/components/network_sediment_transporter/test_init_sediment_pulser.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import pytest
 
 from landlab import RasterModelGrid
-from landlab.components import SedimentPulserAtLinks, SedimentPulserEachParcel
+from landlab.components import SedimentPulserAtLinks
+from landlab.components import SedimentPulserEachParcel
 
 variable_list = {
     "_grid",
     "_parcels",
     "_D50",
     "_D84_D50",
     "_rho_sediment",
```

### Comparing `landlab-2.7.0/tests/components/network_sediment_transporter/test_parcel_leaves.py` & `landlab-2.8.0/tests/components/network_sediment_transporter/test_parcel_leaves.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/network_sediment_transporter/test_pulse_sediment.py` & `landlab-2.8.0/tests/components/network_sediment_transporter/test_pulse_sediment.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import numpy as np
 from numpy.testing import assert_array_almost_equal
 
-from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
+from landlab.components import FlowDirectorSteepest
+from landlab.components import NetworkSedimentTransporter
 from landlab.data_record import DataRecord
 from landlab.grid.network import NetworkModelGrid
 
 
 def test_add_pulse():
     y_of_node = (0, 0, 0, 0)
     x_of_node = (0, 100, 200, 300)
```

### Comparing `landlab-2.7.0/tests/components/network_sediment_transporter/test_recycling.py` & `landlab-2.8.0/tests/components/network_sediment_transporter/test_recycling.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import numpy as np
 from numpy.testing import assert_array_almost_equal
 
-from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
+from landlab.components import FlowDirectorSteepest
+from landlab.components import NetworkSedimentTransporter
 from landlab.data_record import DataRecord
 from landlab.grid.network import NetworkModelGrid
 
 
 def test_recycling():
     y_of_node = (0, 0, 0, 0)
     x_of_node = (0, 100, 200, 300)
```

### Comparing `landlab-2.7.0/tests/components/network_sediment_transporter/test_sediment_pulser.py` & `landlab-2.8.0/tests/components/network_sediment_transporter/test_sediment_pulser.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import numpy as np
 import pandas as pd
 import pytest
-from numpy.testing import assert_allclose, assert_array_equal
+from numpy.testing import assert_allclose
+from numpy.testing import assert_array_equal
 from pytest import approx
 
 from landlab.components.network_sediment_transporter.sediment_pulser_at_links import (
     SedimentPulserAtLinks,
 )
 from landlab.components.network_sediment_transporter.sediment_pulser_base import (
     SedimentPulserBase,
```

### Comparing `landlab-2.7.0/tests/components/network_sediment_transporter/test_transport.py` & `landlab-2.8.0/tests/components/network_sediment_transporter/test_transport.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,13 @@
 import numpy as np
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
-from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
+from landlab.components import FlowDirectorSteepest
+from landlab.components import NetworkSedimentTransporter
 from landlab.data_record import DataRecord
 from landlab.grid.network import NetworkModelGrid
 
 
 def test_no_flow_no_transport(example_nmg, example_parcels, example_flow_director):
     timesteps = 3
     example_nmg.at_link["flow_depth"] = 0 * np.ones(example_nmg.size("link"))
```

### Comparing `landlab-2.7.0/tests/components/nonlinear_diffusion/test_sniff_nldiff.py` & `landlab-2.8.0/tests/components/nonlinear_diffusion/test_sniff_nldiff.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/normal_fault/test_normal_fault.py` & `landlab-2.8.0/tests/components/normal_fault/test_normal_fault.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 import numpy as np
 import pytest
 from numpy.testing import assert_array_equal
 
-from landlab import HexModelGrid, RasterModelGrid
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.components import NormalFault
 
 
 def test_dx_equals_zero():
     """Test a vertical fault trace."""
     grid = RasterModelGrid((6, 6), xy_spacing=10)
```

### Comparing `landlab-2.7.0/tests/components/overland_flow/conftest.py` & `landlab-2.8.0/tests/components/overland_flow/conftest.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,13 @@
 import pytest
 
 from landlab import RasterModelGrid
-from landlab.components.overland_flow import (
-    KinwaveOverlandFlowModel,
-    OverlandFlow,
-    OverlandFlowBates,
-)
+from landlab.components.overland_flow import KinwaveOverlandFlowModel
+from landlab.components.overland_flow import OverlandFlow
+from landlab.components.overland_flow import OverlandFlowBates
 
 
 @pytest.fixture
 def deAlm():
     grid = RasterModelGrid((32, 240), xy_spacing=25)
     grid.add_zeros("surface_water__depth", at="node")
     grid.add_zeros("topographic__elevation", at="node")
```

### Comparing `landlab-2.7.0/tests/components/overland_flow/test_active_links_at_node.py` & `landlab-2.8.0/tests/components/overland_flow/test_active_links_at_node.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/overland_flow/test_bates_overland_flow.py` & `landlab-2.8.0/tests/components/overland_flow/test_bates_overland_flow.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """
 Unit tests for landlab.components.overland_flow.OverlandFlowBates
 
 last updated: 3/14/16
 """
+
 import numpy as np
 import pytest
 
 from landlab.components.overland_flow import OverlandFlowBates
 
 (_SHAPE, _SPACING, _ORIGIN) = ((32, 240), (25, 25), (0.0, 0.0))
 _ARGS = (_SHAPE, _SPACING, _ORIGIN)
```

### Comparing `landlab-2.7.0/tests/components/overland_flow/test_dealmeida_overland_flow.py` & `landlab-2.8.0/tests/components/overland_flow/test_dealmeida_overland_flow.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """
 Unit tests for landlab.components.overland_flow.OverlandFlow
 
 last updated: 3/14/16
 """
+
 import numpy as np
 
 from landlab import RasterModelGrid
 from landlab.components.overland_flow import OverlandFlow
 from landlab.components.overland_flow._links import horizontal_link_ids
 
 (_SHAPE, _SPACING, _ORIGIN) = ((32, 240), (25, 25), (0.0, 0.0))
```

### Comparing `landlab-2.7.0/tests/components/overland_flow/test_kinwave.py` & `landlab-2.8.0/tests/components/overland_flow/test_kinwave.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """
 Unit tests for landlab.components.overland_flow.KinwaveOverlandFlowModel
 
 last updated: 3/14/16
 """
+
 (_SHAPE, _SPACING, _ORIGIN) = ((10, 10), (25, 25), (0.0, 0.0))
 _ARGS = (_SHAPE, _SPACING, _ORIGIN)
 
 
 def test_KinWaveOF_name(kin_wave_of):
     assert kin_wave_of.name == "KinwaveOverlandFlowModel"
```

### Comparing `landlab-2.7.0/tests/components/overland_flow/test_kinwave_implicit.py` & `landlab-2.8.0/tests/components/overland_flow/test_kinwave_implicit.py`

 * *Files 1% similar despite different names*

```diff
@@ -109,17 +109,15 @@
 
 
 def test_curved_surface():
     """Test flow across a curved surface."""
 
     # Create a grid
     rg = RasterModelGrid((10, 10), xy_spacing=(2, 2))
-    rg.add_field(
-        "topographic__elevation", 3.0 * rg.node_x**2 + rg.node_y**2, at="node"
-    )
+    rg.add_field("topographic__elevation", 3.0 * rg.node_x**2 + rg.node_y**2, at="node")
 
     # Create component and run it
     kw = KinwaveImplicitOverlandFlow(rg, runoff_rate=0.001 * 3600000.0)
     for _ in range(8):
         kw.run_one_step(1.0)
 
     # The inflow discharge to each cell at steady state should equal the
```

### Comparing `landlab-2.7.0/tests/components/overland_flow/test_linear_diffusion_overland_flow.py` & `landlab-2.8.0/tests/components/overland_flow/test_linear_diffusion_overland_flow.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,15 +3,16 @@
 Unit tests for KinwaveImplicitOverlandFlowModel.
 
 Created on Sat Apr  1 10:49:33 2017
 
 @author: gtucker
 """
 
-from numpy.testing import assert_allclose, assert_raises
+from numpy.testing import assert_allclose
+from numpy.testing import assert_raises
 
 from landlab import RasterModelGrid
 from landlab.components import LinearDiffusionOverlandFlowRouter
 
 
 def test_steady_one_node():
     """Run to steady state with a single node"""
```

### Comparing `landlab-2.7.0/tests/components/pet/test_pet.py` & `landlab-2.8.0/tests/components/pet/test_pet.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 """
 Unit tests for landlab.components.pet.potential_evapotranspiration_field
 """
+
 import numpy as np
 import pytest
 from numpy.testing import assert_array_almost_equal
 
 (_SHAPE, _SPACING, _ORIGIN) = ((20, 20), (10e0, 10e0), (0.0, 0.0))
 _ARGS = (_SHAPE, _SPACING, _ORIGIN)
```

### Comparing `landlab-2.7.0/tests/components/plant_competition_ca/test_plant_competition_ca.py` & `landlab-2.8.0/tests/components/plant_competition_ca/test_plant_competition_ca.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 """
 Unit tests for landlab.components.plant_competition_ca.plant_competition_ca
 """
+
 import numpy as np
 import pytest
 from numpy.testing import assert_array_almost_equal
 
 (_SHAPE, _SPACING, _ORIGIN) = ((20, 20), (10e0, 10e0), (0.0, 0.0))
 _ARGS = (_SHAPE, _SPACING, _ORIGIN)
```

### Comparing `landlab-2.7.0/tests/components/potentiality_flowrouting/test_sniff_pot_fr.py` & `landlab-2.8.0/tests/components/potentiality_flowrouting/test_sniff_pot_fr.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 """Test potentiality flowrouter.
 
 This tester turns over the potentiality flowrouter to ensure basic
 functionality is working.
 
 Probably doesn't account for cell area yet.
 """
+
 import numpy as np
 from numpy.testing import assert_allclose
 
 from landlab import RasterModelGrid
 from landlab.components import PotentialityFlowRouter
 
 NROWS = 10
```

### Comparing `landlab-2.7.0/tests/components/priority_flood_flow_router/test_priority_flood_flow_router.py` & `landlab-2.8.0/tests/components/priority_flood_flow_router/test_priority_flood_flow_router.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 """Test the flow accumulator component.
 
 @author: benjaminCampforts
 """
+
 import numpy as np
 import pytest
 from numpy import testing
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
-from landlab import FieldError, HexModelGrid, RasterModelGrid
+from landlab import FieldError
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.components import PriorityFloodFlowRouter
-from landlab.components.priority_flood_flow_router.cfuncs import (
-    _D8_FlowAcc,
-    _D8_flowDir,
-)
+from landlab.components.priority_flood_flow_router.cfuncs import _D8_FlowAcc
+from landlab.components.priority_flood_flow_router.cfuncs import _D8_flowDir
 from landlab.grid.nodestatus import NodeStatus
 
 try:
     PriorityFloodFlowRouter.load_richdem()
 except ModuleNotFoundError:
     pytestmark = pytest.mark.skip(reason="richdem is not installed")
 
 
 def test_check_fields():
     """Check to make sure the right fields have been created."""
     # %%
     mg = RasterModelGrid((10, 10), xy_spacing=(1, 1))
-    z = mg.add_field(
-        "topographic__elevation", mg.node_x**2 + mg.node_y**2, at="node"
-    )
+    z = mg.add_field("topographic__elevation", mg.node_x**2 + mg.node_y**2, at="node")
 
     PriorityFloodFlowRouter(mg)
     assert_array_equal(z, mg.at_node["topographic__elevation"])
     assert_array_equal(mg.at_node["drainage_area"], 0.0)
     assert_array_equal(mg.at_node["water__unit_flux_in"], 1.0)
 
     PriorityFloodFlowRouter(mg, runoff_rate=2.0)
```

### Comparing `landlab-2.7.0/tests/components/profiler/test_base_profiler.py` & `landlab-2.8.0/tests/components/profiler/test_base_profiler.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/profiler/test_channel_profile.py` & `landlab-2.8.0/tests/components/profiler/test_channel_profile.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,22 +4,21 @@
 
 @author: barnhark
 """
 import matplotlib
 import numpy as np
 import pytest
 
-from landlab import FieldError, RasterModelGrid
-from landlab.components import (
-    ChannelProfiler,
-    DepressionFinderAndRouter,
-    FastscapeEroder,
-    FlowAccumulator,
-    LinearDiffuser,
-)
+from landlab import FieldError
+from landlab import RasterModelGrid
+from landlab.components import ChannelProfiler
+from landlab.components import DepressionFinderAndRouter
+from landlab.components import FastscapeEroder
+from landlab.components import FlowAccumulator
+from landlab.components import LinearDiffuser
 
 matplotlib.use("agg")
 
 
 def test_assertion_error():
     """Test that the correct assertion error will be raised."""
     mg = RasterModelGrid((10, 10))
```

### Comparing `landlab-2.7.0/tests/components/profiler/test_profiler.py` & `landlab-2.8.0/tests/components/profiler/test_profiler.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/radiation/test_radiation.py` & `landlab-2.8.0/tests/components/vegetation_dynamics/test_vegetation_dynamics.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,79 +1,93 @@
 """
-Unit tests for landlab.components.radiation.radiation
+Unit tests for \
+    landlab.components.vegetation_dynamics.vegetation_dynamics
 """
+
 import numpy as np
 import pytest
 from numpy.testing import assert_array_almost_equal
 
 (_SHAPE, _SPACING, _ORIGIN) = ((20, 20), (10e0, 10e0), (0.0, 0.0))
 _ARGS = (_SHAPE, _SPACING, _ORIGIN)
 
 
-def test_name(rad):
-    assert rad.name == "Radiation"
+def test_name(veg):
+    assert veg.name == "Vegetation"
 
 
-def test_input_var_names(rad):
-    assert rad.input_var_names == ("topographic__elevation",)
+def test_input_var_names(veg):
+    assert sorted(veg.input_var_names) == [
+        "surface__evapotranspiration",
+        "surface__potential_evapotranspiration_30day_mean",
+        "surface__potential_evapotranspiration_rate",
+        "vegetation__plant_functional_type",
+        "vegetation__water_stress",
+    ]
 
 
-def test_output_var_names(rad):
-    assert sorted(rad.output_var_names) == [
-        "radiation__incoming_shortwave_flux",
-        "radiation__net_shortwave_flux",
-        "radiation__ratio_to_flat_surface",
+def test_output_var_names(veg):
+    assert sorted(veg.output_var_names) == [
+        "vegetation__cover_fraction",
+        "vegetation__dead_biomass",
+        "vegetation__dead_leaf_area_index",
+        "vegetation__live_biomass",
+        "vegetation__live_leaf_area_index",
     ]
 
 
-def test_var_units(rad):
-    assert set(rad.input_var_names) | set(rad.output_var_names) == set(
-        dict(rad.units).keys()
+def test_var_units(veg):
+    assert set(veg.input_var_names) | set(veg.output_var_names) == set(
+        dict(veg.units).keys()
     )
 
-    assert rad.var_units("topographic__elevation") == "m"
-    assert rad.var_units("radiation__incoming_shortwave_flux") == "W/m^2"
-    assert rad.var_units("radiation__net_shortwave_flux") == "W/m^2"
-    assert rad.var_units("radiation__ratio_to_flat_surface") == "None"
+    assert veg.var_units("vegetation__live_leaf_area_index") == "None"
+    assert veg.var_units("vegetation__dead_leaf_area_index") == "None"
+    assert veg.var_units("vegetation__cover_fraction") == "None"
+    assert veg.var_units("surface__evapotranspiration") == "mm"
+    assert veg.var_units("surface__potential_evapotranspiration_rate") == "mm"
+    assert veg.var_units("surface__potential_evapotranspiration_30day_mean") == "mm"
+    assert veg.var_units("vegetation__water_stress") == "None"
+    assert veg.var_units("vegetation__live_biomass") == "g m^-2 d^-1"
+    assert veg.var_units("vegetation__dead_biomass") == "g m^-2 d^-1"
+    assert veg.var_units("vegetation__plant_functional_type") == "None"
 
 
-def test_grid_shape(rad):
-    assert rad.grid.number_of_node_rows == _SHAPE[0]
-    assert rad.grid.number_of_node_columns == _SHAPE[1]
+def test_grid_shape(veg):
+    assert veg.grid.number_of_node_rows == _SHAPE[0]
+    assert veg.grid.number_of_node_columns == _SHAPE[1]
 
 
-def test_grid_x_extent(rad):
-    assert rad.grid.extent[1] == (_SHAPE[1] - 1) * _SPACING[1]
+def test_grid_x_extent(veg):
+    assert veg.grid.extent[1] == (_SHAPE[1] - 1) * _SPACING[1]
 
 
-def test_grid_y_extent(rad):
-    assert rad.grid.extent[0] == (_SHAPE[0] - 1) * _SPACING[0]
+def test_grid_y_extent(veg):
+    assert veg.grid.extent[0] == (_SHAPE[0] - 1) * _SPACING[0]
 
 
-def test_field_getters(rad):
-    for name in rad.grid["node"]:
-        field = rad.grid["node"][name]
+def test_field_getters(veg):
+    for name in veg.grid["node"]:
+        field = veg.grid["node"][name]
         assert isinstance(field, np.ndarray)
         assert field.shape == (
-            rad.grid.number_of_node_rows * rad.grid.number_of_node_columns,
+            veg.grid.number_of_node_rows * veg.grid.number_of_node_columns,
         )
 
-    for name in rad.grid["cell"]:
-        field = rad.grid["cell"][name]
+    for name in veg.grid["cell"]:
+        field = veg.grid["cell"][name]
         assert isinstance(field, np.ndarray)
         assert field.shape == (
-            rad.grid.number_of_cell_rows * rad.grid.number_of_cell_columns,
+            veg.grid.number_of_cell_rows * veg.grid.number_of_cell_columns,
         )
 
     with pytest.raises(KeyError):
-        rad.grid["not_a_var_name"]
+        veg.grid["not_a_var_name"]
 
 
-def test_field_initialized_to_zero(rad):
-    for name in rad.grid["node"]:
-        field = rad.grid["node"][name]
-        assert_array_almost_equal(field, np.zeros(rad.grid.number_of_nodes))
-    for name in rad.grid["cell"]:
-        if name == "Slope" or name == "Aspect":
-            continue
-        field = rad.grid["cell"][name]
-        assert_array_almost_equal(field, np.zeros(rad.grid.number_of_cells))
+def test_field_initialized_to_zero(veg):
+    for name in veg.grid["node"]:
+        field = veg.grid["node"][name]
+        assert_array_almost_equal(field, np.zeros(veg.grid.number_of_nodes))
+    for name in veg.grid["cell"]:
+        field = veg.grid["cell"][name]
+        assert_array_almost_equal(field, np.zeros(veg.grid.number_of_cells))
```

### Comparing `landlab-2.7.0/tests/components/sink_fill/conftest.py` & `landlab-2.8.0/tests/components/sink_fill/conftest.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/sink_fill/test_sink_filler.py` & `landlab-2.8.0/tests/components/sink_fill/test_sink_filler.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,25 @@
 """
 test_sink_filler:
 
 Created on Tues Oct 20, 2015
 
 @author: dejh
 """
+
 import numpy as np  # for use of np.round
 import pytest
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
-from landlab import FieldError, RasterModelGrid
-from landlab.components import FlowAccumulator, SinkFiller, SinkFillerBarnes
+from landlab import FieldError
+from landlab import RasterModelGrid
+from landlab.components import FlowAccumulator
+from landlab.components import SinkFiller
+from landlab.components import SinkFillerBarnes
 
 XX = RasterModelGrid.BAD_INDEX
 
 
 def test_route_to_multiple_error_raised_init():
     mg = RasterModelGrid((10, 10))
     z = mg.add_zeros("topographic__elevation", at="node")
```

### Comparing `landlab-2.7.0/tests/components/soil_moisture/conftest.py` & `landlab-2.8.0/tests/components/soil_moisture/conftest.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/soil_moisture/test_green_ampt_infil.py` & `landlab-2.8.0/tests/components/soil_moisture/test_green_ampt_infil.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """
 Unit tests for landlab.components.soil_moisture.SoilInfiltrationGreenAmpt
 
 last updated: 3/14/16
 """
+
 import numpy as np
 
 from landlab import RasterModelGrid
 from landlab.components.soil_moisture import SoilInfiltrationGreenAmpt
 
 (_SHAPE, _SPACING, _ORIGIN) = ((10, 10), (25, 25), (0.0, 0.0))
 _ARGS = (_SHAPE, _SPACING, _ORIGIN)
```

### Comparing `landlab-2.7.0/tests/components/soil_moisture/test_soil_moisture.py` & `landlab-2.8.0/tests/components/soil_moisture/test_soil_moisture.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 """
 Unit tests for \
     landlab.components.soil_moisture.soil_moisture_dynamics
 """
+
 import numpy as np
 import pytest
 from numpy.testing import assert_array_almost_equal
 
 (_SHAPE, _SPACING, _ORIGIN) = ((20, 20), (10e0, 10e0), (0.0, 0.0))
 _ARGS = (_SHAPE, _SPACING, _ORIGIN)
```

### Comparing `landlab-2.7.0/tests/components/space/test_space.py` & `landlab-2.8.0/tests/components/space/test_space.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,15 @@
 import numpy as np
 import pytest
 from numpy import testing
 
-from landlab import HexModelGrid, RasterModelGrid
-from landlab.components import FlowAccumulator, Space
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
+from landlab.components import FlowAccumulator
+from landlab.components import Space
 
 
 def test_route_to_multiple_error_raised():
     mg = RasterModelGrid((10, 10))
     z = mg.add_zeros("topographic__elevation", at="node")
     z += mg.x_of_node + mg.y_of_node
     fa = FlowAccumulator(mg, flow_director="MFD")
@@ -336,17 +338,17 @@
     )
 
     # ... and run it to steady state (5000x1-year timesteps).
     for _ in range(5000):
         fa.run_one_step()
         sp.run_one_step(dt=dt)
         br[mg.core_nodes] += U * dt  # m
-        soil[
-            0
-        ] = 100.0  # enforce constant soil depth at boundary to keep lowering steady
+        soil[0] = (
+            100.0  # enforce constant soil depth at boundary to keep lowering steady
+        )
         z[:] = br[:] + soil[:]
 
     # compare numerical and analytical slope solutions
     num_slope = mg.at_node["topographic__steepest_slope"][mg.core_nodes]
     analytical_slope = np.power(
         (
             (U * v_s * (1 - phi))
```

### Comparing `landlab-2.7.0/tests/components/space/test_space_large_scale_eroder.py` & `landlab-2.8.0/tests/components/space/test_space_large_scale_eroder.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 import copy as cp
 
 import numpy as np
 import pytest
 from numpy import testing
 
-from landlab import FieldError, HexModelGrid, RasterModelGrid
-from landlab.components import (
-    FlowAccumulator,
-    PriorityFloodFlowRouter,
-    SpaceLargeScaleEroder,
-)
+from landlab import FieldError
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
+from landlab.components import FlowAccumulator
+from landlab.components import PriorityFloodFlowRouter
+from landlab.components import SpaceLargeScaleEroder
 
 try:
     PriorityFloodFlowRouter.load_richdem()
 except ModuleNotFoundError:
     with_richdem = False
 else:
     with_richdem = True
@@ -508,17 +508,17 @@
     )
 
     # ... and run it to steady state (5000x1-year timesteps).
     for _ in range(5000):
         fa.run_one_step()
         sp.run_one_step(dt=dt)
         br[mg.core_nodes] += U * dt  # m
-        soil[
-            0
-        ] = 100.0  # enforce constant soil depth at boundary to keep lowering steady
+        soil[0] = (
+            100.0  # enforce constant soil depth at boundary to keep lowering steady
+        )
         z[:] = br[:] + soil[:]
 
     # compare numerical and analytical slope solutions
     num_slope = mg.at_node["topographic__steepest_slope"][mg.core_nodes]
     analytical_slope = np.power(
         (
             (U * v_s * (1 - phi))
@@ -858,17 +858,17 @@
     )
 
     # ... and run it to steady state (5000x1-year timesteps).
     for _ in range(5000):
         fa.run_one_step()
         sp.run_one_step(dt=dt)
         br[mg.core_nodes] += U * dt  # m
-        soil[
-            0
-        ] = 100.0  # enforce constant soil depth at boundary to keep lowering steady
+        soil[0] = (
+            100.0  # enforce constant soil depth at boundary to keep lowering steady
+        )
         z[:] = br[:] + soil[:]
 
     # compare numerical and analytical slope solutions
     num_slope = mg.at_node["topographic__steepest_slope"][mg.core_nodes]
     analytical_slope = np.power(
         (
             (U * v_s * (1 - phi))
@@ -1014,14 +1014,248 @@
         decimal=5,
         err_msg="SpaceLargeScaleEroder bedrock-alluvial soil thickness test failed",
         verbose=True,
     )
     # %%
 
 
+# %%
+@pytest.mark.slow
+@pytest.mark.skipif(not with_richdem, reason="richdem is not installed")
+def test_matches_bedrock_alluvial_solution_PF_extended_range():
+    """
+    Test that model matches the bedrock-alluvial analytical solution
+    for slope/area relationship at steady state:
+    S=((U * v_s * (1 - F_f)) / (K_sed * A^m) + U / (K_br * A^m))^(1/n).
+
+    Also test that the soil depth everywhere matches the bedrock-alluvial
+    analytical solution at steady state:
+    H = -H_star * ln(1 - (v_s / (K_sed / (K_br * (1 - F_f)) + v_s))).
+    """
+    # %%
+    # set up a 5x5 grid with one open outlet node and low initial elevations.
+    nr = 5
+    nc = 5
+    mg = RasterModelGrid((nr, nc), xy_spacing=10.0)
+
+    z = mg.add_zeros("topographic__elevation", at="node")
+    br = mg.add_zeros("bedrock__elevation", at="node")
+    soil = mg.add_zeros("soil__depth", at="node")
+
+    np.random.seed(seed=5000)
+    mg["node"]["topographic__elevation"] += (
+        mg.node_y / 100000 + mg.node_x / 100000 + np.random.rand(len(mg.node_y)) / 10000
+    )
+
+    mg.set_watershed_boundary_condition_outlet_id(
+        0, mg["node"]["topographic__elevation"], -9999.0
+    )
+    soil[:] += 0.0  # initial condition of no soil depth.
+    br[:] = z[:]
+    z[:] += soil[:]
+
+    # Create a D8 flow handler
+    fa = PriorityFloodFlowRouter(
+        mg, surface="topographic__elevation", flow_metric="D8", suppress_out=True
+    )
+    fa.run_one_step()
+
+    # Parameter values for detachment-limited test
+    K_br = 0.005
+    K_sed = 0.01
+    U = 0.0001
+    dt = 10.0
+    F_f = 0.0
+    m_sp = 0.5
+    n_sp = 1.0
+    v_s = 1.0
+    H_star = 1.0
+
+    # Instantiate the SpaceLargeScaleEroder component...
+    sp = SpaceLargeScaleEroder(
+        mg,
+        K_sed=K_sed,
+        K_br=K_br,
+        F_f=F_f,
+        phi=0.0,
+        H_star=H_star,
+        v_s=v_s,
+        m_sp=m_sp,
+        n_sp=n_sp,
+        sp_crit_sed=0,
+        sp_crit_br=0,
+    )
+
+    # ... and run it to steady state (10000x1-year timesteps).
+    for _ in range(10000):
+        fa.run_one_step()
+        sp.run_one_step(dt=dt)
+        br[mg.core_nodes] += U * dt  # m
+        soil[0] = 0.0  # enforce 0 soil depth at boundary to keep lowering steady
+        z[:] = br[:] + soil[:]
+
+    # compare numerical and analytical slope solutions
+    num_slope = mg.at_node["topographic__steepest_slope"][mg.core_nodes]
+    analytical_slope = np.power(
+        (
+            (U * v_s * (1 - F_f))
+            / (K_sed * np.power(mg.at_node["drainage_area"][mg.core_nodes], m_sp))
+        )
+        + (U / (K_br * np.power(mg.at_node["drainage_area"][mg.core_nodes], m_sp))),
+        1.0 / n_sp,
+    )
+
+    # test for match with analytical slope-area relationship
+    testing.assert_array_almost_equal(
+        num_slope,
+        analytical_slope,
+        decimal=8,
+        err_msg="SpaceLargeScaleEroder bedrock-alluvial slope-area test failed",
+        verbose=True,
+    )
+
+    # compare numerical and analytical soil depth solutions
+    num_h = mg.at_node["soil__depth"][mg.core_nodes]
+    analytical_h = -H_star * np.log(1 - (v_s / (K_sed / (K_br * (1 - F_f)) + v_s)))
+
+    # test for match with analytical sediment depth
+    testing.assert_array_almost_equal(
+        num_h,
+        analytical_h,
+        decimal=5,
+        err_msg="SpaceLargeScaleEroder bedrock-alluvial soil thickness test failed",
+        verbose=True,
+    )
+
+
+# %%
+@pytest.mark.slow
+@pytest.mark.skipif(not with_richdem, reason="richdem is not installed")
+def test_matches_bedrock_alluvial_solution_PF_high_v_high_hstar():
+    """
+    Test that model matches the bedrock-alluvial analytical solution
+    for slope/area relationship at steady state:
+    S=((U * v_s * (1 - F_f)) / (K_sed * A^m) + U / (K_br * A^m))^(1/n).
+    Also test that the soil depth everywhere matches the bedrock-alluvial
+    analytical solution at steady state:
+    H = -H_star * ln(1 - (v_s / (K_sed / (K_br * (1 - F_f)) + v_s))).
+    Also test that the sediment flux at the outlet is:
+    Qs = U * A.
+    """
+    # %%
+    # set up a 5x5 grid with one open outlet node and low initial elevations.
+    nr = 5
+    nc = 5
+    mg = RasterModelGrid((nr, nc), xy_spacing=10.0)
+
+    z = mg.add_zeros("topographic__elevation", at="node")
+    br = mg.add_zeros("bedrock__elevation", at="node")
+    soil = mg.add_zeros("soil__depth", at="node")
+
+    np.random.seed(seed=5000)
+    mg["node"]["topographic__elevation"] += (
+        mg.node_y / 100000 + mg.node_x / 100000 + np.random.rand(len(mg.node_y)) / 10000
+    )
+
+    mg.set_watershed_boundary_condition_outlet_id(
+        0, mg["node"]["topographic__elevation"], -9999.0
+    )
+    soil[:] += 0.0  # initial condition of no soil depth.
+    br[:] = z[:]
+    z[:] += soil[:]
+
+    # Create a D8 flow handler
+    fa = PriorityFloodFlowRouter(
+        mg, surface="topographic__elevation", flow_metric="D8", suppress_out=True
+    )
+    fa.run_one_step()
+
+    # Parameter values for detachment-limited test
+    K_br = 0.005
+    K_sed = 0.01
+    U = 0.0001
+    dt = 10.0
+    F_f = 0.0
+    m_sp = 0.5
+    n_sp = 1.0
+    v_s = 10.0
+    H_star = 2.0
+    phi = 0.0
+
+    # Instantiate the SpaceLargeScaleEroder component...
+    sp = SpaceLargeScaleEroder(
+        mg,
+        K_sed=K_sed,
+        K_br=K_br,
+        F_f=F_f,
+        phi=phi,
+        H_star=H_star,
+        v_s=v_s,
+        m_sp=m_sp,
+        n_sp=n_sp,
+        sp_crit_sed=0,
+        sp_crit_br=0,
+    )
+
+    # ... and run it to steady state (25000x10-year timesteps).
+    for _ in range(25000):
+        fa.run_one_step()
+        sp.run_one_step(dt=dt)
+        br[mg.core_nodes] += U * dt  # m
+        soil[0] = 0.0  # enforce 0 soil depth at boundary to keep lowering steady
+        z[:] = br[:] + soil[:]
+
+    # compare numerical and analytical slope solutions
+    num_slope = mg.at_node["topographic__steepest_slope"][mg.core_nodes]
+    analytical_slope = np.power(
+        (
+            (U * v_s * (1 - F_f))
+            / (K_sed * np.power(mg.at_node["drainage_area"][mg.core_nodes], m_sp))
+        )
+        + (U / (K_br * np.power(mg.at_node["drainage_area"][mg.core_nodes], m_sp))),
+        1.0 / n_sp,
+    )
+
+    # test for match with analytical slope-area relationship
+    testing.assert_array_almost_equal(
+        num_slope,
+        analytical_slope,
+        decimal=8,
+        err_msg="SpaceLargeScaleEroder bedrock-alluvial slope-area test failed",
+        verbose=True,
+    )
+
+    # compare numerical and analytical soil depth solutions
+    num_h = mg.at_node["soil__depth"][mg.core_nodes]
+    analytical_h = -H_star * np.log(1 - (v_s / (K_sed / (K_br * (1 - F_f)) + v_s)))
+
+    # test for match with analytical sediment depth
+    testing.assert_array_almost_equal(
+        num_h,
+        analytical_h,
+        decimal=5,
+        err_msg="SpaceLargeScaleEroder bedrock-alluvial soil thickness test failed",
+        verbose=True,
+    )
+
+    # compare numerical and analytical sediment flux solutions
+    num_sedflux = mg.at_node["sediment__outflux"][mg.core_nodes]
+    analytical_sedflux = U * mg.at_node["drainage_area"][mg.core_nodes] * (1 - phi)
+
+    # test for match with analytical sediment flux
+    testing.assert_array_almost_equal(
+        num_sedflux,
+        analytical_sedflux,
+        decimal=5,
+        err_msg="SpaceLargeScaleEroder bedrock-alluvial sediment flux test failed",
+        verbose=True,
+    )
+
+
+# %%
 @pytest.mark.slow
 def test_MassBalance():
     # %%
     # set up a 15x15 grid with one open outlet node and low initial elevations.
     nr = 15
     nc = 15
     mg = RasterModelGrid((nr, nc), xy_spacing=10.0)
```

### Comparing `landlab-2.7.0/tests/components/spatial_precip/elevs_Singer.txt` & `landlab-2.8.0/tests/components/spatial_precip/elevs_Singer.txt`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/spatial_precip/test_spatial_storm_generator.py` & `landlab-2.8.0/tests/components/spatial_precip/test_spatial_storm_generator.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/species_evolution/test_base_taxon.py` & `landlab-2.8.0/tests/components/species_evolution/test_base_taxon.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/species_evolution/test_record.py` & `landlab-2.8.0/tests/components/species_evolution/test_record.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/species_evolution/test_species_evolver.py` & `landlab-2.8.0/tests/components/species_evolution/test_species_evolver.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/species_evolution/test_zone_objects.py` & `landlab-2.8.0/tests/components/species_evolution/test_zone_objects.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,15 +2,17 @@
 """Tests for SpeciesEvolver zone objects."""
 import numpy as np
 import pandas as pd
 import pytest
 
 from landlab import RasterModelGrid
 from landlab.components import SpeciesEvolver
-from landlab.components.species_evolution import ZoneController, ZoneTaxon, zone as zn
+from landlab.components.species_evolution import ZoneController
+from landlab.components.species_evolution import ZoneTaxon
+from landlab.components.species_evolution import zone as zn
 
 
 @pytest.fixture()
 def zone_example_grid():
     mg = RasterModelGrid((5, 7), 2)
     z = mg.add_zeros("node", "topographic__elevation")
     return mg, z
```

### Comparing `landlab-2.7.0/tests/components/stream_power/perturbedcondst300.txt` & `landlab-2.8.0/tests/components/stream_power/perturbedcondst300.txt`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/stream_power/seddepinit.txt` & `landlab-2.8.0/tests/components/stream_power/seddepinit.txt`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/stream_power/seddepz_tg.txt` & `landlab-2.8.0/tests/components/stream_power/seddepz_tg.txt`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/stream_power/tenmorestepsfrom300.txt` & `landlab-2.8.0/tests/components/stream_power/tenmorestepsfrom300.txt`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/stream_power/test_fastscape.py` & `landlab-2.8.0/tests/components/stream_power/test_fastscape.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """Test Braun-Willett flow routing and fastscape stream power.
 
 A simple driver implementing Braun-Willett flow routing and then the
 fastscape stream power component.
 """
+
 # DEJH, 09/15/14
 import os
 
 import numpy
 from numpy.testing import assert_array_almost_equal
 
 from landlab import RasterModelGrid
```

### Comparing `landlab-2.7.0/tests/components/stream_power/test_not_implemented_errors.py` & `landlab-2.8.0/tests/components/stream_power/test_not_implemented_errors.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,17 +1,15 @@
 import pytest
 
 from landlab import RasterModelGrid
-from landlab.components import (
-    FastscapeEroder,
-    FlowAccumulator,
-    SedDepEroder,
-    StreamPowerEroder,
-    StreamPowerSmoothThresholdEroder,
-)
+from landlab.components import FastscapeEroder
+from landlab.components import FlowAccumulator
+from landlab.components import SedDepEroder
+from landlab.components import StreamPowerEroder
+from landlab.components import StreamPowerSmoothThresholdEroder
 
 
 def test_route_to_multiple_error_raised_init_FastscapeEroder():
     mg = RasterModelGrid((10, 10))
     z = mg.add_zeros("node", "topographic__elevation")
     z += mg.x_of_node + mg.y_of_node
     fa = FlowAccumulator(mg, flow_director="MFD")
```

### Comparing `landlab-2.7.0/tests/components/stream_power/test_sed_flux_dep.py` & `landlab-2.8.0/tests/components/stream_power/test_sed_flux_dep.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,22 @@
 """Test the SedDepEroder component.
 
 Test the sed dep eroder by turning it over a few times. No attempt has been
 made to ensure the solution is stable. Takes a topo already output and runs it
 a few more times, to ensure repeatability.
 """
+
 import os
 
 import numpy as np
 from numpy.testing import assert_array_almost_equal
 
 from landlab import RasterModelGrid
-from landlab.components import FlowAccumulator, SedDepEroder
+from landlab.components import FlowAccumulator
+from landlab.components import SedDepEroder
 
 _THIS_DIR = os.path.abspath(os.path.dirname(__file__))
 
 
 def test_sed_dep():
     uplift_rate = 0.0001
     runtime = 20000.0
```

### Comparing `landlab-2.7.0/tests/components/stream_power/test_simple.py` & `landlab-2.8.0/tests/components/stream_power/test_simple.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,21 +1,23 @@
 """Test Braun-Willett and non-fastscape stream power component.
 
 A simple driver implementing Braun-Willett flow routing and then a
 (non-fastscape) stream power component.
 """
+
 # DEJH, 09/15/14
 
 import os
 
 import numpy
 from numpy.testing import assert_array_almost_equal
 
 from landlab import RasterModelGrid
-from landlab.components import FlowAccumulator, StreamPowerEroder
+from landlab.components import FlowAccumulator
+from landlab.components import StreamPowerEroder
 
 _THIS_DIR = os.path.abspath(os.path.dirname(__file__))
 
 
 def test_sp_old():
     uplift = 0.001
     dt = 1.0
```

### Comparing `landlab-2.7.0/tests/components/stream_power/test_smooth_thresh.py` & `landlab-2.8.0/tests/components/stream_power/test_smooth_thresh.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 import numpy as np
 import pytest
 from numpy.testing import assert_array_almost_equal
 
 from landlab import RasterModelGrid
-from landlab.components import FlowAccumulator, StreamPowerSmoothThresholdEroder as Spst
+from landlab.components import FlowAccumulator
+from landlab.components import StreamPowerSmoothThresholdEroder as Spst
 
 
 def test_bad_nsp():
     mg = RasterModelGrid((4, 4))
     mg.set_closed_boundaries_at_grid_edges(False, False, True, True)
     with pytest.raises(ValueError):
         Spst(mg, K_sp=1.0, n_sp=1.01)
```

### Comparing `landlab-2.7.0/tests/components/stream_power/test_sp_driver_discharges.py` & `landlab-2.8.0/tests/components/stream_power/test_sp_driver_discharges.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 """Test simple stream power functionality when a discharge array is specified."""
+
 import os
 
 import numpy as np
 from numpy.testing import assert_array_almost_equal
 
 from landlab import RasterModelGrid
-from landlab.components import FlowAccumulator, StreamPowerEroder
+from landlab.components import FlowAccumulator
+from landlab.components import StreamPowerEroder
 
 _THIS_DIR = os.path.abspath(os.path.dirname(__file__))
 
 
 def test_sp_discharges_old():
     dt = 1.0
     mg = RasterModelGrid((5, 5))
```

### Comparing `landlab-2.7.0/tests/components/stream_power/test_sp_driver_widths.py` & `landlab-2.8.0/tests/components/stream_power/test_sp_driver_widths.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 """Test simple stream power functionality when a width array is specified."""
+
 import os
 
 import numpy as np
 from numpy.testing import assert_array_almost_equal
 
 from landlab import RasterModelGrid
-from landlab.components import FlowAccumulator, StreamPowerEroder
+from landlab.components import FlowAccumulator
+from landlab.components import StreamPowerEroder
 
 _THIS_DIR = os.path.abspath(os.path.dirname(__file__))
 
 
 def test_sp_widths():
     nrows = 5
     ncols = 5
```

### Comparing `landlab-2.7.0/tests/components/stream_power/test_sp_storms.py` & `landlab-2.8.0/tests/components/stream_power/test_sp_storms.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,18 +1,17 @@
 """Test the storm generator and simple stream power eroder both execute."""
+
 import os
 
 import numpy as np
 
 from landlab import RasterModelGrid
-from landlab.components import (
-    FlowAccumulator,
-    PrecipitationDistribution,
-    StreamPowerEroder,
-)
+from landlab.components import FlowAccumulator
+from landlab.components import PrecipitationDistribution
+from landlab.components import StreamPowerEroder
 
 _THIS_DIR = os.path.abspath(os.path.dirname(__file__))
 
 
 def test_storms():
     dt = 500.0
     uplift = 0.0001
```

### Comparing `landlab-2.7.0/tests/components/stream_power/test_voronoi_sp.py` & `landlab-2.8.0/tests/components/stream_power/test_voronoi_sp.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 """Test the Voronoi compatibility of the grid."""
+
 import os
 
 import numpy as np
 from numpy.testing import assert_array_almost_equal
 
 from landlab import VoronoiDelaunayGrid
-from landlab.components import FlowAccumulator, StreamPowerEroder
+from landlab.components import FlowAccumulator
+from landlab.components import StreamPowerEroder
 
 _THIS_DIR = os.path.abspath(os.path.dirname(__file__))
 
 
 def test_sp_voronoi():
     nnodes = 100
```

### Comparing `landlab-2.7.0/tests/components/taylor_nonlinear_hillslope_flux/test_taylor_nonlinear_hillslope_flux.py` & `landlab-2.8.0/tests/components/taylor_nonlinear_hillslope_flux/test_taylor_nonlinear_hillslope_flux.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/tectonics/test_listric_kinematic_extender.py` & `landlab-2.8.0/tests/components/tectonics/test_listric_kinematic_extender.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,22 +2,21 @@
 """
 Created on Fri Mar  5 08:42:24 2021
 
 @author: gtucker
 """
 
 import numpy as np
-from numpy.testing import (
-    assert_almost_equal,
-    assert_array_almost_equal,
-    assert_equal,
-    assert_raises,
-)
+from numpy.testing import assert_almost_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_equal
+from numpy.testing import assert_raises
 
-from landlab import RadialModelGrid, RasterModelGrid
+from landlab import RadialModelGrid
+from landlab import RasterModelGrid
 from landlab.components import ListricKinematicExtender
 
 
 def test_hangingwall_motion():
     dx = 10.0  # node spacing, m
     fault_x0 = 100.0
     grid = RasterModelGrid((3, 130), xy_spacing=dx)
```

### Comparing `landlab-2.7.0/tests/components/test_components.py` & `landlab-2.8.0/tests/components/test_components.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,15 @@
 import numpy as np
 import pandas as pd
 import pytest
 
-from landlab import FieldError, RasterModelGrid
-from landlab.components import COMPONENTS, PriorityFloodFlowRouter
+from landlab import FieldError
+from landlab import RasterModelGrid
+from landlab.components import COMPONENTS
+from landlab.components import PriorityFloodFlowRouter
 
 _VALID_LOCS = {"grid", "node", "link", "patch", "corner", "face", "cell"}
 
 _REQUIRED_ATTRS = {"doc", "mapping", "dtype", "intent", "optional", "units"}
 
 _EXCLUDE_COMPONENTS = {
     "ChannelProfiler",
```

### Comparing `landlab-2.7.0/tests/components/threshold_eroder/test_threshold_eroder.py` & `landlab-2.8.0/tests/components/threshold_eroder/test_threshold_eroder.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,20 +1,19 @@
 #! /usr/bin/env python
 """Unit tests for landlab.components.threshold_eroder.py"""
 import numpy as np
 import pytest
 from numpy.testing import assert_array_almost_equal
 
-from landlab import HexModelGrid, RasterModelGrid
-from landlab.components import (
-    FlowAccumulator,
-    FlowDirectorSteepest,
-    PriorityFloodFlowRouter,
-    ThresholdEroder,
-)
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
+from landlab.components import FlowAccumulator
+from landlab.components import FlowDirectorSteepest
+from landlab.components import PriorityFloodFlowRouter
+from landlab.components import ThresholdEroder
 
 try:
     PriorityFloodFlowRouter.load_richdem()
 except ModuleNotFoundError:
     with_richdem = False
 else:
     with_richdem = True
```

### Comparing `landlab-2.7.0/tests/components/tidal_flow_calculator/test_tidal_flow_calculator.py` & `landlab-2.8.0/tests/components/tidal_flow_calculator/test_tidal_flow_calculator.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,22 +2,22 @@
 """
 Created on Sun Jul 12 10:22:59 2020
 
 @author: gtucker
 """
 
 import numpy as np
-from numpy.testing import (
-    assert_array_almost_equal,
-    assert_array_equal,
-    assert_equal,
-    assert_raises,
-)
-
-from landlab import HexModelGrid, RadialModelGrid, RasterModelGrid
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
+from numpy.testing import assert_equal
+from numpy.testing import assert_raises
+
+from landlab import HexModelGrid
+from landlab import RadialModelGrid
+from landlab import RasterModelGrid
 from landlab.components import TidalFlowCalculator
 
 
 def test_constant_depth_deeper_than_tidal_amplitude():
     r"""Test velocity calculation under the following conditions:
 
     r = 1  # tidal range in m
@@ -173,17 +173,17 @@
           = (21/8) I dx = (21/4) r dx / T = 0.0002625
     """
     grid = HexModelGrid((5, 3), spacing=2.0)
     z = grid.add_zeros("topographic__elevation", at="node")
     z[:] = -5.0
 
     # Close all boundary nodes except the bottom row
-    grid.status_at_node[
-        grid.status_at_node != grid.BC_NODE_IS_CORE
-    ] = grid.BC_NODE_IS_CLOSED
+    grid.status_at_node[grid.status_at_node != grid.BC_NODE_IS_CORE] = (
+        grid.BC_NODE_IS_CLOSED
+    )
     grid.status_at_node[0:3] = grid.BC_NODE_IS_FIXED_VALUE
 
     tfc = TidalFlowCalculator(grid, tidal_period=4.0e4)
     tfc.run_one_step()
 
     q = grid.at_link["flood_tide_flow__velocity"] * tfc._water_depth_at_links
     assert_array_almost_equal(q[3:7], [0.0002625, 0.0002625, 0.0002625, 0.0002625])
```

### Comparing `landlab-2.7.0/tests/components/transport_length_diffusion/test_tl_hill_diff.py` & `landlab-2.8.0/tests/components/transport_length_diffusion/test_tl_hill_diff.py`

 * *Files 8% similar despite different names*

```diff
@@ -6,19 +6,17 @@
 """
 
 import numpy as np
 import pytest
 from numpy.testing import assert_almost_equal
 
 from landlab import RasterModelGrid
-from landlab.components import (
-    FlowAccumulator,
-    FlowDirectorSteepest,
-    TransportLengthHillslopeDiffuser,
-)
+from landlab.components import FlowAccumulator
+from landlab.components import FlowDirectorSteepest
+from landlab.components import TransportLengthHillslopeDiffuser
 
 
 def test_route_to_multiple_error_raised():
     mg = RasterModelGrid((10, 10))
     z = mg.add_zeros("topographic__elevation", at="node")
     z += mg.x_of_node + mg.y_of_node
     fa = FlowAccumulator(mg, flow_director="MFD")
```

### Comparing `landlab-2.7.0/tests/components/vegetation_dynamics/conftest.py` & `landlab-2.8.0/tests/components/vegetation_dynamics/conftest.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/weathering/test_exponential_weatherer.py` & `landlab-2.8.0/tests/components/weathering/test_exponential_weatherer.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/components/weathering/test_exponential_weathering_integrated.py` & `landlab-2.8.0/tests/components/weathering/test_exponential_weathering_integrated.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,15 +4,16 @@
 
 @author: dylanward
 """
 
 import numpy as np
 import pytest
 
-from landlab import HexModelGrid, RasterModelGrid
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.components import ExponentialWeathererIntegrated
 
 
 def test_no_soil_depth_field():
     # should pass if the code fails correctly on instantiation
     # given no established soil__depth field on the model grid
     mg = RasterModelGrid((5, 5))
```

### Comparing `landlab-2.7.0/tests/core/test_example_data.py` & `landlab-2.8.0/tests/core/test_example_data.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/core/test_load_params.py` & `landlab-2.8.0/tests/core/test_load_params.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/core/test_messager.py` & `landlab-2.8.0/tests/core/test_messager.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,19 +1,17 @@
 #! /usr/bin/env python
 import os
 
 import pytest
 
-from landlab.core.messages import (
-    assert_or_print,
-    error_message,
-    format_message,
-    split_paragraphs,
-    warning_message,
-)
+from landlab.core.messages import assert_or_print
+from landlab.core.messages import error_message
+from landlab.core.messages import format_message
+from landlab.core.messages import split_paragraphs
+from landlab.core.messages import warning_message
 
 LOREM_IPSUM = os.linesep.join(
     [
         "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.",  # noqa: B950
         "",
         "Pharetra pharetra massa massa ultricies mi quis hendrerit.",
         "",
```

### Comparing `landlab-2.7.0/tests/data_record/conftest.py` & `landlab-2.8.0/tests/data_record/conftest.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/data_record/test_data_record_2dim.py` & `landlab-2.8.0/tests/data_record/test_data_record_2dim.py`

 * *Files 1% similar despite different names*

```diff
@@ -34,15 +34,15 @@
 
 
 def test_permitted_locations(dr_2dim):
     assert dr_2dim._permitted_locations == grid.groups
 
 
 def test_coordinates(dr_2dim):
-    assert len(dr_2dim.dataset.dims) == 2
+    assert len(dr_2dim.dataset.sizes) == 2
     assert list(dr_2dim.dataset.time.values) == time
     assert list(dr_2dim.time_coordinates) == time
     assert list(dr_2dim.dataset.item_id.values) == [0, 1]
     assert list(dr_2dim.item_coordinates) == [0, 1]
     # properties:
     assert dr_2dim.number_of_timesteps == 1
     assert dr_2dim.number_of_items == 2
```

### Comparing `landlab-2.7.0/tests/data_record/test_data_record_item.py` & `landlab-2.8.0/tests/data_record/test_data_record_item.py`

 * *Files 1% similar despite different names*

```diff
@@ -29,15 +29,15 @@
 
 
 def test_permitted_locations(dr_item):
     assert dr_item._permitted_locations == grid.groups
 
 
 def test_coordinates(dr_item):
-    assert len(dr_item.dataset.dims) == 1
+    assert len(dr_item.dataset.sizes) == 1
     assert list(dr_item.dataset.item_id.values) == [0, 1]
     assert list(dr_item.item_coordinates) == [0, 1]
     assert dr_item.number_of_items == len(my_items2["element_id"])
     with pytest.raises(AttributeError):
         dr_item.dataset.time
     with pytest.raises(AttributeError):
         dr_item.time_coordinates
```

### Comparing `landlab-2.7.0/tests/data_record/test_data_record_time.py` & `landlab-2.8.0/tests/data_record/test_data_record_time.py`

 * *Files 0% similar despite different names*

```diff
@@ -28,15 +28,15 @@
 
 
 def test_permitted_locations(dr_time):
     assert dr_time._permitted_locations == grid.groups
 
 
 def test_coordinates(dr_time):
-    assert len(dr_time.dataset.dims) == 1
+    assert len(dr_time.dataset.sizes) == 1
     assert list(dr_time.dataset.time.values) == list(np.array(time))
     assert list(dr_time.time_coordinates) == list(np.array(time))
     # properties:
     assert dr_time.number_of_timesteps == 1
     assert dr_time.earliest_time == 0.0
     assert dr_time.latest_time == 0.0
     assert np.isnan(dr_time.prior_time)
```

### Comparing `landlab-2.7.0/tests/data_record/test_dummy.py` & `landlab-2.8.0/tests/data_record/test_dummy.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/data_record/test_errors.py` & `landlab-2.8.0/tests/data_record/test_errors.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,15 +7,18 @@
 
 
 """
 
 import numpy as np
 import pytest
 
-from landlab import HexModelGrid, RadialModelGrid, RasterModelGrid, VoronoiDelaunayGrid
+from landlab import HexModelGrid
+from landlab import RadialModelGrid
+from landlab import RasterModelGrid
+from landlab import VoronoiDelaunayGrid
 from landlab.data_record import DataRecord
 
 
 def test_misc():
     grid = RasterModelGrid((3, 3))
 
     # test bad dimension:
```

### Comparing `landlab-2.7.0/tests/field/test_field_dataset.py` & `landlab-2.8.0/tests/field/test_field_dataset.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/field/test_graph_fields.py` & `landlab-2.8.0/tests/field/test_graph_fields.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 #! /usr/bin/env python
 import numpy as np
 import pytest
 from hypothesis import given
 from hypothesis.strategies import text
 from numpy.testing import assert_array_equal
 
-from landlab.field import FieldError, GroupError
+from landlab.field import FieldError
+from landlab.field import GroupError
 from landlab.field.graph_field import GraphFields as ModelDataFields
 
 
 def test_init():
     fields = ModelDataFields()
     assert set() == fields.groups
     # assert_set_equal(set(), fields.groups)
```

### Comparing `landlab-2.7.0/tests/graph/framed_voronoi/test_dual_framed_voronoi.py` & `landlab-2.8.0/tests/graph/framed_voronoi/test_dual_framed_voronoi.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/graph/framed_voronoi/test_framed_voronoi.py` & `landlab-2.8.0/tests/graph/framed_voronoi/test_framed_voronoi.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,22 +1,19 @@
 import numpy as np
 import pytest
 from hypothesis import given
-from hypothesis.strategies import integers, lists
-from numpy.testing import (
-    assert_array_almost_equal,
-    assert_array_equal,
-    assert_array_less,
-)
+from hypothesis.strategies import integers
+from hypothesis.strategies import lists
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
+from numpy.testing import assert_array_less
 from pytest import approx
 
-from landlab.graph.framed_voronoi.framed_voronoi import (
-    FramedVoronoiGraph,
-    HorizontalRectVoronoiGraph,
-)
+from landlab.graph.framed_voronoi.framed_voronoi import FramedVoronoiGraph
+from landlab.graph.framed_voronoi.framed_voronoi import HorizontalRectVoronoiGraph
 
 
 def test_number_of_nodes_horizontal_rect():
     assert HorizontalRectVoronoiGraph.number_of_nodes((1, 2)) == 2
     assert HorizontalRectVoronoiGraph.number_of_nodes((1, 3)) == 3
     assert HorizontalRectVoronoiGraph.number_of_nodes((2, 2)) == 4
     assert HorizontalRectVoronoiGraph.number_of_nodes((2, 3)) == 6
```

### Comparing `landlab-2.7.0/tests/graph/framed_voronoi/test_perimeter_nodes.py` & `landlab-2.8.0/tests/graph/framed_voronoi/test_perimeter_nodes.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/graph/hex/test_dual_hex.py` & `landlab-2.8.0/tests/graph/hex/test_dual_hex.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,12 @@
 """Test HexGraph and DualHexGraph."""
+
 import numpy as np
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 from pytest import approx
 
 from landlab.graph import DualHexGraph
 
 ROOT_3_OVER_2 = np.sqrt(3.0) * 0.5
```

### Comparing `landlab-2.7.0/tests/graph/hex/test_hex.py` & `landlab-2.8.0/tests/graph/hex/test_hex.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 import numpy as np
 import pytest
 from hypothesis import given
-from hypothesis.strategies import integers, lists
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from hypothesis.strategies import integers
+from hypothesis.strategies import lists
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 from pytest import approx
 
 from landlab.graph import TriGraph
-from landlab.graph.hex.hex import (
-    HorizontalHexTriGraph,
-    HorizontalRectTriGraph,
-    VerticalHexTriGraph,
-    VerticalRectTriGraph,
-)
+from landlab.graph.hex.hex import HorizontalHexTriGraph
+from landlab.graph.hex.hex import HorizontalRectTriGraph
+from landlab.graph.hex.hex import VerticalHexTriGraph
+from landlab.graph.hex.hex import VerticalRectTriGraph
 
 
 def test_number_of_nodes_horizontal_rect():
     assert HorizontalRectTriGraph.number_of_nodes((1, 2)) == 2
     assert HorizontalRectTriGraph.number_of_nodes((1, 3)) == 3
     assert HorizontalRectTriGraph.number_of_nodes((2, 2)) == 4
     assert HorizontalRectTriGraph.number_of_nodes((2, 3)) == 6
```

### Comparing `landlab-2.7.0/tests/graph/hex/test_perimeter_nodes.py` & `landlab-2.8.0/tests/graph/hex/test_perimeter_nodes.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,18 +1,16 @@
 #! /usr/bin/env python
 import numpy as np
 import pytest
 from numpy.testing import assert_array_equal
 
-from landlab.graph.hex.hex import (
-    HorizontalHexTriGraph,
-    HorizontalRectTriGraph,
-    VerticalHexTriGraph,
-    VerticalRectTriGraph,
-)
+from landlab.graph.hex.hex import HorizontalHexTriGraph
+from landlab.graph.hex.hex import HorizontalRectTriGraph
+from landlab.graph.hex.hex import VerticalHexTriGraph
+from landlab.graph.hex.hex import VerticalRectTriGraph
 
 
 @pytest.mark.parametrize(
     "n_cols", (1,) + tuple(np.random.randint(2, high=1000, size=5))
 )
 @pytest.mark.parametrize(
     "n_rows", (1,) + tuple(np.random.randint(2, high=1000, size=5))
```

### Comparing `landlab-2.7.0/tests/graph/radial/test_dual_radial.py` & `landlab-2.8.0/tests/graph/radial/test_dual_radial.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,12 @@
 """Test StructuredQuadGraph."""
+
 import numpy as np
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
 from landlab.graph import DualRadialGraph
 
 
 def test_create():
     """Test creating a quad graph."""
     graph = DualRadialGraph((1, 4))
```

### Comparing `landlab-2.7.0/tests/graph/sort/test_intpair.py` & `landlab-2.8.0/tests/graph/sort/test_intpair.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,14 @@
 import numpy as np
 from numpy.testing import assert_array_equal
 
 from landlab.graph.sort.ext.remap_element import offset_to_sorted_block
-from landlab.graph.sort.intpair import (
-    map_pairs_to_values,
-    map_rolling_pairs_to_values,
-    pair_isin,
-)
+from landlab.graph.sort.intpair import map_pairs_to_values
+from landlab.graph.sort.intpair import map_rolling_pairs_to_values
+from landlab.graph.sort.intpair import pair_isin
 
 
 def test_pair_isin_one_pair():
     src = np.asarray(
         [[0, 1], [1, 2], [2, 5], [5, 8], [8, 7], [7, 6], [6, 3], [3, 0]], dtype=int
     )
     pairs = np.asarray([[4, 8]], dtype=int)
```

### Comparing `landlab-2.7.0/tests/graph/sort/test_remap.py` & `landlab-2.8.0/tests/graph/sort/test_remap.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/graph/structured_quad/test_dual_quad.py` & `landlab-2.8.0/tests/graph/structured_quad/test_dual_quad.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 """Test StructuredQuadGraph."""
+
 from numpy.testing import assert_array_equal
 from pytest import approx
 
-from landlab.graph import DualStructuredQuadGraph, DualUniformRectilinearGraph
+from landlab.graph import DualStructuredQuadGraph
+from landlab.graph import DualUniformRectilinearGraph
 
 
 def test_create():
     """Test creating a quad graph."""
     y = [0, 1, 3, 0, 1, 3, 0, 1, 3]
     x = [3, 3, 3, 4, 4, 4, 6, 6, 6]
     graph = DualStructuredQuadGraph((y, x), shape=(3, 3))
```

### Comparing `landlab-2.7.0/tests/graph/structured_quad/test_quad.py` & `landlab-2.8.0/tests/graph/structured_quad/test_quad.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,20 @@
 """Test StructuredQuadGraph."""
+
 import numpy as np
 from numpy.testing import assert_array_equal
-from pytest import approx, mark, raises
+from pytest import approx
+from pytest import mark
+from pytest import raises
 
-from landlab.graph import RectilinearGraph, StructuredQuadGraph, UniformRectilinearGraph
-from landlab.graph.structured_quad.structured_quad import (
-    StructuredQuadLayoutCython,
-    StructuredQuadLayoutPython,
-)
+from landlab.graph import RectilinearGraph
+from landlab.graph import StructuredQuadGraph
+from landlab.graph import UniformRectilinearGraph
+from landlab.graph.structured_quad.structured_quad import StructuredQuadLayoutCython
+from landlab.graph.structured_quad.structured_quad import StructuredQuadLayoutPython
 
 
 def test_graph_is_frozen():
     graph = UniformRectilinearGraph((3, 4))
 
     assert_array_equal(
         graph.nodes_at_link,
```

### Comparing `landlab-2.7.0/tests/graph/test_graph.py` & `landlab-2.8.0/tests/graph/test_graph.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 import pytest
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
 from landlab.graph import Graph
 
 r"""
 For these tests the nodes are given column-by-column::
 
     (1) -- (3) --- (4)
```

### Comparing `landlab-2.7.0/tests/graph/voronoi/test_voronoi_to_graph.py` & `landlab-2.8.0/tests/graph/voronoi/test_voronoi_to_graph.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,17 @@
 import inspect
 
 import numpy as np
 import pytest
 from pytest import approx
-from scipy.spatial import Delaunay, Voronoi
+from scipy.spatial import Delaunay
+from scipy.spatial import Voronoi
 
-from landlab.graph.voronoi.voronoi_to_graph import (
-    VoronoiDelaunay,
-    VoronoiDelaunayToGraph,
-)
+from landlab.graph.voronoi.voronoi_to_graph import VoronoiDelaunay
+from landlab.graph.voronoi.voronoi_to_graph import VoronoiDelaunayToGraph
 
 XY_OF_NODE = {
     "rect-horizontal-3-3": [
         [0.0, 0.0],
         [1.0, 0.0],
         [2.0, 0.0],
         [0.5, 1.0],
@@ -192,30 +191,30 @@
     ids = []
     for name in hex_graph.ids_with_prefix(at):
         ids.append(np.sort(np.unique(getattr(hex_graph, name).reshape((-1,)))))
     ids = np.sort(np.unique(np.concatenate(ids)))
     ids = ids[ids >= 0]
 
     assert ids[0] >= 0
-    assert ids[-1] <= hex_graph._mesh.dims[at]
+    assert ids[-1] <= hex_graph._mesh.sizes[at]
 
 
 @pytest.mark.parametrize("at", ("node", "link", "cell", "corner", "face", "cell"))
 def test_compact_ids_with_perimeter_nodes(xy_of_hex, at):
     perimeter_links = [[0, 1], [1, 2], [2, 5], [5, 8], [8, 7], [7, 6], [6, 3], [3, 0]]
     graph = VoronoiDelaunayToGraph(xy_of_hex, perimeter_links=perimeter_links)
 
     ids = []
     for name in graph.ids_with_prefix(at):
         ids.append(np.sort(np.unique(getattr(graph, name).reshape((-1,)))))
     ids = np.sort(np.unique(np.concatenate(ids)))
     ids = ids[ids >= 0]
 
     assert ids[0] >= 0
-    assert ids[-1] <= graph._mesh.dims[at]
+    assert ids[-1] <= graph._mesh.sizes[at]
 
 
 @pytest.mark.parametrize("at", ["node", "link", "patch", "corner", "face", "cell"])
 def test_has_prefix(hex_graph, at):
     expected = {
         "node": ("nodes_at_patch", "nodes_at_face", "node_at_cell", "nodes_at_link"),
         "link": ("links_at_patch",),
```

### Comparing `landlab-2.7.0/tests/grid/conftest.py` & `landlab-2.8.0/tests/grid/conftest.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_constructors.py` & `landlab-2.8.0/tests/grid/test_constructors.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,20 @@
 from io import StringIO
 
 import numpy as np
 import pytest
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
-from landlab import (
-    FramedVoronoiGrid,
-    HexModelGrid,
-    NetworkModelGrid,
-    RadialModelGrid,
-    RasterModelGrid,
-    VoronoiDelaunayGrid,
-)
+from landlab import FramedVoronoiGrid
+from landlab import HexModelGrid
+from landlab import NetworkModelGrid
+from landlab import RadialModelGrid
+from landlab import RasterModelGrid
+from landlab import VoronoiDelaunayGrid
 
 
 def test_raster_from_file():
     file_strn = (
         "shape:\n"
         "    - 10\n"
         "    - 20\n"
```

### Comparing `landlab-2.7.0/tests/grid/test_create/test-netcdf4.nc` & `landlab-2.8.0/tests/grid/test_create/test-netcdf4.nc`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_create.py` & `landlab-2.8.0/tests/grid/test_create.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,26 +1,27 @@
 from collections import OrderedDict
 from io import StringIO
 
 import numpy as np
 import pytest
 from hypothesis import given
 from hypothesis.strategies import text
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
-from landlab import HexModelGrid, RadialModelGrid, RasterModelGrid
-from landlab.grid.create import (
-    _parse_args_kwargs,
-    add_boundary_conditions,
-    add_field_from_function,
-    as_list_of_tuples,
-    create_grid,
-    grid_from_dict,
-    norm_grid_description,
-)
+from landlab import HexModelGrid
+from landlab import RadialModelGrid
+from landlab import RasterModelGrid
+from landlab.grid.create import _parse_args_kwargs
+from landlab.grid.create import add_boundary_conditions
+from landlab.grid.create import add_field_from_function
+from landlab.grid.create import as_list_of_tuples
+from landlab.grid.create import create_grid
+from landlab.grid.create import grid_from_dict
+from landlab.grid.create import norm_grid_description
 
 SIMPLE_PARAMS_STR = """
 grid:
   RasterModelGrid:
     args: [[4, 5]]
     xy_spacing: [3, 4]
     fields:
```

### Comparing `landlab-2.7.0/tests/grid/test_create_network.py` & `landlab-2.8.0/tests/grid/test_create_network.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,36 +1,37 @@
 import hypothesis.extra.numpy as hynp
 import numpy as np
 import pytest
 from hypothesis import given
-from hypothesis.strategies import composite, floats, integers, lists
+from hypothesis.strategies import composite
+from hypothesis.strategies import floats
+from hypothesis.strategies import integers
+from hypothesis.strategies import lists
 from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
-from landlab.grid.create_network import (
-    AlongChannelSpacingAtLeast,
-    AtMostNodes,
-    ChannelSegment,
-    ChannelSegmentConnector,
-    JustEndNodes,
-    SegmentLinkCollector,
-    SegmentNodeCoordinateCollector,
-    SegmentNodeReindexer,
-    SpacingAtLeast,
-    _reduce_nodes,
-    _reduce_to_fewest_nodes,
-    create_network_links,
-    create_xy_of_node,
-    get_node_fields,
-    network_grid_from_raster,
-    network_grid_from_segments,
-    pairwise,
-    reindex_network_nodes,
-    spacing_from_drainage_area,
-)
+from landlab.grid.create_network import AlongChannelSpacingAtLeast
+from landlab.grid.create_network import AtMostNodes
+from landlab.grid.create_network import ChannelSegment
+from landlab.grid.create_network import ChannelSegmentConnector
+from landlab.grid.create_network import JustEndNodes
+from landlab.grid.create_network import SegmentLinkCollector
+from landlab.grid.create_network import SegmentNodeCoordinateCollector
+from landlab.grid.create_network import SegmentNodeReindexer
+from landlab.grid.create_network import SpacingAtLeast
+from landlab.grid.create_network import _reduce_nodes
+from landlab.grid.create_network import _reduce_to_fewest_nodes
+from landlab.grid.create_network import create_network_links
+from landlab.grid.create_network import create_xy_of_node
+from landlab.grid.create_network import get_node_fields
+from landlab.grid.create_network import network_grid_from_raster
+from landlab.grid.create_network import network_grid_from_segments
+from landlab.grid.create_network import pairwise
+from landlab.grid.create_network import reindex_network_nodes
+from landlab.grid.create_network import spacing_from_drainage_area
 
 
 @given(
     drainage_area=hynp.arrays(
         dtype=hynp.floating_dtypes(),
         shape=hynp.array_shapes(),
         elements=floats(min_value=0, width=16),
```

### Comparing `landlab-2.7.0/tests/grid/test_diagonals.py` & `landlab-2.8.0/tests/grid/test_diagonals.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_framed_voronoi_grid/test_edges.py` & `landlab-2.8.0/tests/grid/test_framed_voronoi_grid/test_edges.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_framed_voronoi_grid/test_link_order.py` & `landlab-2.8.0/tests/grid/test_framed_voronoi_grid/test_link_order.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_framed_voronoi_grid/test_links.py` & `landlab-2.8.0/tests/grid/test_framed_voronoi_grid/test_links.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_framed_voronoi_grid/test_nodes_.py` & `landlab-2.8.0/tests/grid/test_framed_voronoi_grid/test_nodes_.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_framed_voronoi_grid/test_patches.py` & `landlab-2.8.0/tests/grid/test_framed_voronoi_grid/test_patches.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_grid_reference.py` & `landlab-2.8.0/tests/grid/test_grid_reference.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 import numpy as np
 import pytest
 from pytest import approx
 
-from landlab import HexModelGrid, RadialModelGrid, RasterModelGrid
+from landlab import HexModelGrid
+from landlab import RadialModelGrid
+from landlab import RasterModelGrid
 
 
 def test_xy_of_reference_default_is_zero():
     grid = RasterModelGrid((9, 5))
     assert grid.xy_of_reference == approx((0.0, 0.0))
```

### Comparing `landlab-2.7.0/tests/grid/test_hex_grid/test_edges.py` & `landlab-2.8.0/tests/grid/test_hex_grid/test_edges.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_hex_grid/test_flux_divergence_hex_grid.py` & `landlab-2.8.0/tests/grid/test_hex_grid/test_flux_divergence_hex_grid.py`

 * *Files 0% similar despite different names*

```diff
@@ -31,14 +31,15 @@
 AND CELL AREAS SEEMS TO BE BROKEN...
 RELATES TO THE NEED TO IDENTIFY PERIMETER NODES IN A VORONOI GRID.
 IN A RECTANGULAR RASTER, NODES WITH CELLS ARE EASY TO IDENTIFY.
 IN A HEX-SHAPED OR RECTANGULAR HEX, SLIGHTLY MORE COMPLICATED BUT NOT TOO BAD.
 IN A GENERAL VORONOI...??
 FIRST THING PROBABLY IS TO FIX LINK_AT_FACE FOR RASTER, THEN IMPLEMENT FOR HEX.
 """
+
 import numpy as np
 from numpy.testing import assert_array_equal
 
 from landlab import HexModelGrid
 
 MAX_NUM_LINKS = 6
```

### Comparing `landlab-2.7.0/tests/grid/test_hex_grid/test_link_order.py` & `landlab-2.8.0/tests/grid/test_hex_grid/test_link_order.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """
 Created on Sat Nov 14 10:36:03 2015
 
 @author: gtucker
 """
+
 import numpy as np
 from numpy.testing import assert_array_equal
 from pytest import approx
 
 from landlab import HexModelGrid
```

### Comparing `landlab-2.7.0/tests/grid/test_hex_grid/test_links.py` & `landlab-2.8.0/tests/grid/test_hex_grid/test_links.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_hex_grid/test_nodes.py` & `landlab-2.8.0/tests/grid/test_hex_grid/test_nodes.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_hex_grid/test_patches.py` & `landlab-2.8.0/tests/grid/test_hex_grid/test_patches.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_hex_mappers.py` & `landlab-2.8.0/tests/grid/test_hex_mappers.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_mappers.py` & `landlab-2.8.0/tests/grid/test_mappers.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 import numpy as np
 import pytest
 from numpy.testing import assert_array_almost_equal
 
-from landlab import HexModelGrid, RasterModelGrid
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.grid.mappers import map_upwind_node_link_max_to_node
 
 
 def test_map_upwind_node_link_max_to_node():
     grid = RasterModelGrid((3, 4))
 
     grid.at_link["grad"] = (
```

### Comparing `landlab-2.7.0/tests/grid/test_radial_grid/test_nodes.py` & `landlab-2.8.0/tests/grid/test_radial_grid/test_nodes.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_funcs/test_best_fit_plane.py` & `landlab-2.8.0/tests/grid/test_raster_funcs/test_best_fit_plane.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_funcs/test_find_nearest_node.py` & `landlab-2.8.0/tests/grid/test_raster_funcs/test_find_nearest_node.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_funcs/test_gradients_across_cell_corners.py` & `landlab-2.8.0/tests/grid/test_raster_funcs/test_gradients_across_cell_corners.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_funcs/test_gradients_across_cell_faces.py` & `landlab-2.8.0/tests/grid/test_raster_funcs/test_gradients_across_cell_faces.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_funcs/test_gradients_at_active_links.py` & `landlab-2.8.0/tests/grid/test_raster_funcs/test_gradients_at_active_links.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_funcs/test_gradients_at_links.py` & `landlab-2.8.0/tests/grid/test_raster_funcs/test_gradients_at_links.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_funcs/test_is_on_grid.py` & `landlab-2.8.0/tests/grid/test_raster_funcs/test_is_on_grid.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_funcs/test_line_to_grid_coords.py` & `landlab-2.8.0/tests/grid/test_raster_funcs/test_line_to_grid_coords.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_funcs/test_node_id_of_adjacent.py` & `landlab-2.8.0/tests/grid/test_raster_funcs/test_node_id_of_adjacent.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_gradients.py` & `landlab-2.8.0/tests/grid/test_raster_gradients.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 import numpy as np
 import pytest
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
-from landlab.grid.gradients import (
-    calc_diff_at_link as calc_diff_at_link_slow,
-    calc_grad_at_link as calc_grad_at_link_slow,
-)
-from landlab.grid.raster_gradients import calc_diff_at_link, calc_grad_at_link
+from landlab.grid.gradients import calc_diff_at_link as calc_diff_at_link_slow
+from landlab.grid.gradients import calc_grad_at_link as calc_grad_at_link_slow
+from landlab.grid.raster_gradients import calc_diff_at_link
+from landlab.grid.raster_gradients import calc_grad_at_link
 
 
 @pytest.mark.benchmark(group="calc_diff_at_link")
 @pytest.mark.parametrize(
     "func",
     [calc_diff_at_link, calc_diff_at_link_slow],
     ids=["raster-specific", "general"],
```

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_allocators.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_allocators.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_axis_methods.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_axis_methods.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_bc_updates.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_bc_updates.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import numpy as np
 from numpy.testing import assert_array_equal
 
-from landlab import LinkStatus, RasterModelGrid
+from landlab import LinkStatus
+from landlab import RasterModelGrid
 
 
 def test_issue_428_a():
     """Issue #428"""
     grid = RasterModelGrid((4, 4))
     grid.set_closed_boundaries_at_grid_edges(True, True, True, True)
```

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_cell_areas.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_cell_areas.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_corners.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_corners.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_faces.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_faces.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_fields.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_fields.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_fixed_link_boundary.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_fixed_link_boundary.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import numpy as np
 from numpy.testing import assert_array_equal
 
-from landlab import NodeStatus, RasterModelGrid
+from landlab import NodeStatus
+from landlab import RasterModelGrid
 
 FG = NodeStatus.FIXED_GRADIENT
 CB = NodeStatus.CLOSED
 FV = NodeStatus.FIXED_VALUE
 
 
 def test_fixed_link_boundaries_at_grid_edges():
```

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_has_boundary_neighbor.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_has_boundary_neighbor.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_init.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_init.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_is_boundary.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_is_boundary.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import numpy as np
 from numpy.testing import assert_array_equal
 
-from landlab import NodeStatus, RasterModelGrid
+from landlab import NodeStatus
+from landlab import RasterModelGrid
 
 
 def test_id_as_int():
     rmg = RasterModelGrid((4, 5))
     assert rmg.node_is_boundary(0)
```

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_link_length.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_link_length.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_link_order.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_link_order.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """
 Created on Sat Nov 14 10:48:23 2015
 
 @author: gtucker
 """
+
 import numpy as np
 from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
 
 
 def test_link_order():
```

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_mappers.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_mappers.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_neighbor_nodes.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_neighbor_nodes.py`

 * *Files 0% similar despite different names*

```diff
@@ -109,17 +109,17 @@
 
 
 def test_active_neighbor_list_boundary():
     """All of the neighbor IDs for a boundary cell are -1."""
     rmg = RasterModelGrid((5, 4))
     import landlab.utils.structured_grid as sgrid
 
-    rmg.status_at_node[
-        (0, 1, 2, 3, 4, 7, 8, 11, 12, 15, 16, 17, 18, 19),
-    ] = rmg.BC_NODE_IS_CLOSED
+    rmg.status_at_node[(0, 1, 2, 3, 4, 7, 8, 11, 12, 15, 16, 17, 18, 19),] = (
+        rmg.BC_NODE_IS_CLOSED
+    )
 
     for node_id in sgrid.perimeter_iter(rmg.shape):
         assert_array_equal(
             rmg.active_adjacent_nodes_at_node[node_id], np.array([X, X, X, X])
         )
```

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_nodes.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_nodes.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_nodes_around_point.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_nodes_around_point.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_patches.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_patches.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 import numpy as np
-from pytest import approx, raises
+from pytest import approx
+from pytest import raises
 
 from landlab import RasterModelGrid
 
 
 class TestPatchesAtNode:
     patch_values = np.array(
         [
```

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_save.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_save.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/test_raster_grid/test_status_at_node.py` & `landlab-2.8.0/tests/grid/test_raster_grid/test_status_at_node.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import numpy as np
 from numpy.testing import assert_array_equal
 
-from landlab import NodeStatus, RasterModelGrid
+from landlab import NodeStatus
+from landlab import RasterModelGrid
 
 CB = NodeStatus.CLOSED
 FV = NodeStatus.FIXED_VALUE
 
 
 def test_get_status():
     """Test getting the node status array."""
```

### Comparing `landlab-2.7.0/tests/grid/test_voronoi.py` & `landlab-2.8.0/tests/grid/test_voronoi.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/grid/unstructured/test_links.py` & `landlab-2.8.0/tests/grid/unstructured/test_links.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,13 @@
 import pytest
 from numpy.testing import assert_array_equal
 
-from landlab.grid.unstructured.links import (
-    in_link_ids_at_node,
-    link_ids_at_node,
-    out_link_ids_at_node,
-)
+from landlab.grid.unstructured.links import in_link_ids_at_node
+from landlab.grid.unstructured.links import link_ids_at_node
+from landlab.grid.unstructured.links import out_link_ids_at_node
 
 
 def test_array_length_mismatch():
     with pytest.raises(ValueError):
         link_ids_at_node(([0, 1, 2, 3, 4, 5], [3, 4, 5, 6, 7]))
```

### Comparing `landlab-2.7.0/tests/io/netcdf/test_from_netcdf/test-HexModelGrid.nc` & `landlab-2.8.0/tests/io/netcdf/test_from_netcdf/test-HexModelGrid.nc`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/io/netcdf/test_from_netcdf/test-RadialModelGrid.nc` & `landlab-2.8.0/tests/io/netcdf/test_from_netcdf/test-RadialModelGrid.nc`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/io/netcdf/test_from_netcdf/test-RasterModelGrid.nc` & `landlab-2.8.0/tests/io/netcdf/test_from_netcdf/test-RasterModelGrid.nc`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/io/netcdf/test_from_netcdf.py` & `landlab-2.8.0/tests/io/netcdf/test_from_netcdf.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 import pytest
 from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
-from landlab.io.netcdf import from_netcdf, to_netcdf
+from landlab.io.netcdf import from_netcdf
+from landlab.io.netcdf import to_netcdf
 
 
 @pytest.mark.parametrize("include", ((), [], set(), None))
 def test_include_keyword_is_empty(tmpdir, format, include):
     grid = RasterModelGrid((4, 3), xy_spacing=(2, 5), xy_of_lower_left=(-2.0, 10.0))
     grid.add_ones("elev", at="node")
     grid.add_zeros("elev", at="link")
```

### Comparing `landlab-2.7.0/tests/io/netcdf/test_read_netcdf/test-netcdf3-64bit.nc` & `landlab-2.8.0/tests/io/netcdf/test_read_netcdf/test-netcdf3-64bit.nc`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/io/netcdf/test_read_netcdf/test-netcdf4.nc` & `landlab-2.8.0/tests/io/netcdf/test_read_netcdf/test-netcdf4.nc`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/io/netcdf/test_read_netcdf.py` & `landlab-2.8.0/tests/io/netcdf/test_read_netcdf.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,19 +2,17 @@
 """Unit tests for landlab.io.netcdf module."""
 
 
 import pytest
 from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
-from landlab.io import (
-    MismatchGridDataSizeError,
-    MismatchGridXYLowerLeft,
-    MismatchGridXYSpacing,
-)
+from landlab.io import MismatchGridDataSizeError
+from landlab.io import MismatchGridXYLowerLeft
+from landlab.io import MismatchGridXYSpacing
 from landlab.io.netcdf import read_netcdf
 
 grid_mapping_keys = [
     "grid_mapping_name",
     "longitude_of_central_meridian",
     "false_easting",
     "false_northing",
```

### Comparing `landlab-2.7.0/tests/io/netcdf/test_to_netcdf.py` & `landlab-2.8.0/tests/io/netcdf/test_to_netcdf.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,18 @@
 #! /usr/bin/env python
 """Unit tests for landlab.io.netcdf module."""
 import numpy as np
 import pytest
 import xarray as xr
 from numpy.testing import assert_array_equal
 
-from landlab import HexModelGrid, RasterModelGrid
-from landlab.io.netcdf import from_netcdf, to_netcdf
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
+from landlab.io.netcdf import from_netcdf
+from landlab.io.netcdf import to_netcdf
 
 
 def test_netcdf_write_int64(tmpdir, format):
     grid = RasterModelGrid((4, 3))
     grid.add_field("topographic__elevation", np.arange(12, dtype=np.int64), at="node")
 
     with tmpdir.as_cwd():
@@ -126,24 +128,24 @@
 @pytest.mark.parametrize("mode", ("w", "a"))
 def test_with_and_without_time(tmpdir, format, mode):
     grid = RasterModelGrid((3, 4))
     grid.add_full("elevation", 1.0, at="node")
     with tmpdir.as_cwd():
         to_netcdf(grid, "test-without-time.nc", format=format, mode=mode)
         with xr.open_dataset("test-without-time.nc") as actual:
-            assert "time" not in actual.dims
+            assert "time" not in actual.sizes
             assert "time" not in actual.variables
-            assert actual["at_node:elevation"].dims == ("node",)
+            assert tuple(actual["at_node:elevation"].sizes) == ("node",)
 
         to_netcdf(grid, "test-with-time.nc", format=format, time=10.0, mode=mode)
         with xr.open_dataset("test-with-time.nc") as actual:
-            assert "time" in actual.dims
+            assert "time" in actual.sizes
             assert "time" in actual.variables
             assert actual["time"] == [10.0]
-            assert actual["at_node:elevation"].dims == ("time", "node")
+            assert tuple(actual["at_node:elevation"].sizes) == ("time", "node")
 
 
 @pytest.mark.parametrize("mode", ("w", "a"))
 @pytest.mark.parametrize("time0", [None, 10.0])
 @pytest.mark.parametrize("time1", [None, 100.0])
 def test_append_with_and_without_time(tmpdir, format, mode, time0, time1):
     grid = RasterModelGrid((3, 4))
@@ -151,15 +153,15 @@
     with tmpdir.as_cwd():
         to_netcdf(grid, "test.nc", format=format, mode=mode, time=time0)
         to_netcdf(grid, "test.nc", format=format, mode="a", time=time1)
 
         time0 = np.nan if time0 is None else time0
 
         with xr.open_dataset("test.nc") as actual:
-            assert "time" in actual.dims
+            assert "time" in actual.sizes
             assert "time" in actual.variables
             assert_array_equal(
                 actual["time"],
                 [
                     np.nan if time0 is None else time0,
                     time0 + 1 if time1 is None else time1,
                 ],
```

### Comparing `landlab-2.7.0/tests/io/netcdf/test_write_netcdf.py` & `landlab-2.8.0/tests/io/netcdf/test_write_netcdf.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,15 +4,16 @@
 
 import netCDF4 as nc
 import numpy as np
 import pytest
 from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
-from landlab.io.netcdf import NotRasterGridError, write_netcdf
+from landlab.io.netcdf import NotRasterGridError
+from landlab.io.netcdf import write_netcdf
 from landlab.io.netcdf.read import _get_raster_spacing
 
 _TEST_DATA_DIR = os.path.join(os.path.dirname(__file__), "data")
 
 
 def test_netcdf_write_int64_field_netcdf4(tmpdir):
     """Test write_netcdf with a grid that has an int64 field."""
```

### Comparing `landlab-2.7.0/tests/io/netcdf/test_write_raster_netcdf.py` & `landlab-2.8.0/tests/io/netcdf/test_write_raster_netcdf.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/io/shapefile/test_infer_dtype.py` & `landlab-2.8.0/tests/io/test_shapefile_infer_dtype.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 import hypothesis.extra.numpy as hynp
 import numpy as np
 import pytest
-from hypothesis import assume, given
+from hypothesis import assume
+from hypothesis import given
 from hypothesis.strategies import integers
 from numpy.testing import assert_array_equal
 
-from landlab.io.shapefile.read_shapefile import _infer_data_type
+from landlab.io.shapefile import _infer_data_type
 
 
 @pytest.mark.parametrize("src_type", [np.int32, np.int64, float, bool])
 @pytest.mark.parametrize("as_iterable", [list, tuple, np.asarray])
 def test_infer_dtype(as_iterable, src_type):
     values = np.asarray([1, 2, 3], dtype=src_type)
     array = _infer_data_type(as_iterable(values))
```

### Comparing `landlab-2.7.0/tests/io/shapefile/test_read_shapefile.py` & `landlab-2.8.0/tests/io/test_shapefile.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,18 @@
 from io import BytesIO
 
 import numpy as np
 import pytest
 import shapefile
 from numpy.testing import assert_array_equal
-from pytest import approx, raises
-from shapefile import POINT, POLYLINE, ShapefileException
+from pytest import approx
+from pytest import raises
+from shapefile import POINT
+from shapefile import POLYLINE
+from shapefile import ShapefileException
 
 from landlab import ExampleData
 from landlab.io.shapefile import read_shapefile
 
 
 def test_read_methow(tmpdir):
     # test of the big methow network.
```

### Comparing `landlab-2.7.0/tests/io/test_read_esri_ascii/hugo_site.asc` & `landlab-2.8.0/tests/io/test_read_esri_ascii/hugo_site.asc`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/io/test_read_esri_ascii.py` & `landlab-2.8.0/tests/io/test_read_esri_ascii.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,29 +2,28 @@
 """
 Unit tests for landlab.io.esri_ascii module.
 """
 from io import StringIO
 
 import numpy as np
 import pytest
-from numpy.testing import assert_array_almost_equal, assert_array_equal
+from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
-from landlab.io import (
-    BadHeaderLineError,
-    DataSizeError,
-    KeyTypeError,
-    KeyValueError,
-    MismatchGridDataSizeError,
-    MismatchGridXYLowerLeft,
-    MismatchGridXYSpacing,
-    MissingRequiredKeyError,
-    read_asc_header,
-    read_esri_ascii,
-)
+from landlab.io import BadHeaderLineError
+from landlab.io import DataSizeError
+from landlab.io import KeyTypeError
+from landlab.io import KeyValueError
+from landlab.io import MismatchGridDataSizeError
+from landlab.io import MismatchGridXYLowerLeft
+from landlab.io import MismatchGridXYSpacing
+from landlab.io import MissingRequiredKeyError
+from landlab.io import read_asc_header
+from landlab.io import read_esri_ascii
 
 
 def test_hugo_read_file_name(datadir):
     (grid, field) = read_esri_ascii(datadir / "hugo_site.asc")
 
     assert isinstance(grid, RasterModelGrid)
```

### Comparing `landlab-2.7.0/tests/io/test_read_write_native.py` & `landlab-2.8.0/tests/io/test_read_write_native.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,18 @@
 #! /usr/bin/env python
 import os
 import pickle
 
 from numpy.testing import assert_array_equal
 
-from landlab import HexModelGrid, RasterModelGrid
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.components import FlowAccumulator
-from landlab.io.native_landlab import load_grid, save_grid
+from landlab.io.native_landlab import load_grid
+from landlab.io.native_landlab import save_grid
 
 
 def compare_dictionaries(dict_1, dict_2, dict_1_name, dict_2_name, path=""):
     """Compare two dictionaries recursively to find non mathcing elements
 
     Args:
         dict_1: dictionary 1
```

### Comparing `landlab-2.7.0/tests/io/test_write_esri_ascii.py` & `landlab-2.8.0/tests/io/test_write_esri_ascii.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,15 +2,16 @@
 import os
 
 import numpy as np
 import pytest
 from numpy.testing import assert_array_almost_equal
 
 from landlab import RasterModelGrid
-from landlab.io import read_esri_ascii, write_esri_ascii
+from landlab.io import read_esri_ascii
+from landlab.io import write_esri_ascii
 
 _TEST_DATA_DIR = os.path.join(os.path.dirname(__file__), "data")
 
 
 def test_write_esri_ascii_doctest_one_var(tmpdir):
     grid = RasterModelGrid((4, 5), xy_spacing=(2.0, 2.0))
     grid.at_node["air__temperature"] = np.arange(20.0)
```

### Comparing `landlab-2.7.0/tests/io/test_write_obj.py` & `landlab-2.8.0/tests/io/test_write_obj.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 #!/usr/bin/env python3
 
 """unit tests for landlab.io.obj module"""
 import pathlib
 
 import pytest
 
-from landlab import HexModelGrid, RasterModelGrid
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.io import write_obj
 
 LITTLE_HEX_OBJ = """# landlabgrid
 #
 g landlabgrid
 v 1.0 0.0 0.0
 v 3.0 0.0 0.0
```

### Comparing `landlab-2.7.0/tests/layers/test_event_layers.py` & `landlab-2.8.0/tests/layers/test_event_layers.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 import numpy as np
 import pytest
 from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
 from landlab.layers import EventLayers
-from landlab.layers.eventlayers import _BlockSlice, _valid_keywords_or_raise
+from landlab.layers.eventlayers import _BlockSlice
+from landlab.layers.eventlayers import _valid_keywords_or_raise
 
 
 def test_EventLayersMixIn():
     grid = RasterModelGrid((4, 4))
     assert hasattr(grid, "event_layers")
     assert grid.event_layers.number_of_layers == 0
     assert grid.event_layers.number_of_stacks == 4
```

### Comparing `landlab-2.7.0/tests/layers/test_material_layers.py` & `landlab-2.8.0/tests/layers/test_material_layers.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/plot/network_sediment_transporter/conftest.py` & `landlab-2.8.0/tests/plot/network_sediment_transporter/conftest.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 import numpy as np
 import pytest
 
 from landlab import ExampleData
-from landlab.components import FlowDirectorSteepest, NetworkSedimentTransporter
+from landlab.components import FlowDirectorSteepest
+from landlab.components import NetworkSedimentTransporter
 from landlab.data_record import DataRecord
 from landlab.grid.network import NetworkModelGrid
 from landlab.io import read_shapefile
 
 
 @pytest.fixture()
 def synthetic():
```

### Comparing `landlab-2.7.0/tests/plot/network_sediment_transporter/test_plot_network_and_parcels.py` & `landlab-2.8.0/tests/plot/network_sediment_transporter/test_plot_network_and_parcels.py`

 * *Files 0% similar despite different names*

```diff
@@ -102,15 +102,15 @@
 @pytest.mark.parametrize(
     "arg", ["synthetic", pytest.param("methow", marks=pytest.mark.slow)]
 )
 def test_with_filter(arg, request):
     nst = request.getfixturevalue(arg)
     grid = nst.grid
     parcels = nst._parcels
-    parcel_filter = np.zeros((parcels.dataset.dims["item_id"]), dtype=bool)
+    parcel_filter = np.zeros((parcels.dataset.sizes["item_id"]), dtype=bool)
     parcel_filter[::10] = True
     plot_network_and_parcels(
         grid,
         parcels,
         parcel_time_index=0,
         parcel_filter=parcel_filter,
         link_attribute="sediment_total_volume",
```

### Comparing `landlab-2.7.0/tests/plot/test_drainage_plot.py` & `landlab-2.8.0/tests/plot/test_drainage_plot.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/plot/test_event_handler.py` & `landlab-2.8.0/tests/plot/test_event_handler.py`

 * *Files 8% similar despite different names*

```diff
@@ -4,15 +4,16 @@
 
 @author: njlyons
 """
 from matplotlib.backend_bases import Event
 from matplotlib.pyplot import gcf
 from numpy.testing import assert_equal
 
-from landlab import RasterModelGrid, imshow_grid
+from landlab import RasterModelGrid
+from landlab import imshow_grid
 from landlab.plot.event_handler import query_grid_on_button_press
 
 
 def test_query_grid_on_button_press():
     rmg = RasterModelGrid((5, 5))
     imshow_grid(rmg, rmg.nodes, cmap="RdYlBu")
```

### Comparing `landlab-2.7.0/tests/plot/test_graph.py` & `landlab-2.8.0/tests/plot/test_graph.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import pytest
 
 from landlab import RasterModelGrid
-from landlab.plot.graph import _parse_locations_as_set, plot_graph
+from landlab.plot.graph import _parse_locations_as_set
+from landlab.plot.graph import plot_graph
 
 
 def _axes_arrows(ax):
     from matplotlib.patches import FancyArrow
 
     return [child for child in ax.get_children() if isinstance(child, FancyArrow)]
```

### Comparing `landlab-2.7.0/tests/plot/test_imshow_grid.py` & `landlab-2.8.0/tests/plot/test_imshow_grid.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 import matplotlib.pyplot as plt
 import numpy as np
 import pytest
 from matplotlib.backends.backend_pdf import PdfPages
 
 import landlab
-from landlab.plot.imshow import _guess_location_from_name, _guess_location_from_size
+from landlab.plot.imshow import _guess_location_from_name
+from landlab.plot.imshow import _guess_location_from_size
 
 
 @pytest.mark.slow
 def test_imshow_grid():
     rmg = landlab.RasterModelGrid((4, 5))
 
     pp = PdfPages("test.pdf")
```

### Comparing `landlab-2.7.0/tests/plot/test_layers.py` & `landlab-2.8.0/tests/plot/test_layers.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,18 +1,17 @@
 import hypothesis.extra.numpy as hynp
 import pytest
 from hypothesis import given
-from hypothesis.strategies import floats, integers
+from hypothesis.strategies import floats
+from hypothesis.strategies import integers
 from numpy.testing import assert_array_equal
 
-from landlab.plot.layers import (
-    _insert_shorelines,
-    _interp_zero_crossings,
-    _search_zero_crossings,
-)
+from landlab.plot.layers import _insert_shorelines
+from landlab.plot.layers import _interp_zero_crossings
+from landlab.plot.layers import _search_zero_crossings
 
 
 @given(
     y=hynp.arrays(
         dtype=hynp.floating_dtypes(),
         shape=8,
         elements=floats(0, 1, width=16, exclude_min=False),
```

### Comparing `landlab-2.7.0/tests/utils/test_count_repeats.py` & `landlab-2.8.0/tests/utils/test_count_repeats.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/utils/test_distance_from_divide.py` & `landlab-2.8.0/tests/utils/test_distance_from_divide.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 import numpy as np
 import pytest
 
-from landlab import FieldError, RasterModelGrid
-from landlab.components import FlowAccumulator, FlowDirectorSteepest
+from landlab import FieldError
+from landlab import RasterModelGrid
+from landlab.components import FlowAccumulator
+from landlab.components import FlowDirectorSteepest
 from landlab.utils.distance_to_divide import calculate_distance_to_divide
 
 
 def test_no_flow_receivers():
     """Test that correct error is raised when no flow recievers are
     on the grid."""
     mg = RasterModelGrid((30, 70))
```

### Comparing `landlab-2.7.0/tests/utils/test_flow__distance.py` & `landlab-2.8.0/tests/utils/test_flow__distance.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,19 @@
 import math
 
 import numpy as np
 import pytest
-from numpy.testing import assert_almost_equal, assert_array_equal
+from numpy.testing import assert_almost_equal
+from numpy.testing import assert_array_equal
 
-from landlab import FieldError, HexModelGrid, RasterModelGrid
-from landlab.components import FlowAccumulator, FlowDirectorSteepest
+from landlab import FieldError
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
+from landlab.components import FlowAccumulator
+from landlab.components import FlowDirectorSteepest
 from landlab.utils.flow__distance import calculate_flow__distance
 
 
 def test_no_flow_receivers():
     """Test that correct error is raised when no flow recievers are
     on the grid."""
```

### Comparing `landlab-2.7.0/tests/utils/test_halo.py` & `landlab-2.8.0/tests/utils/test_halo.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/utils/test_matrix.py` & `landlab-2.8.0/tests/utils/test_matrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 import numpy as np
 import pytest
 from numpy.testing import assert_array_equal
 
-from landlab import HexModelGrid, RasterModelGrid
+from landlab import HexModelGrid
+from landlab import RasterModelGrid
 from landlab.utils import get_core_node_matrix
 
 
 @pytest.mark.parametrize("diff", (-1, 1))
 def test_bad_value_at_node(diff):
     grid = RasterModelGrid((5, 6))
     value_at_node = np.full(grid.number_of_nodes + diff, 1.0)
```

### Comparing `landlab-2.7.0/tests/utils/test_neighbor_node_array.py` & `landlab-2.8.0/tests/utils/test_neighbor_node_array.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/utils/test_return_grid.py` & `landlab-2.8.0/tests/utils/test_return_grid.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 import numpy as np
 import pytest
 
-from landlab import FieldError, RasterModelGrid
-from landlab.utils.return_array import return_array_at_link, return_array_at_node
+from landlab import FieldError
+from landlab import RasterModelGrid
+from landlab.utils.return_array import return_array_at_link
+from landlab.utils.return_array import return_array_at_node
 
 
 def test_no_field():
     mg = RasterModelGrid((10, 10))
     with pytest.raises(FieldError):
         return_array_at_node(mg, "spam")
     with pytest.raises(FieldError):
```

### Comparing `landlab-2.7.0/tests/utils/test_source_tracking_algorithm.py` & `landlab-2.8.0/tests/utils/test_source_tracking_algorithm.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,15 +4,16 @@
 """
 
 import numpy as np
 import pytest
 
 from landlab import RasterModelGrid
 from landlab.components import FlowAccumulator
-from landlab.utils import find_unique_upstream_hsd_ids_and_fractions, track_source
+from landlab.utils import find_unique_upstream_hsd_ids_and_fractions
+from landlab.utils import track_source
 
 
 def test_route_to_multiple_error_raised():
     grid = RasterModelGrid((5, 5), xy_spacing=(1.0, 1.0))
     grid.at_node["topographic__elevation"] = [
         [5.0, 5.0, 5.0, 5.0, 5.0],
         [5.0, 4.0, 5.0, 1.0, 5.0],
```

### Comparing `landlab-2.7.0/tests/utils/test_stable_priority_queue.py` & `landlab-2.8.0/tests/utils/test_stable_priority_queue.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/utils/test_structured_grid.py` & `landlab-2.8.0/tests/utils/test_structured_grid.py`

 * *Files identical despite different names*

### Comparing `landlab-2.7.0/tests/utils/test_watershed.py` & `landlab-2.8.0/tests/utils/test_watershed.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,19 +1,17 @@
 #!/usr/bin/env python
 import numpy as np
 import pytest
 
 from landlab import RasterModelGrid
 from landlab.components import FlowAccumulator
-from landlab.utils import (
-    get_watershed_mask,
-    get_watershed_masks_with_area_threshold,
-    get_watershed_nodes,
-    get_watershed_outlet,
-)
+from landlab.utils import get_watershed_mask
+from landlab.utils import get_watershed_masks_with_area_threshold
+from landlab.utils import get_watershed_nodes
+from landlab.utils import get_watershed_outlet
 
 
 def test_get_watershed_nodes():
     grid = RasterModelGrid((7, 7))
 
     z = np.array(
         [
```

### Comparing `landlab-2.7.0/tests/utils/test_window_statistic.py` & `landlab-2.8.0/tests/utils/test_window_statistic.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,18 @@
 Created on Wed Jan 13 15:34:08 2021
 
 @author: laure
 """
 
 import numpy as np
 
-from landlab import HexModelGrid, RadialModelGrid, RasterModelGrid, VoronoiDelaunayGrid
+from landlab import HexModelGrid
+from landlab import RadialModelGrid
+from landlab import RasterModelGrid
+from landlab import VoronoiDelaunayGrid
 from landlab.utils.window_statistic import calculate_window_statistic
 
 
 def test_hex_grid():
     grid = HexModelGrid((5, 4), spacing=10)
     grid.status_at_node[grid.status_at_node == 1] = grid.BC_NODE_IS_CLOSED
     z = grid.add_zeros("topographic__elevation", at="node")
```

### Comparing `landlab-2.7.0/tests/values/conftest.py` & `landlab-2.8.0/tests/values/conftest.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 import pytest
 
-from landlab import NetworkModelGrid, RasterModelGrid
+from landlab import NetworkModelGrid
+from landlab import RasterModelGrid
 from landlab.values.synthetic import _STATUS
 
 
 @pytest.fixture
 def four_by_four_raster():
     mg = RasterModelGrid((4, 4))
     return mg
```

### Comparing `landlab-2.7.0/tests/values/test_synthetic.py` & `landlab-2.8.0/tests/values/test_synthetic.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,16 +2,20 @@
 import pytest
 from hypothesis import given
 from hypothesis.strategies import text
 from numpy.testing import assert_array_equal
 
 from landlab import RasterModelGrid
 from landlab.field import GroupError
-from landlab.values import constant, plane, random, units
-from landlab.values.synthetic import _plane_function, _where_to_add_values
+from landlab.values import constant
+from landlab.values import plane
+from landlab.values import random
+from landlab.values import units
+from landlab.values.synthetic import _plane_function
+from landlab.values.synthetic import _where_to_add_values
 
 _NORMAL = (1, 1, 1)
 _POINT = (0, 0, 0)
 
 
 @given(name=text(), unit_str=text())
 def test_add_units_missing_field(at, name, unit_str):
```

